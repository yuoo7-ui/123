import './style.css';
var HR = Object.defineProperty;
var VR = (e, t, n) => t in e ? HR(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Se = (e, t, n) => VR(e, typeof t != "symbol" ? t + "" : t, n);
import * as w from "react";
import bt, { forwardRef as _n, useState as ht, useEffect as $t, useCallback as Et, useLayoutEffect as mo, useRef as Pt, createContext as Yu, useContext as Pi, useId as ZR, memo as Ju, useMemo as Sr } from "react";
import * as JS from "react-dom";
import { createPortal as KR } from "react-dom";
const GR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
let Al;
const YR = new Uint8Array(16);
function JR() {
  if (!Al && (Al = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Al))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Al(YR);
}
const Qt = [];
for (let e = 0; e < 256; ++e)
  Qt.push((e + 256).toString(16).slice(1));
function XR(e, t = 0) {
  return Qt[e[t + 0]] + Qt[e[t + 1]] + Qt[e[t + 2]] + Qt[e[t + 3]] + "-" + Qt[e[t + 4]] + Qt[e[t + 5]] + "-" + Qt[e[t + 6]] + Qt[e[t + 7]] + "-" + Qt[e[t + 8]] + Qt[e[t + 9]] + "-" + Qt[e[t + 10]] + Qt[e[t + 11]] + Qt[e[t + 12]] + Qt[e[t + 13]] + Qt[e[t + 14]] + Qt[e[t + 15]];
}
const QR = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), _y = {
  randomUUID: QR
};
function Qo(e, t, n) {
  if (_y.randomUUID && !t && !e)
    return _y.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || JR)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, XR(r);
}
const Qs = (e) => ({
  block: e,
  type: "bubble"
}), XS = (e) => {
  const t = e.title, n = e.subtitle, r = e.imageUrl, i = e.actions.map((o) => {
    switch (o.action) {
      case "postback":
        return {
          type: "button",
          variant: "action",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      case "url":
        return {
          type: "button",
          variant: "link",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      case "say":
        return {
          type: "button",
          variant: "action",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      default:
        throw new Error(`Unknown action type ${o.action}`);
    }
  }), a = [];
  return r && a.push({
    type: "image",
    url: r
  }), t && a.push({
    type: "text",
    text: `## ${t}`
  }), n && a.push({
    type: "text",
    text: n
  }), i.length > 0 && a.push({
    type: "row",
    blocks: i
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...a]
  };
}, QS = (e) => ({
  payload: { type: "audio", url: e.audioUrl }
}), eI = (e) => ({
  payload: Qs(XS(e))
}), tI = (e) => ({
  payload: {
    type: "carousel",
    blocks: e.items.map((t) => XS(t))
  }
}), nI = (e) => {
  const t = e.options.map((a) => ({ title: a.label, value: a.value })), n = e.text, r = Qo(), i = Qs({
    type: "text",
    text: n
  });
  return t.length === 0 ? {
    disableInput: e.disableFreeText,
    payload: i
  } : {
    disableInput: e.disableFreeText,
    payload: {
      type: "column",
      horizontalAlignment: "left",
      blocks: [
        i,
        {
          type: "row",
          blocks: t.map(({ title: a, value: o }) => ({
            type: "button",
            variant: "action",
            text: a,
            buttonValue: o,
            groupId: r
          }))
        }
      ]
    }
  };
}, rI = (e) => {
  const t = e.options.map((i) => ({ label: i.label, value: i.value })), n = e.text, r = [
    {
      type: "dropdown",
      label: n ?? "Select an option",
      options: t
    }
  ];
  return n && r.unshift({
    type: "text",
    text: n
  }), {
    disableInput: !0,
    payload: Qs({
      type: "column",
      blocks: r
    })
  };
}, eE = (e) => ({
  payload: {
    type: "file",
    url: e.fileUrl,
    title: e.title
  }
}), tE = (e) => ({
  payload: { type: "image", url: e.imageUrl }
}), nE = (e) => ({
  payload: {
    type: "location",
    latitude: e.latitude,
    longitude: e.longitude,
    title: e.title ?? e.address ?? "View on map"
  }
}), rE = (e) => ({
  payload: Qs({ type: "text", text: e.markdown })
}), iE = (e) => ({
  payload: Qs({ type: "text", text: e.text, value: e.value })
}), aE = (e) => ({
  payload: { type: "video", url: e.videoUrl }
}), iI = (e) => ({ payload: {
  type: "column",
  blocks: e.items.map((n) => {
    switch (n.type) {
      case "audio":
        return QS({ ...n.payload, type: n.type }).payload;
      case "file":
        return eE({ ...n.payload, type: n.type }).payload;
      case "image":
        return tE({ ...n.payload, type: n.type }).payload;
      case "location":
        return nE({ ...n.payload, type: n.type }).payload;
      case "markdown":
        return rE({ ...n.payload, type: n.type }).payload;
      case "text":
        return iE({ ...n.payload, type: n.type }).payload;
      case "video":
        return aE({ ...n.payload, type: n.type }).payload;
      default:
        throw new Error("Unsuported message type");
    }
  })
} }), cs = (e) => {
  switch (e.type) {
    case "audio":
      return QS(e);
    case "card":
      return eI(e);
    case "carousel":
      return tI(e);
    case "choice":
      return nI(e);
    case "dropdown":
      return rI(e);
    case "file":
      return eE(e);
    case "image":
      return tE(e);
    case "location":
      return nE(e);
    case "markdown":
      return rE(e);
    case "text":
      return iE(e);
    case "video":
      return aE(e);
    case "bloc":
      return iI(e);
    default:
      throw new Error("Unsuported message type");
  }
}, aI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messageAdapter: cs
}, Symbol.toStringTag, { value: "Module" })), Ppe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  target: GR,
  webchatToTarget: aI
}, Symbol.toStringTag, { value: "Module" }));
var ft = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ze(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function oI(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var rh = { exports: {} }, Co = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ky;
function sI() {
  if (ky) return Co;
  ky = 1;
  var e = bt, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(s, l, c) {
    var u, f = {}, d = null, p = null;
    c !== void 0 && (d = "" + c), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (p = l.ref);
    for (u in l) r.call(l, u) && !a.hasOwnProperty(u) && (f[u] = l[u]);
    if (s && s.defaultProps) for (u in l = s.defaultProps, l) f[u] === void 0 && (f[u] = l[u]);
    return { $$typeof: t, type: s, key: d, ref: p, props: f, _owner: i.current };
  }
  return Co.Fragment = n, Co.jsx = o, Co.jsxs = o, Co;
}
var Ro = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $y;
function lI() {
  return $y || ($y = 1, process.env.NODE_ENV !== "production" && function() {
    var e = bt, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), h = Symbol.iterator, m = "@@iterator";
    function y(T) {
      if (T === null || typeof T != "object")
        return null;
      var ee = h && T[h] || T[m];
      return typeof ee == "function" ? ee : null;
    }
    var v = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(T) {
      {
        for (var ee = arguments.length, ve = new Array(ee > 1 ? ee - 1 : 0), Ne = 1; Ne < ee; Ne++)
          ve[Ne - 1] = arguments[Ne];
        b("error", T, ve);
      }
    }
    function b(T, ee, ve) {
      {
        var Ne = v.ReactDebugCurrentFrame, lt = Ne.getStackAddendum();
        lt !== "" && (ee += "%s", ve = ve.concat([lt]));
        var vt = ve.map(function(Xe) {
          return String(Xe);
        });
        vt.unshift("Warning: " + ee), Function.prototype.apply.call(console[T], console, vt);
      }
    }
    var k = !1, S = !1, _ = !1, $ = !1, j = !1, B;
    B = Symbol.for("react.module.reference");
    function O(T) {
      return !!(typeof T == "string" || typeof T == "function" || T === r || T === a || j || T === i || T === c || T === u || $ || T === p || k || S || _ || typeof T == "object" && T !== null && (T.$$typeof === d || T.$$typeof === f || T.$$typeof === o || T.$$typeof === s || T.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      T.$$typeof === B || T.getModuleId !== void 0));
    }
    function N(T, ee, ve) {
      var Ne = T.displayName;
      if (Ne)
        return Ne;
      var lt = ee.displayName || ee.name || "";
      return lt !== "" ? ve + "(" + lt + ")" : ve;
    }
    function q(T) {
      return T.displayName || "Context";
    }
    function M(T) {
      if (T == null)
        return null;
      if (typeof T.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof T == "function")
        return T.displayName || T.name || null;
      if (typeof T == "string")
        return T;
      switch (T) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case a:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case s:
            var ee = T;
            return q(ee) + ".Consumer";
          case o:
            var ve = T;
            return q(ve._context) + ".Provider";
          case l:
            return N(T, T.render, "ForwardRef");
          case f:
            var Ne = T.displayName || null;
            return Ne !== null ? Ne : M(T.type) || "Memo";
          case d: {
            var lt = T, vt = lt._payload, Xe = lt._init;
            try {
              return M(Xe(vt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, D = 0, R, W, F, A, x, U, Z;
    function E() {
    }
    E.__reactDisabledLog = !0;
    function X() {
      {
        if (D === 0) {
          R = console.log, W = console.info, F = console.warn, A = console.error, x = console.group, U = console.groupCollapsed, Z = console.groupEnd;
          var T = {
            configurable: !0,
            enumerable: !0,
            value: E,
            writable: !0
          };
          Object.defineProperties(console, {
            info: T,
            log: T,
            warn: T,
            error: T,
            group: T,
            groupCollapsed: T,
            groupEnd: T
          });
        }
        D++;
      }
    }
    function ae() {
      {
        if (D--, D === 0) {
          var T = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, T, {
              value: R
            }),
            info: z({}, T, {
              value: W
            }),
            warn: z({}, T, {
              value: F
            }),
            error: z({}, T, {
              value: A
            }),
            group: z({}, T, {
              value: x
            }),
            groupCollapsed: z({}, T, {
              value: U
            }),
            groupEnd: z({}, T, {
              value: Z
            })
          });
        }
        D < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var te = v.ReactCurrentDispatcher, se;
    function de(T, ee, ve) {
      {
        if (se === void 0)
          try {
            throw Error();
          } catch (lt) {
            var Ne = lt.stack.trim().match(/\n( *(at )?)/);
            se = Ne && Ne[1] || "";
          }
        return `
` + se + T;
      }
    }
    var pe = !1, le;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      le = new J();
    }
    function V(T, ee) {
      if (!T || pe)
        return "";
      {
        var ve = le.get(T);
        if (ve !== void 0)
          return ve;
      }
      var Ne;
      pe = !0;
      var lt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var vt;
      vt = te.current, te.current = null, X();
      try {
        if (ee) {
          var Xe = function() {
            throw Error();
          };
          if (Object.defineProperty(Xe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Xe, []);
            } catch (gn) {
              Ne = gn;
            }
            Reflect.construct(T, [], Xe);
          } else {
            try {
              Xe.call();
            } catch (gn) {
              Ne = gn;
            }
            T.call(Xe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (gn) {
            Ne = gn;
          }
          T();
        }
      } catch (gn) {
        if (gn && Ne && typeof gn.stack == "string") {
          for (var Ke = gn.stack.split(`
`), fn = Ne.stack.split(`
`), At = Ke.length - 1, jt = fn.length - 1; At >= 1 && jt >= 0 && Ke[At] !== fn[jt]; )
            jt--;
          for (; At >= 1 && jt >= 0; At--, jt--)
            if (Ke[At] !== fn[jt]) {
              if (At !== 1 || jt !== 1)
                do
                  if (At--, jt--, jt < 0 || Ke[At] !== fn[jt]) {
                    var Ln = `
` + Ke[At].replace(" at new ", " at ");
                    return T.displayName && Ln.includes("<anonymous>") && (Ln = Ln.replace("<anonymous>", T.displayName)), typeof T == "function" && le.set(T, Ln), Ln;
                  }
                while (At >= 1 && jt >= 0);
              break;
            }
        }
      } finally {
        pe = !1, te.current = vt, ae(), Error.prepareStackTrace = lt;
      }
      var ya = T ? T.displayName || T.name : "", zi = ya ? de(ya) : "";
      return typeof T == "function" && le.set(T, zi), zi;
    }
    function fe(T, ee, ve) {
      return V(T, !1);
    }
    function me(T) {
      var ee = T.prototype;
      return !!(ee && ee.isReactComponent);
    }
    function Oe(T, ee, ve) {
      if (T == null)
        return "";
      if (typeof T == "function")
        return V(T, me(T));
      if (typeof T == "string")
        return de(T);
      switch (T) {
        case c:
          return de("Suspense");
        case u:
          return de("SuspenseList");
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case l:
            return fe(T.render);
          case f:
            return Oe(T.type, ee, ve);
          case d: {
            var Ne = T, lt = Ne._payload, vt = Ne._init;
            try {
              return Oe(vt(lt), ee, ve);
            } catch {
            }
          }
        }
      return "";
    }
    var I = Object.prototype.hasOwnProperty, G = {}, re = v.ReactDebugCurrentFrame;
    function Q(T) {
      if (T) {
        var ee = T._owner, ve = Oe(T.type, T._source, ee ? ee.type : null);
        re.setExtraStackFrame(ve);
      } else
        re.setExtraStackFrame(null);
    }
    function _e(T, ee, ve, Ne, lt) {
      {
        var vt = Function.call.bind(I);
        for (var Xe in T)
          if (vt(T, Xe)) {
            var Ke = void 0;
            try {
              if (typeof T[Xe] != "function") {
                var fn = Error((Ne || "React class") + ": " + ve + " type `" + Xe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof T[Xe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw fn.name = "Invariant Violation", fn;
              }
              Ke = T[Xe](ee, Xe, Ne, ve, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (At) {
              Ke = At;
            }
            Ke && !(Ke instanceof Error) && (Q(lt), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ne || "React class", ve, Xe, typeof Ke), Q(null)), Ke instanceof Error && !(Ke.message in G) && (G[Ke.message] = !0, Q(lt), g("Failed %s type: %s", ve, Ke.message), Q(null));
          }
      }
    }
    var xe = Array.isArray;
    function Ce(T) {
      return xe(T);
    }
    function We(T) {
      {
        var ee = typeof Symbol == "function" && Symbol.toStringTag, ve = ee && T[Symbol.toStringTag] || T.constructor.name || "Object";
        return ve;
      }
    }
    function Ie(T) {
      try {
        return Me(T), !1;
      } catch {
        return !0;
      }
    }
    function Me(T) {
      return "" + T;
    }
    function L(T) {
      if (Ie(T))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", We(T)), Me(T);
    }
    var P = v.ReactCurrentOwner, Y = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ce, Ee, $e;
    $e = {};
    function Ye(T) {
      if (I.call(T, "ref")) {
        var ee = Object.getOwnPropertyDescriptor(T, "ref").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return T.ref !== void 0;
    }
    function at(T) {
      if (I.call(T, "key")) {
        var ee = Object.getOwnPropertyDescriptor(T, "key").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return T.key !== void 0;
    }
    function Bt(T, ee) {
      if (typeof T.ref == "string" && P.current && ee && P.current.stateNode !== ee) {
        var ve = M(P.current.type);
        $e[ve] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(P.current.type), T.ref), $e[ve] = !0);
      }
    }
    function Rt(T, ee) {
      {
        var ve = function() {
          ce || (ce = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ve.isReactWarning = !0, Object.defineProperty(T, "key", {
          get: ve,
          configurable: !0
        });
      }
    }
    function He(T, ee) {
      {
        var ve = function() {
          Ee || (Ee = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ve.isReactWarning = !0, Object.defineProperty(T, "ref", {
          get: ve,
          configurable: !0
        });
      }
    }
    var It = function(T, ee, ve, Ne, lt, vt, Xe) {
      var Ke = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: T,
        key: ee,
        ref: ve,
        props: Xe,
        // Record the component responsible for creating this element.
        _owner: vt
      };
      return Ke._store = {}, Object.defineProperty(Ke._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ke, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ne
      }), Object.defineProperty(Ke, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lt
      }), Object.freeze && (Object.freeze(Ke.props), Object.freeze(Ke)), Ke;
    };
    function Je(T, ee, ve, Ne, lt) {
      {
        var vt, Xe = {}, Ke = null, fn = null;
        ve !== void 0 && (L(ve), Ke = "" + ve), at(ee) && (L(ee.key), Ke = "" + ee.key), Ye(ee) && (fn = ee.ref, Bt(ee, lt));
        for (vt in ee)
          I.call(ee, vt) && !Y.hasOwnProperty(vt) && (Xe[vt] = ee[vt]);
        if (T && T.defaultProps) {
          var At = T.defaultProps;
          for (vt in At)
            Xe[vt] === void 0 && (Xe[vt] = At[vt]);
        }
        if (Ke || fn) {
          var jt = typeof T == "function" ? T.displayName || T.name || "Unknown" : T;
          Ke && Rt(Xe, jt), fn && He(Xe, jt);
        }
        return It(T, Ke, fn, lt, Ne, P.current, Xe);
      }
    }
    var vn = v.ReactCurrentOwner, On = v.ReactDebugCurrentFrame;
    function Yn(T) {
      if (T) {
        var ee = T._owner, ve = Oe(T.type, T._source, ee ? ee.type : null);
        On.setExtraStackFrame(ve);
      } else
        On.setExtraStackFrame(null);
    }
    var Ur;
    Ur = !1;
    function mr(T) {
      return typeof T == "object" && T !== null && T.$$typeof === t;
    }
    function Jn() {
      {
        if (vn.current) {
          var T = M(vn.current.type);
          if (T)
            return `

Check the render method of \`` + T + "`.";
        }
        return "";
      }
    }
    function qr(T) {
      return "";
    }
    var dt = {};
    function St(T) {
      {
        var ee = Jn();
        if (!ee) {
          var ve = typeof T == "string" ? T : T.displayName || T.name;
          ve && (ee = `

Check the top-level render call using <` + ve + ">.");
        }
        return ee;
      }
    }
    function zt(T, ee) {
      {
        if (!T._store || T._store.validated || T.key != null)
          return;
        T._store.validated = !0;
        var ve = St(ee);
        if (dt[ve])
          return;
        dt[ve] = !0;
        var Ne = "";
        T && T._owner && T._owner !== vn.current && (Ne = " It was passed a child from " + M(T._owner.type) + "."), Yn(T), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ve, Ne), Yn(null);
      }
    }
    function Ut(T, ee) {
      {
        if (typeof T != "object")
          return;
        if (Ce(T))
          for (var ve = 0; ve < T.length; ve++) {
            var Ne = T[ve];
            mr(Ne) && zt(Ne, ee);
          }
        else if (mr(T))
          T._store && (T._store.validated = !0);
        else if (T) {
          var lt = y(T);
          if (typeof lt == "function" && lt !== T.entries)
            for (var vt = lt.call(T), Xe; !(Xe = vt.next()).done; )
              mr(Xe.value) && zt(Xe.value, ee);
        }
      }
    }
    function Xt(T) {
      {
        var ee = T.type;
        if (ee == null || typeof ee == "string")
          return;
        var ve;
        if (typeof ee == "function")
          ve = ee.propTypes;
        else if (typeof ee == "object" && (ee.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ee.$$typeof === f))
          ve = ee.propTypes;
        else
          return;
        if (ve) {
          var Ne = M(ee);
          _e(ve, T.props, "prop", Ne, T);
        } else if (ee.PropTypes !== void 0 && !Ur) {
          Ur = !0;
          var lt = M(ee);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", lt || "Unknown");
        }
        typeof ee.getDefaultProps == "function" && !ee.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function qt(T) {
      {
        for (var ee = Object.keys(T.props), ve = 0; ve < ee.length; ve++) {
          var Ne = ee[ve];
          if (Ne !== "children" && Ne !== "key") {
            Yn(T), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ne), Yn(null);
            break;
          }
        }
        T.ref !== null && (Yn(T), g("Invalid attribute `ref` supplied to `React.Fragment`."), Yn(null));
      }
    }
    var Dn = {};
    function Mn(T, ee, ve, Ne, lt, vt) {
      {
        var Xe = O(T);
        if (!Xe) {
          var Ke = "";
          (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (Ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var fn = qr();
          fn ? Ke += fn : Ke += Jn();
          var At;
          T === null ? At = "null" : Ce(T) ? At = "array" : T !== void 0 && T.$$typeof === t ? (At = "<" + (M(T.type) || "Unknown") + " />", Ke = " Did you accidentally export a JSX literal instead of a component?") : At = typeof T, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", At, Ke);
        }
        var jt = Je(T, ee, ve, lt, vt);
        if (jt == null)
          return jt;
        if (Xe) {
          var Ln = ee.children;
          if (Ln !== void 0)
            if (Ne)
              if (Ce(Ln)) {
                for (var ya = 0; ya < Ln.length; ya++)
                  Ut(Ln[ya], T);
                Object.freeze && Object.freeze(Ln);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ut(Ln, T);
        }
        if (I.call(ee, "key")) {
          var zi = M(T), gn = Object.keys(ee).filter(function(WR) {
            return WR !== "key";
          }), Kf = gn.length > 0 ? "{key: someKey, " + gn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Dn[zi + Kf]) {
            var qR = gn.length > 0 ? "{" + gn.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Kf, zi, qR, zi), Dn[zi + Kf] = !0;
          }
        }
        return T === r ? qt(jt) : Xt(jt), jt;
      }
    }
    function si(T, ee, ve) {
      return Mn(T, ee, ve, !0);
    }
    function BR(T, ee, ve) {
      return Mn(T, ee, ve, !1);
    }
    var zR = BR, UR = si;
    Ro.Fragment = r, Ro.jsx = zR, Ro.jsxs = UR;
  }()), Ro;
}
process.env.NODE_ENV === "production" ? rh.exports = sI() : rh.exports = lI();
var C = rh.exports;
function cI(e, t = []) {
  let n = [];
  function r(a, o) {
    const s = w.createContext(o), l = n.length;
    n = [...n, o];
    function c(f) {
      const { scope: d, children: p, ...h } = f, m = (d == null ? void 0 : d[e][l]) || s, y = w.useMemo(() => h, Object.values(h));
      return /* @__PURE__ */ C.jsx(m.Provider, { value: y, children: p });
    }
    function u(f, d) {
      const p = (d == null ? void 0 : d[e][l]) || s, h = w.useContext(p);
      if (h) return h;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${a}\``);
    }
    return c.displayName = a + "Provider", [c, u];
  }
  const i = () => {
    const a = n.map((o) => w.createContext(o));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || a;
      return w.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, uI(i, ...t)];
}
function uI(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const o = r.reduce((s, { useScope: l, scopeName: c }) => {
        const f = l(a)[`__scope${c}`];
        return { ...s, ...f };
      }, {});
      return w.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function _i(e) {
  const t = w.useRef(e);
  return w.useEffect(() => {
    t.current = e;
  }), w.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
var Za = globalThis != null && globalThis.document ? w.useLayoutEffect : () => {
};
function fI(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function oE(...e) {
  return (t) => e.forEach((n) => fI(n, t));
}
function ji(...e) {
  return w.useCallback(oE(...e), e);
}
var Vm = w.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = w.Children.toArray(n), a = i.find(pI);
  if (a) {
    const o = a.props.children, s = i.map((l) => l === a ? w.Children.count(o) > 1 ? w.Children.only(null) : w.isValidElement(o) ? o.props.children : null : l);
    return /* @__PURE__ */ C.jsx(ih, { ...r, ref: t, children: w.isValidElement(o) ? w.cloneElement(o, void 0, s) : null });
  }
  return /* @__PURE__ */ C.jsx(ih, { ...r, ref: t, children: n });
});
Vm.displayName = "Slot";
var ih = w.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (w.isValidElement(n)) {
    const i = mI(n);
    return w.cloneElement(n, {
      ...hI(r, n.props),
      // @ts-ignore
      ref: t ? oE(t, i) : i
    });
  }
  return w.Children.count(n) > 1 ? w.Children.only(null) : null;
});
ih.displayName = "SlotClone";
var dI = ({ children: e }) => /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
function pI(e) {
  return w.isValidElement(e) && e.type === dI;
}
function hI(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function mI(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var vI = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], kn = vI.reduce((e, t) => {
  const n = w.forwardRef((r, i) => {
    const { asChild: a, ...o } = r, s = a ? Vm : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ C.jsx(s, { ...o, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function gI(e, t) {
  e && JS.flushSync(() => e.dispatchEvent(t));
}
var Zm = "Avatar", [yI, jpe] = cI(Zm), [bI, sE] = yI(Zm), Km = w.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, a] = w.useState("idle");
    return /* @__PURE__ */ C.jsx(
      bI,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: a,
        children: /* @__PURE__ */ C.jsx(kn.span, { ...r, ref: t })
      }
    );
  }
);
Km.displayName = Zm;
var lE = "AvatarImage", Gm = w.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...a } = e, o = sE(lE, n), s = xI(r), l = _i((c) => {
      i(c), o.onImageLoadingStatusChange(c);
    });
    return Za(() => {
      s !== "idle" && l(s);
    }, [s, l]), s === "loaded" ? /* @__PURE__ */ C.jsx(kn.img, { ...a, ref: t, src: r }) : null;
  }
);
Gm.displayName = lE;
var cE = "AvatarFallback", Ym = w.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, a = sE(cE, n), [o, s] = w.useState(r === void 0);
    return w.useEffect(() => {
      if (r !== void 0) {
        const l = window.setTimeout(() => s(!0), r);
        return () => window.clearTimeout(l);
      }
    }, [r]), o && a.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ C.jsx(kn.span, { ...i, ref: t }) : null;
  }
);
Ym.displayName = cE;
function xI(e) {
  const [t, n] = w.useState("idle");
  return Za(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), a = (o) => () => {
      r && n(o);
    };
    return n("loading"), i.onload = a("loaded"), i.onerror = a("error"), i.src = e, () => {
      r = !1;
    };
  }, [e]), t;
}
function ah(e) {
  if (!/^#?([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(e))
    return { r: 0, g: 0, b: 0 };
  const n = e.replace(/^#/, "");
  let r = n;
  n.length === 3 && (r = n.split("").map((l) => l + l).join(""));
  const i = parseInt(r, 16), a = i >> 16 & 255, o = i >> 8 & 255, s = i & 255;
  return { r: a, g: o, b: s };
}
function wI(e) {
  return `#${((1 << 24) + (e.r << 16) + (e.g << 8) + e.b).toString(16).slice(1)}`;
}
const SI = (e, t = 30) => {
  const n = Math.min(e.r, e.g, e.b), r = Math.max(e.r, e.g, e.b, n + 1);
  return {
    r: Math.floor((e.r - n) / (r - n) * t * (1 - 0.299) + 120 - t / 2),
    g: Math.floor((e.g - n) / (r - n) * t * (1 - 0.587) + 120 - t / 2),
    b: Math.floor((e.b - n) / (r - n) * t * (1 - 0.114) + 120 - t / 2)
  };
};
function Oy(e) {
  return Object.entries(e).reduce((t, [n, r]) => {
    const i = n.replace(/(\d+)/, (a) => (1e3 - parseInt(a)).toString());
    return { ...t, [i]: r };
  }, {});
}
const EI = 2.4, _I = 0.2126729, kI = 0.7151522, $I = 0.072175, OI = 0.56, TI = 0.57, CI = 0.62, RI = 0.65, Pl = 0.022, Ty = 1.414, II = 1.14, AI = 1.14, PI = 0.035991, jI = 0.035991, NI = 27.7847239587675, DI = 27.7847239587675, Cy = 0.027, Ry = 0.027, Iy = 1e-3, MI = 5e-4;
function Ay(e) {
  const { r: t, g: n, b: r } = e, i = (a) => (a / 255) ** EI;
  return _I * i(t) + kI * i(n) + $I * i(r);
}
function Py(e, t) {
  if (!e || !t)
    return 0;
  let n = Ay(ah(e)), r = Ay(ah(t)), i = 0, a = 0;
  return n = n > Pl ? n : n + (Pl - n) ** Ty, r = r > Pl ? r : r + (Pl - r) ** Ty, Math.abs(r - n) < MI ? 0 : (r > n ? (i = (r ** OI - n ** TI) * II, a = i < Iy ? 0 : i < PI ? i - i * NI * Cy : i - Cy) : (i = (r ** RI - n ** CI) * AI, a = i > -Iy ? 0 : i > -jI ? i - i * DI * Ry : i + Ry), Math.abs(a * 100));
}
let uE = class {
  constructor() {
    Se(this, "eventMap");
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((a) => {
      a(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((a) => {
      a({ type: t, payload: n });
    });
  }
};
const LI = new uE();
function jy(e, t) {
  let n = `${e} {`;
  for (const [r, i] of Object.entries(t))
    n += `${r}: ${i}; `;
  return n += "}", n;
}
function fE(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
var dE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(ft, function() {
    var n = 1e3, r = 6e4, i = 36e5, a = "millisecond", o = "second", s = "minute", l = "hour", c = "day", u = "week", f = "month", d = "quarter", p = "year", h = "date", m = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, v = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, g = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(z) {
      var D = ["th", "st", "nd", "rd"], R = z % 100;
      return "[" + z + (D[(R - 20) % 10] || D[R] || D[0]) + "]";
    } }, b = function(z, D, R) {
      var W = String(z);
      return !W || W.length >= D ? z : "" + Array(D + 1 - W.length).join(R) + z;
    }, k = { s: b, z: function(z) {
      var D = -z.utcOffset(), R = Math.abs(D), W = Math.floor(R / 60), F = R % 60;
      return (D <= 0 ? "+" : "-") + b(W, 2, "0") + ":" + b(F, 2, "0");
    }, m: function z(D, R) {
      if (D.date() < R.date()) return -z(R, D);
      var W = 12 * (R.year() - D.year()) + (R.month() - D.month()), F = D.clone().add(W, f), A = R - F < 0, x = D.clone().add(W + (A ? -1 : 1), f);
      return +(-(W + (R - F) / (A ? F - x : x - F)) || 0);
    }, a: function(z) {
      return z < 0 ? Math.ceil(z) || 0 : Math.floor(z);
    }, p: function(z) {
      return { M: f, y: p, w: u, d: c, D: h, h: l, m: s, s: o, ms: a, Q: d }[z] || String(z || "").toLowerCase().replace(/s$/, "");
    }, u: function(z) {
      return z === void 0;
    } }, S = "en", _ = {};
    _[S] = g;
    var $ = "$isDayjsObject", j = function(z) {
      return z instanceof q || !(!z || !z[$]);
    }, B = function z(D, R, W) {
      var F;
      if (!D) return S;
      if (typeof D == "string") {
        var A = D.toLowerCase();
        _[A] && (F = A), R && (_[A] = R, F = A);
        var x = D.split("-");
        if (!F && x.length > 1) return z(x[0]);
      } else {
        var U = D.name;
        _[U] = D, F = U;
      }
      return !W && F && (S = F), F || !W && S;
    }, O = function(z, D) {
      if (j(z)) return z.clone();
      var R = typeof D == "object" ? D : {};
      return R.date = z, R.args = arguments, new q(R);
    }, N = k;
    N.l = B, N.i = j, N.w = function(z, D) {
      return O(z, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var q = function() {
      function z(R) {
        this.$L = B(R.locale, null, !0), this.parse(R), this.$x = this.$x || R.x || {}, this[$] = !0;
      }
      var D = z.prototype;
      return D.parse = function(R) {
        this.$d = function(W) {
          var F = W.date, A = W.utc;
          if (F === null) return /* @__PURE__ */ new Date(NaN);
          if (N.u(F)) return /* @__PURE__ */ new Date();
          if (F instanceof Date) return new Date(F);
          if (typeof F == "string" && !/Z$/i.test(F)) {
            var x = F.match(y);
            if (x) {
              var U = x[2] - 1 || 0, Z = (x[7] || "0").substring(0, 3);
              return A ? new Date(Date.UTC(x[1], U, x[3] || 1, x[4] || 0, x[5] || 0, x[6] || 0, Z)) : new Date(x[1], U, x[3] || 1, x[4] || 0, x[5] || 0, x[6] || 0, Z);
            }
          }
          return new Date(F);
        }(R), this.init();
      }, D.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, D.$utils = function() {
        return N;
      }, D.isValid = function() {
        return this.$d.toString() !== m;
      }, D.isSame = function(R, W) {
        var F = O(R);
        return this.startOf(W) <= F && F <= this.endOf(W);
      }, D.isAfter = function(R, W) {
        return O(R) < this.startOf(W);
      }, D.isBefore = function(R, W) {
        return this.endOf(W) < O(R);
      }, D.$g = function(R, W, F) {
        return N.u(R) ? this[W] : this.set(F, R);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(R, W) {
        var F = this, A = !!N.u(W) || W, x = N.p(R), U = function(pe, le) {
          var J = N.w(F.$u ? Date.UTC(F.$y, le, pe) : new Date(F.$y, le, pe), F);
          return A ? J : J.endOf(c);
        }, Z = function(pe, le) {
          return N.w(F.toDate()[pe].apply(F.toDate("s"), (A ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(le)), F);
        }, E = this.$W, X = this.$M, ae = this.$D, te = "set" + (this.$u ? "UTC" : "");
        switch (x) {
          case p:
            return A ? U(1, 0) : U(31, 11);
          case f:
            return A ? U(1, X) : U(0, X + 1);
          case u:
            var se = this.$locale().weekStart || 0, de = (E < se ? E + 7 : E) - se;
            return U(A ? ae - de : ae + (6 - de), X);
          case c:
          case h:
            return Z(te + "Hours", 0);
          case l:
            return Z(te + "Minutes", 1);
          case s:
            return Z(te + "Seconds", 2);
          case o:
            return Z(te + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(R) {
        return this.startOf(R, !1);
      }, D.$set = function(R, W) {
        var F, A = N.p(R), x = "set" + (this.$u ? "UTC" : ""), U = (F = {}, F[c] = x + "Date", F[h] = x + "Date", F[f] = x + "Month", F[p] = x + "FullYear", F[l] = x + "Hours", F[s] = x + "Minutes", F[o] = x + "Seconds", F[a] = x + "Milliseconds", F)[A], Z = A === c ? this.$D + (W - this.$W) : W;
        if (A === f || A === p) {
          var E = this.clone().set(h, 1);
          E.$d[U](Z), E.init(), this.$d = E.set(h, Math.min(this.$D, E.daysInMonth())).$d;
        } else U && this.$d[U](Z);
        return this.init(), this;
      }, D.set = function(R, W) {
        return this.clone().$set(R, W);
      }, D.get = function(R) {
        return this[N.p(R)]();
      }, D.add = function(R, W) {
        var F, A = this;
        R = Number(R);
        var x = N.p(W), U = function(X) {
          var ae = O(A);
          return N.w(ae.date(ae.date() + Math.round(X * R)), A);
        };
        if (x === f) return this.set(f, this.$M + R);
        if (x === p) return this.set(p, this.$y + R);
        if (x === c) return U(1);
        if (x === u) return U(7);
        var Z = (F = {}, F[s] = r, F[l] = i, F[o] = n, F)[x] || 1, E = this.$d.getTime() + R * Z;
        return N.w(E, this);
      }, D.subtract = function(R, W) {
        return this.add(-1 * R, W);
      }, D.format = function(R) {
        var W = this, F = this.$locale();
        if (!this.isValid()) return F.invalidDate || m;
        var A = R || "YYYY-MM-DDTHH:mm:ssZ", x = N.z(this), U = this.$H, Z = this.$m, E = this.$M, X = F.weekdays, ae = F.months, te = F.meridiem, se = function(le, J, V, fe) {
          return le && (le[J] || le(W, A)) || V[J].slice(0, fe);
        }, de = function(le) {
          return N.s(U % 12 || 12, le, "0");
        }, pe = te || function(le, J, V) {
          var fe = le < 12 ? "AM" : "PM";
          return V ? fe.toLowerCase() : fe;
        };
        return A.replace(v, function(le, J) {
          return J || function(V) {
            switch (V) {
              case "YY":
                return String(W.$y).slice(-2);
              case "YYYY":
                return N.s(W.$y, 4, "0");
              case "M":
                return E + 1;
              case "MM":
                return N.s(E + 1, 2, "0");
              case "MMM":
                return se(F.monthsShort, E, ae, 3);
              case "MMMM":
                return se(ae, E);
              case "D":
                return W.$D;
              case "DD":
                return N.s(W.$D, 2, "0");
              case "d":
                return String(W.$W);
              case "dd":
                return se(F.weekdaysMin, W.$W, X, 2);
              case "ddd":
                return se(F.weekdaysShort, W.$W, X, 3);
              case "dddd":
                return X[W.$W];
              case "H":
                return String(U);
              case "HH":
                return N.s(U, 2, "0");
              case "h":
                return de(1);
              case "hh":
                return de(2);
              case "a":
                return pe(U, Z, !0);
              case "A":
                return pe(U, Z, !1);
              case "m":
                return String(Z);
              case "mm":
                return N.s(Z, 2, "0");
              case "s":
                return String(W.$s);
              case "ss":
                return N.s(W.$s, 2, "0");
              case "SSS":
                return N.s(W.$ms, 3, "0");
              case "Z":
                return x;
            }
            return null;
          }(le) || x.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(R, W, F) {
        var A, x = this, U = N.p(W), Z = O(R), E = (Z.utcOffset() - this.utcOffset()) * r, X = this - Z, ae = function() {
          return N.m(x, Z);
        };
        switch (U) {
          case p:
            A = ae() / 12;
            break;
          case f:
            A = ae();
            break;
          case d:
            A = ae() / 3;
            break;
          case u:
            A = (X - E) / 6048e5;
            break;
          case c:
            A = (X - E) / 864e5;
            break;
          case l:
            A = X / i;
            break;
          case s:
            A = X / r;
            break;
          case o:
            A = X / n;
            break;
          default:
            A = X;
        }
        return F ? A : N.a(A);
      }, D.daysInMonth = function() {
        return this.endOf(f).$D;
      }, D.$locale = function() {
        return _[this.$L];
      }, D.locale = function(R, W) {
        if (!R) return this.$L;
        var F = this.clone(), A = B(R, W, !0);
        return A && (F.$L = A), F;
      }, D.clone = function() {
        return N.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, z;
    }(), M = q.prototype;
    return O.prototype = M, [["$ms", a], ["$s", o], ["$m", s], ["$H", l], ["$W", c], ["$M", f], ["$y", p], ["$D", h]].forEach(function(z) {
      M[z[1]] = function(D) {
        return this.$g(D, z[0], z[1]);
      };
    }), O.extend = function(z, D) {
      return z.$i || (z(D, q, O), z.$i = !0), O;
    }, O.locale = B, O.isDayjs = j, O.unix = function(z) {
      return O(1e3 * z);
    }, O.en = _[S], O.Ls = _, O.p = {}, O;
  });
})(dE);
var FI = dE.exports;
const Xu = /* @__PURE__ */ Ze(FI);
var pE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(ft, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var a = "YYYY-MM-DD", o = i();
        return this.format(a) === o.format(a);
      };
    };
  });
})(pE);
var BI = pE.exports;
const zI = /* @__PURE__ */ Ze(BI);
var hE = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(ft, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var a = "YYYY-MM-DD", o = i().subtract(1, "day");
        return this.format(a) === o.format(a);
      };
    };
  });
})(hE);
var UI = hE.exports;
const qI = /* @__PURE__ */ Ze(UI);
Xu.extend(zI);
Xu.extend(qI);
function WI(e, t = "day") {
  var r, i, a;
  if (!e || e.length === 0) return [];
  const n = [];
  (r = e[0]) != null && r.timestamp && n.push(Ny(e[0].timestamp));
  for (let o = 0; o < e.length; o++)
    if (e[o] && n.push(e[o]), o + 1 < e.length) {
      const s = (i = e[o]) == null ? void 0 : i.timestamp, l = (a = e[o + 1]) == null ? void 0 : a.timestamp;
      !Xu(s).isSame(l, t) && l && n.push(Ny(l));
    }
  return n;
}
function Ny(e) {
  return {
    id: Qo(),
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: HI(e)
    }
  };
}
function HI(e, t = !1) {
  const n = Xu(e), r = "h:mma";
  return n.isToday() ? t ? `Today  ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday  ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD  ${r}`) : n.format("YYYY-MM-DD");
}
function VI(e = "") {
  if (typeof e != "string")
    throw new TypeError("Color should be string!");
  const t = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(e);
  if (t)
    return t.splice(1).map((r) => Number.parseInt(r, 16));
  const n = /^#?([\da-f])([\da-f])([\da-f])$/i.exec(e);
  if (n)
    return n.splice(1).map((r) => Number.parseInt(r + r, 16));
  if (e.includes(","))
    return e.split(",").map((r) => Number.parseInt(r));
  throw new Error("Invalid color format! Use #ABC or #AABBCC or r,g,b");
}
function ZI(e) {
  return "#" + e.map((t) => `0${t.toString(16).toUpperCase()}`.slice(-2)).join("");
}
function KI(e, t) {
  return e.map((n) => Math.round(n + (255 - n) * t));
}
function GI(e, t) {
  return e.map((n) => Math.round(n * t));
}
const Io = (e) => (t) => KI(t, e), Ao = (e) => (t) => GI(t, e), YI = {
  50: Io(0.95),
  100: Io(0.9),
  200: Io(0.75),
  300: Io(0.6),
  400: Io(0.3),
  500: (e) => e,
  600: Ao(0.9),
  700: Ao(0.6),
  800: Ao(0.45),
  900: Ao(0.3),
  950: Ao(0.2)
};
function Dy(e, t = YI) {
  const n = {}, r = VI(e);
  for (const [i, a] of Object.entries(t))
    n[i] = ZI(a(r));
  return n;
}
var it;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(it || (it = {}));
var oh;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(oh || (oh = {}));
const ge = it.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), pi = (e) => {
  switch (typeof e) {
    case "undefined":
      return ge.undefined;
    case "string":
      return ge.string;
    case "number":
      return isNaN(e) ? ge.nan : ge.number;
    case "boolean":
      return ge.boolean;
    case "function":
      return ge.function;
    case "bigint":
      return ge.bigint;
    case "symbol":
      return ge.symbol;
    case "object":
      return Array.isArray(e) ? ge.array : e === null ? ge.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ge.promise : typeof Map < "u" && e instanceof Map ? ge.map : typeof Set < "u" && e instanceof Set ? ge.set : typeof Date < "u" && e instanceof Date ? ge.date : ge.object;
    default:
      return ge.unknown;
  }
}, oe = it.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), JI = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let ar = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(n(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], l++;
          }
        }
    };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, it.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
ar.create = (e) => new ar(e);
const us = (e, t) => {
  let n;
  switch (e.code) {
    case oe.invalid_type:
      e.received === ge.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case oe.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, it.jsonStringifyReplacer)}`;
      break;
    case oe.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${it.joinValues(e.keys, ", ")}`;
      break;
    case oe.invalid_union:
      n = "Invalid input";
      break;
    case oe.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${it.joinValues(e.options)}`;
      break;
    case oe.invalid_enum_value:
      n = `Invalid enum value. Expected ${it.joinValues(e.options)}, received '${e.received}'`;
      break;
    case oe.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case oe.invalid_return_type:
      n = "Invalid function return type";
      break;
    case oe.invalid_date:
      n = "Invalid date";
      break;
    case oe.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : it.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case oe.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case oe.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case oe.custom:
      n = "Invalid input";
      break;
    case oe.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case oe.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case oe.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, it.assertNever(e);
  }
  return { message: n };
};
let mE = us;
function XI(e) {
  mE = e;
}
function Hc() {
  return mE;
}
const Vc = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], o = {
    ...i,
    path: a
  };
  let s = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    s = c(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: i.message || s
  };
}, QI = [];
function be(e, t) {
  const n = Vc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Hc(),
      us
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
let Sn = class vE {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return Le;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return vE.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return Le;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
};
const Le = Object.freeze({
  status: "aborted"
}), gE = (e) => ({ status: "dirty", value: e }), hn = (e) => ({ status: "valid", value: e }), sh = (e) => e.status === "aborted", lh = (e) => e.status === "dirty", fs = (e) => e.status === "valid", Zc = (e) => typeof Promise < "u" && e instanceof Promise;
var Te;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Te || (Te = {}));
let Rr = class {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const My = (e, t) => {
  if (fs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new ar(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Be(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => o.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, description: i };
}
let Ue = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return pi(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: pi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Sn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: pi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Zc(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: pi(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return My(i, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: pi(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (Zc(i) ? i : Promise.resolve(i));
    return My(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: oe.custom,
        ...r(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new cr({
      schema: this,
      typeName: Ae.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Kr.create(this, this._def);
  }
  nullable() {
    return ta.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ea.create(this, this._def);
  }
  promise() {
    return Ya.create(this, this._def);
  }
  or(t) {
    return ys.create([this, t], this._def);
  }
  and(t) {
    return bs.create(this, t, this._def);
  }
  transform(t) {
    return new cr({
      ...Be(this._def),
      schema: this,
      typeName: Ae.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Es({
      ...Be(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ae.ZodDefault
    });
  }
  brand() {
    return new kE({
      typeName: Ae.ZodBranded,
      type: this,
      ...Be(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Xc({
      ...Be(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ae.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Jm.create(this, t);
  }
  readonly() {
    return eu.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const eA = /^c[^\s-]{8,}$/i, tA = /^[a-z][a-z0-9]*$/, nA = /^[0-9A-HJKMNP-TV-Z]{26}$/, rA = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, iA = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, aA = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Gf;
const oA = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, sA = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, lA = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function cA(e, t) {
  return !!((t === "v4" || !t) && oA.test(e) || (t === "v6" || !t) && sA.test(e));
}
let Ka = class Ko extends Ue {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ge.string) {
      const a = this._getOrReturnCtx(t);
      return be(
        a,
        {
          code: oe.invalid_type,
          expected: ge.string,
          received: a.parsedType
        }
        //
      ), Le;
    }
    const r = new Sn();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), be(i, {
          code: oe.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), be(i, {
          code: oe.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? be(i, {
          code: oe.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && be(i, {
          code: oe.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        iA.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "email",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Gf || (Gf = new RegExp(aA, "u")), Gf.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "emoji",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        rA.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "uuid",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        eA.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "cuid",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        tA.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "cuid2",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        nA.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
          validation: "ulid",
          code: oe.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), be(i, {
            validation: "url",
            code: oe.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
        validation: "regex",
        code: oe.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? lA(a).test(t.data) || (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? cA(t.data, a.version) || (i = this._getOrReturnCtx(t, i), be(i, {
        validation: "ip",
        code: oe.invalid_string,
        message: a.message
      }), r.dirty()) : it.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: oe.invalid_string,
      ...Te.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Te.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Te.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Te.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Te.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Te.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Te.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Te.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Te.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...Te.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Te.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...Te.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Te.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Te.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Te.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Te.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Te.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, Te.errToObj(t));
  }
  trim() {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
Ka.create = (e) => {
  var t;
  return new Ka({
    checks: [],
    typeName: Ae.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Be(e)
  });
};
function uA(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
let ds = class ch extends Ue {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ge.number) {
      const a = this._getOrReturnCtx(t);
      return be(a, {
        code: oe.invalid_type,
        expected: ge.number,
        received: a.parsedType
      }), Le;
    }
    let r;
    const i = new Sn();
    for (const a of this._def.checks)
      a.kind === "int" ? it.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? uA(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.not_finite,
        message: a.message
      }), i.dirty()) : it.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Te.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Te.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Te.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Te.toString(n));
  }
  setLimit(t, n, r, i) {
    return new ch({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Te.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ch({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Te.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Te.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Te.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Te.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Te.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Te.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Te.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Te.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Te.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && it.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
ds.create = (e) => new ds({
  checks: [],
  typeName: Ae.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Be(e)
});
let ps = class uh extends Ue {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ge.bigint) {
      const a = this._getOrReturnCtx(t);
      return be(a, {
        code: oe.invalid_type,
        expected: ge.bigint,
        received: a.parsedType
      }), Le;
    }
    let r;
    const i = new Sn();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), be(r, {
        code: oe.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : it.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Te.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Te.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Te.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Te.toString(n));
  }
  setLimit(t, n, r, i) {
    return new uh({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Te.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new uh({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Te.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Te.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Te.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Te.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Te.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
ps.create = (e) => {
  var t;
  return new ps({
    checks: [],
    typeName: Ae.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Be(e)
  });
};
let hs = class extends Ue {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ge.boolean) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.boolean,
        received: r.parsedType
      }), Le;
    }
    return hn(t.data);
  }
};
hs.create = (e) => new hs({
  typeName: Ae.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Be(e)
});
let ms = class yE extends Ue {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ge.date) {
      const a = this._getOrReturnCtx(t);
      return be(a, {
        code: oe.invalid_type,
        expected: ge.date,
        received: a.parsedType
      }), Le;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return be(a, {
        code: oe.invalid_date
      }), Le;
    }
    const r = new Sn();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), be(i, {
        code: oe.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : it.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new yE({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Te.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Te.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
ms.create = (e) => new ms({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Ae.ZodDate,
  ...Be(e)
});
let Kc = class extends Ue {
  _parse(t) {
    if (this._getType(t) !== ge.symbol) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.symbol,
        received: r.parsedType
      }), Le;
    }
    return hn(t.data);
  }
};
Kc.create = (e) => new Kc({
  typeName: Ae.ZodSymbol,
  ...Be(e)
});
let vs = class extends Ue {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.undefined,
        received: r.parsedType
      }), Le;
    }
    return hn(t.data);
  }
};
vs.create = (e) => new vs({
  typeName: Ae.ZodUndefined,
  ...Be(e)
});
let gs = class extends Ue {
  _parse(t) {
    if (this._getType(t) !== ge.null) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.null,
        received: r.parsedType
      }), Le;
    }
    return hn(t.data);
  }
};
gs.create = (e) => new gs({
  typeName: Ae.ZodNull,
  ...Be(e)
});
let Ga = class extends Ue {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return hn(t.data);
  }
};
Ga.create = (e) => new Ga({
  typeName: Ae.ZodAny,
  ...Be(e)
});
let Zi = class extends Ue {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return hn(t.data);
  }
};
Zi.create = (e) => new Zi({
  typeName: Ae.ZodUnknown,
  ...Be(e)
});
let Xr = class extends Ue {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return be(n, {
      code: oe.invalid_type,
      expected: ge.never,
      received: n.parsedType
    }), Le;
  }
};
Xr.create = (e) => new Xr({
  typeName: Ae.ZodNever,
  ...Be(e)
});
let Gc = class extends Ue {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.void,
        received: r.parsedType
      }), Le;
    }
    return hn(t.data);
  }
};
Gc.create = (e) => new Gc({
  typeName: Ae.ZodVoid,
  ...Be(e)
});
let ea = class fc extends Ue {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== ge.array)
      return be(n, {
        code: oe.invalid_type,
        expected: ge.array,
        received: n.parsedType
      }), Le;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (be(n, {
        code: o ? oe.too_big : oe.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (be(n, {
      code: oe.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (be(n, {
      code: oe.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, s) => i.type._parseAsync(new Rr(n, o, n.path, s)))).then((o) => Sn.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new Rr(n, o, n.path, s)));
    return Sn.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new fc({
      ...this._def,
      minLength: { value: t, message: Te.toString(n) }
    });
  }
  max(t, n) {
    return new fc({
      ...this._def,
      maxLength: { value: t, message: Te.toString(n) }
    });
  }
  length(t, n) {
    return new fc({
      ...this._def,
      exactLength: { value: t, message: Te.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
ea.create = (e, t) => new ea({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ae.ZodArray,
  ...Be(t)
});
function Ia(e) {
  if (e instanceof Vn) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Kr.create(Ia(r));
    }
    return new Vn({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof ea ? new ea({
    ...e._def,
    type: Ia(e.element)
  }) : e instanceof Kr ? Kr.create(Ia(e.unwrap())) : e instanceof ta ? ta.create(Ia(e.unwrap())) : e instanceof ki ? ki.create(e.items.map((t) => Ia(t))) : e;
}
let Vn = class Qn extends Ue {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = it.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== ge.object) {
      const c = this._getOrReturnCtx(t);
      return be(c, {
        code: oe.invalid_type,
        expected: ge.object,
        received: c.parsedType
      }), Le;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Xr && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        o.includes(c) || s.push(c);
    const l = [];
    for (const c of o) {
      const u = a[c], f = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Rr(i, f, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof Xr) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (be(i, {
          code: oe.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const f = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new Rr(i, f, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const f = await u.key;
        c.push({
          key: f,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Sn.mergeObjectSync(r, c)) : Sn.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Te.errToObj, new Qn({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, o, s;
          const l = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = Te.errToObj(t).message) !== null && s !== void 0 ? s : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Qn({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Qn({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Qn({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Qn({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Ae.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Qn({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return it.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Qn({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return it.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new Qn({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ia(this);
  }
  partial(t) {
    const n = {};
    return it.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new Qn({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return it.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Kr; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new Qn({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return _E(it.objectKeys(this.shape));
  }
};
Vn.create = (e, t) => new Vn({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Xr.create(),
  typeName: Ae.ZodObject,
  ...Be(t)
});
Vn.strictCreate = (e, t) => new Vn({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Xr.create(),
  typeName: Ae.ZodObject,
  ...Be(t)
});
Vn.lazycreate = (e, t) => new Vn({
  shape: e,
  unknownKeys: "strip",
  catchall: Xr.create(),
  typeName: Ae.ZodObject,
  ...Be(t)
});
let ys = class extends Ue {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new ar(s.ctx.common.issues));
      return be(n, {
        code: oe.invalid_union,
        unionErrors: o
      }), Le;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const l of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((l) => new ar(l));
      return be(n, {
        code: oe.invalid_union,
        unionErrors: s
      }), Le;
    }
  }
  get options() {
    return this._def.options;
  }
};
ys.create = (e, t) => new ys({
  options: e,
  typeName: Ae.ZodUnion,
  ...Be(t)
});
const dc = (e) => e instanceof xs ? dc(e.schema) : e instanceof cr ? dc(e.innerType()) : e instanceof ws ? [e.value] : e instanceof el ? e.options : e instanceof Ss ? Object.keys(e.enum) : e instanceof Es ? dc(e._def.innerType) : e instanceof vs ? [void 0] : e instanceof gs ? [null] : null;
let bE = class xE extends Ue {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.object)
      return be(n, {
        code: oe.invalid_type,
        expected: ge.object,
        received: n.parsedType
      }), Le;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (be(n, {
      code: oe.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Le);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = dc(a.shape[t]);
      if (!o)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new xE({
      typeName: Ae.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...Be(r)
    });
  }
};
function fh(e, t) {
  const n = pi(e), r = pi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === ge.object && r === ge.object) {
    const i = it.objectKeys(t), a = it.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const l = fh(e[s], t[s]);
      if (!l.valid)
        return { valid: !1 };
      o[s] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === ge.array && r === ge.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], l = fh(o, s);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else return n === ge.date && r === ge.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
let bs = class extends Ue {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, o) => {
      if (sh(a) || sh(o))
        return Le;
      const s = fh(a.value, o.value);
      return s.valid ? ((lh(a) || lh(o)) && n.dirty(), { status: n.value, value: s.data }) : (be(r, {
        code: oe.invalid_intersection_types
      }), Le);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
bs.create = (e, t, n) => new bs({
  left: e,
  right: t,
  typeName: Ae.ZodIntersection,
  ...Be(n)
});
let ki = class wE extends Ue {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.array)
      return be(r, {
        code: oe.invalid_type,
        expected: ge.array,
        received: r.parsedType
      }), Le;
    if (r.data.length < this._def.items.length)
      return be(r, {
        code: oe.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Le;
    !this._def.rest && r.data.length > this._def.items.length && (be(r, {
      code: oe.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const l = this._def.items[s] || this._def.rest;
      return l ? l._parse(new Rr(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => Sn.mergeArray(n, o)) : Sn.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new wE({
      ...this._def,
      rest: t
    });
  }
};
ki.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ki({
    items: e,
    typeName: Ae.ZodTuple,
    rest: null,
    ...Be(t)
  });
};
let SE = class dh extends Ue {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.object)
      return be(r, {
        code: oe.invalid_type,
        expected: ge.object,
        received: r.parsedType
      }), Le;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new Rr(r, s, r.path, s)),
        value: o._parse(new Rr(r, r.data[s], r.path, s))
      });
    return r.common.async ? Sn.mergeObjectAsync(n, i) : Sn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof Ue ? new dh({
      keyType: t,
      valueType: n,
      typeName: Ae.ZodRecord,
      ...Be(r)
    }) : new dh({
      keyType: Ka.create(),
      valueType: t,
      typeName: Ae.ZodRecord,
      ...Be(n)
    });
  }
}, Yc = class extends Ue {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.map)
      return be(r, {
        code: oe.invalid_type,
        expected: ge.map,
        received: r.parsedType
      }), Le;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, l], c) => ({
      key: i._parse(new Rr(r, s, r.path, [c, "key"])),
      value: a._parse(new Rr(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return Le;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return Le;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
};
Yc.create = (e, t, n) => new Yc({
  valueType: t,
  keyType: e,
  typeName: Ae.ZodMap,
  ...Be(n)
});
let Jc = class ph extends Ue {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.set)
      return be(r, {
        code: oe.invalid_type,
        expected: ge.set,
        received: r.parsedType
      }), Le;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (be(r, {
      code: oe.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (be(r, {
      code: oe.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return Le;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const s = [...r.data.values()].map((l, c) => a._parse(new Rr(r, l, r.path, c)));
    return r.common.async ? Promise.all(s).then((l) => o(l)) : o(s);
  }
  min(t, n) {
    return new ph({
      ...this._def,
      minSize: { value: t, message: Te.toString(n) }
    });
  }
  max(t, n) {
    return new ph({
      ...this._def,
      maxSize: { value: t, message: Te.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Jc.create = (e, t) => new Jc({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Ae.ZodSet,
  ...Be(t)
});
let EE = class pc extends Ue {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.function)
      return be(n, {
        code: oe.invalid_type,
        expected: ge.function,
        received: n.parsedType
      }), Le;
    function r(s, l) {
      return Vc({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Hc(),
          us
        ].filter((c) => !!c),
        issueData: {
          code: oe.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(s, l) {
      return Vc({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Hc(),
          us
        ].filter((c) => !!c),
        issueData: {
          code: oe.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof Ya) {
      const s = this;
      return hn(async function(...l) {
        const c = new ar([]), u = await s._def.args.parseAsync(l, a).catch((p) => {
          throw c.addIssue(r(l, p)), c;
        }), f = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(f, a).catch((p) => {
          throw c.addIssue(i(f, p)), c;
        });
      });
    } else {
      const s = this;
      return hn(function(...l) {
        const c = s._def.args.safeParse(l, a);
        if (!c.success)
          throw new ar([r(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), f = s._def.returns.safeParse(u, a);
        if (!f.success)
          throw new ar([i(u, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new pc({
      ...this._def,
      args: ki.create(t).rest(Zi.create())
    });
  }
  returns(t) {
    return new pc({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new pc({
      args: t || ki.create([]).rest(Zi.create()),
      returns: n || Zi.create(),
      typeName: Ae.ZodFunction,
      ...Be(r)
    });
  }
}, xs = class extends Ue {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
xs.create = (e, t) => new xs({
  getter: e,
  typeName: Ae.ZodLazy,
  ...Be(t)
});
let ws = class extends Ue {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return be(n, {
        received: n.data,
        code: oe.invalid_literal,
        expected: this._def.value
      }), Le;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
ws.create = (e, t) => new ws({
  value: e,
  typeName: Ae.ZodLiteral,
  ...Be(t)
});
function _E(e, t) {
  return new el({
    values: e,
    typeName: Ae.ZodEnum,
    ...Be(t)
  });
}
let el = class hh extends Ue {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return be(n, {
        expected: it.joinValues(r),
        received: n.parsedType,
        code: oe.invalid_type
      }), Le;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return be(n, {
        received: n.data,
        code: oe.invalid_enum_value,
        options: r
      }), Le;
    }
    return hn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return hh.create(t);
  }
  exclude(t) {
    return hh.create(this.options.filter((n) => !t.includes(n)));
  }
};
el.create = _E;
let Ss = class extends Ue {
  _parse(t) {
    const n = it.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== ge.string && r.parsedType !== ge.number) {
      const i = it.objectValues(n);
      return be(r, {
        expected: it.joinValues(i),
        received: r.parsedType,
        code: oe.invalid_type
      }), Le;
    }
    if (n.indexOf(t.data) === -1) {
      const i = it.objectValues(n);
      return be(r, {
        received: r.data,
        code: oe.invalid_enum_value,
        options: i
      }), Le;
    }
    return hn(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
Ss.create = (e, t) => new Ss({
  values: e,
  typeName: Ae.ZodNativeEnum,
  ...Be(t)
});
let Ya = class extends Ue {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.promise && n.common.async === !1)
      return be(n, {
        code: oe.invalid_type,
        expected: ge.promise,
        received: n.parsedType
      }), Le;
    const r = n.parsedType === ge.promise ? n.data : Promise.resolve(n.data);
    return hn(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
};
Ya.create = (e, t) => new Ya({
  type: e,
  typeName: Ae.ZodPromise,
  ...Be(t)
});
let cr = class extends Ue {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ae.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        be(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(o).then((s) => this._def.schema._parseAsync({
        data: s,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const l = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Le : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? Le : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!fs(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => fs(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: n.value, value: s })) : o);
    it.assertNever(i);
  }
};
cr.create = (e, t, n) => new cr({
  schema: e,
  typeName: Ae.ZodEffects,
  effect: t,
  ...Be(n)
});
cr.createWithPreprocess = (e, t, n) => new cr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Ae.ZodEffects,
  ...Be(n)
});
let Kr = class extends Ue {
  _parse(t) {
    return this._getType(t) === ge.undefined ? hn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Kr.create = (e, t) => new Kr({
  innerType: e,
  typeName: Ae.ZodOptional,
  ...Be(t)
});
let ta = class extends Ue {
  _parse(t) {
    return this._getType(t) === ge.null ? hn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ta.create = (e, t) => new ta({
  innerType: e,
  typeName: Ae.ZodNullable,
  ...Be(t)
});
let Es = class extends Ue {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === ge.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Es.create = (e, t) => new Es({
  innerType: e,
  typeName: Ae.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Be(t)
});
let Xc = class extends Ue {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Zc(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new ar(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new ar(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Xc.create = (e, t) => new Xc({
  innerType: e,
  typeName: Ae.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Be(t)
});
let Qc = class extends Ue {
  _parse(t) {
    if (this._getType(t) !== ge.nan) {
      const r = this._getOrReturnCtx(t);
      return be(r, {
        code: oe.invalid_type,
        expected: ge.nan,
        received: r.parsedType
      }), Le;
    }
    return { status: "valid", value: t.data };
  }
};
Qc.create = (e) => new Qc({
  typeName: Ae.ZodNaN,
  ...Be(e)
});
const fA = Symbol("zod_brand");
let kE = class extends Ue {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}, Jm = class $E extends Ue {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Le : a.status === "dirty" ? (n.dirty(), gE(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? Le : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new $E({
      in: t,
      out: n,
      typeName: Ae.ZodPipeline
    });
  }
}, eu = class extends Ue {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return fs(n) && (n.value = Object.freeze(n.value)), n;
  }
};
eu.create = (e, t) => new eu({
  innerType: e,
  typeName: Ae.ZodReadonly,
  ...Be(t)
});
const OE = (e, t = {}, n) => e ? Ga.create().superRefine((r, i) => {
  var a, o;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, l = (o = (a = s.fatal) !== null && a !== void 0 ? a : n) !== null && o !== void 0 ? o : !0, c = typeof s == "string" ? { message: s } : s;
    i.addIssue({ code: "custom", ...c, fatal: l });
  }
}) : Ga.create(), dA = {
  object: Vn.lazycreate
};
var Ae;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Ae || (Ae = {}));
const pA = (e, t = {
  message: `Input not instance of ${e.name}`
}) => OE((n) => n instanceof e, t), TE = Ka.create, CE = ds.create, hA = Qc.create, mA = ps.create, RE = hs.create, vA = ms.create, gA = Kc.create, yA = vs.create, bA = gs.create, xA = Ga.create, wA = Zi.create, SA = Xr.create, EA = Gc.create, _A = ea.create, kA = Vn.create, $A = Vn.strictCreate, OA = ys.create, TA = bE.create, CA = bs.create, RA = ki.create, IA = SE.create, AA = Yc.create, PA = Jc.create, jA = EE.create, NA = xs.create, DA = ws.create, MA = el.create, LA = Ss.create, FA = Ya.create, Ly = cr.create, BA = Kr.create, zA = ta.create, UA = cr.createWithPreprocess, qA = Jm.create, WA = () => TE().optional(), HA = () => CE().optional(), VA = () => RE().optional(), ZA = {
  string: (e) => Ka.create({ ...e, coerce: !0 }),
  number: (e) => ds.create({ ...e, coerce: !0 }),
  boolean: (e) => hs.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => ps.create({ ...e, coerce: !0 }),
  date: (e) => ms.create({ ...e, coerce: !0 })
}, KA = Le;
var we = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: us,
  setErrorMap: XI,
  getErrorMap: Hc,
  makeIssue: Vc,
  EMPTY_PATH: QI,
  addIssueToContext: be,
  ParseStatus: Sn,
  INVALID: Le,
  DIRTY: gE,
  OK: hn,
  isAborted: sh,
  isDirty: lh,
  isValid: fs,
  isAsync: Zc,
  get util() {
    return it;
  },
  get objectUtil() {
    return oh;
  },
  ZodParsedType: ge,
  getParsedType: pi,
  ZodType: Ue,
  ZodString: Ka,
  ZodNumber: ds,
  ZodBigInt: ps,
  ZodBoolean: hs,
  ZodDate: ms,
  ZodSymbol: Kc,
  ZodUndefined: vs,
  ZodNull: gs,
  ZodAny: Ga,
  ZodUnknown: Zi,
  ZodNever: Xr,
  ZodVoid: Gc,
  ZodArray: ea,
  ZodObject: Vn,
  ZodUnion: ys,
  ZodDiscriminatedUnion: bE,
  ZodIntersection: bs,
  ZodTuple: ki,
  ZodRecord: SE,
  ZodMap: Yc,
  ZodSet: Jc,
  ZodFunction: EE,
  ZodLazy: xs,
  ZodLiteral: ws,
  ZodEnum: el,
  ZodNativeEnum: Ss,
  ZodPromise: Ya,
  ZodEffects: cr,
  ZodTransformer: cr,
  ZodOptional: Kr,
  ZodNullable: ta,
  ZodDefault: Es,
  ZodCatch: Xc,
  ZodNaN: Qc,
  BRAND: fA,
  ZodBranded: kE,
  ZodPipeline: Jm,
  ZodReadonly: eu,
  custom: OE,
  Schema: Ue,
  ZodSchema: Ue,
  late: dA,
  get ZodFirstPartyTypeKind() {
    return Ae;
  },
  coerce: ZA,
  any: xA,
  array: _A,
  bigint: mA,
  boolean: RE,
  date: vA,
  discriminatedUnion: TA,
  effect: Ly,
  enum: MA,
  function: jA,
  instanceof: pA,
  intersection: CA,
  lazy: NA,
  literal: DA,
  map: AA,
  nan: hA,
  nativeEnum: LA,
  never: SA,
  null: bA,
  nullable: zA,
  number: CE,
  object: kA,
  oboolean: VA,
  onumber: HA,
  optional: BA,
  ostring: WA,
  pipeline: qA,
  preprocess: UA,
  promise: FA,
  record: IA,
  set: PA,
  strictObject: $A,
  string: TE,
  symbol: gA,
  transformer: Ly,
  tuple: RA,
  undefined: yA,
  union: OA,
  unknown: wA,
  void: EA,
  NEVER: KA,
  ZodIssueCode: oe,
  quotelessJson: JI,
  ZodError: ar
});
const Po = we.object({
  title: we.string().optional(),
  link: we.string().optional()
}), IE = we.object({
  color: we.string().optional(),
  variant: we.enum(["soft", "solid"]).optional(),
  themeMode: we.enum(["light", "dark"]).optional(),
  fontFamily: we.enum(["rubik", "inter", "ibm", "fira"]).optional(),
  radius: we.number().min(0.5).max(4).optional()
}), GA = we.object({
  composerPlaceholder: we.string().optional(),
  botName: we.string().optional(),
  botAvatar: we.string().optional(),
  botDescription: we.string().optional(),
  website: Po.optional(),
  email: Po.optional(),
  phone: Po.optional(),
  privacyPolicy: Po.optional(),
  termsOfService: Po.optional(),
  showPoweredBy: we.boolean().optional()
}).merge(IE), YA = we.enum([
  "heading1",
  "heading2",
  "heading3",
  "text",
  "horizontalRule",
  "link",
  "italic",
  "bold",
  "orderedList",
  "unorderedList",
  "listItem",
  "lineBreak",
  "pre"
]), JA = we.object({}).passthrough().transform((e) => e), ue = we.object({
  className: we.string().optional(),
  style: JA.optional()
}), Yf = we.object({
  container: ue.optional(),
  image: ue.optional(),
  fallback: ue.optional()
}), XA = we.object({
  button: ue.optional(),
  text: we.record(YA, ue.optional()),
  image: we.object({
    image: ue.optional(),
    placeholder: ue.optional()
  }).optional(),
  audio: ue.optional(),
  video: ue.optional(),
  file: we.object({
    container: ue.optional(),
    title: ue.optional(),
    icon: ue.optional()
  }).optional(),
  location: we.object({
    container: ue.optional(),
    title: ue.optional(),
    icon: ue.optional()
  }).optional(),
  column: ue.optional(),
  row: ue.optional(),
  bubble: ue.optional(),
  carousel: we.object({
    container: ue.optional(),
    slidesContainer: ue.optional(),
    backButton: ue.optional(),
    nextButton: ue.optional()
  }).optional(),
  dropdown: we.object({
    button: we.object({
      container: ue.optional(),
      icon: ue.optional(),
      text: ue.optional()
    }).optional(),
    content: we.object({
      container: ue.optional(),
      item: ue.optional()
    }).optional()
  }).optional()
}), QA = we.object({
  container: ue.optional(),
  modal: we.object({
    overlay: ue.optional(),
    container: ue.optional(),
    dialog: we.object({
      container: ue.optional(),
      title: we.object({
        container: ue.optional(),
        text: ue.optional(),
        closeIcon: ue.optional()
      }).optional(),
      content: ue.optional(),
      newConversation: we.object({
        text: ue.optional(),
        button: ue.optional()
      }).optional()
    }).optional()
  }).optional(),
  notification: we.object({
    container: ue.optional(),
    title: ue.optional(),
    description: ue.optional(),
    icon: ue.optional(),
    closeIcon: ue.optional()
  }).optional(),
  header: we.object({
    container: ue.optional(),
    content: we.object({
      container: ue.optional(),
      title: ue.optional(),
      description: ue.optional(),
      avatar: Yf.optional(),
      actions: we.object({
        container: ue.optional(),
        icons: ue.optional()
      }).optional()
    }),
    expandedContent: we.object({
      container: ue.optional(),
      group: ue.optional(),
      descriptionItems: we.object({
        container: ue.optional(),
        icon: ue.optional(),
        text: ue.optional(),
        link: ue.optional(),
        poweredBy: ue.optional()
      }).optional()
    }).optional(),
    description: we.object({
      container: ue.optional(),
      title: ue.optional(),
      subtitle: ue.optional()
    }).optional(),
    newConversationIcon: ue.optional()
  }).optional(),
  composer: we.object({
    container: ue.optional(),
    input: ue.optional(),
    uploadButton: we.object({
      container: ue.optional(),
      icon: ue.optional()
    }).optional(),
    button: we.object({
      container: ue.optional(),
      icon: ue.optional()
    }).optional()
  }).optional(),
  fab: we.object({
    icon: ue.optional(),
    container: ue.optional()
  }).optional(),
  messageList: we.object({
    scrollbar: we.object({
      container: ue.optional(),
      viewport: ue.optional(),
      thumb: ue.optional(),
      corner: ue.optional(),
      background: ue.optional()
    }).optional(),
    container: ue.optional(),
    marquee: we.object({
      content: ue.optional(),
      title: ue.optional(),
      description: ue.optional(),
      avatar: Yf.optional(),
      container: ue.optional()
    }).optional(),
    scrollDownButton: we.object({
      container: ue.optional(),
      button: ue.optional(),
      icon: ue.optional()
    }).optional()
  }).optional(),
  message: we.object({
    container: ue.optional(),
    avatar: Yf.optional(),
    blocks: XA.optional()
  }).optional(),
  loadingIndicator: we.object({
    container: ue.optional(),
    loader: ue.optional()
  }).optional()
}), eP = we.enum(["opened", "closed", "initial"]), tP = we.object({
  name: we.string().optional(),
  pictureUrl: we.string().optional(),
  data: we.record(we.unknown()).optional()
}), nP = we.object({
  configuration: GA.optional().catch(void 0),
  theme: QA.optional().catch(void 0),
  style: we.string().optional().catch(void 0),
  user: tP.optional().catch(void 0)
}), lhe = nP.extend({
  clientId: we.string(),
  botId: we.string(),
  selector: we.string().optional().catch(void 0),
  webchatScriptUrl: we.string().optional().catch(void 0),
  fabScriptUrl: we.string().optional().catch(void 0),
  pushpinUrl: we.string().optional().catch(void 0),
  defaultState: eP.optional().catch(void 0)
});
function rP(e) {
  const { fontFamily: t, radius: n, themeMode: r, variant: i, color: a } = IE.parse(e);
  let o = {}, s = {};
  if (a) {
    const u = Dy(a), f = r === "dark" ? Oy(u) : u, d = Dy(wI(SI(ah(a)))), p = r === "dark" ? Oy(d) : d, h = r === "dark" ? "#101010" : "#fdfdfd";
    s = Object.entries({ ...f, 1: h }).reduce(
      (y, [v, g]) => ({ ...y, [`--bpPrimary-${v}`]: g }),
      {}
    );
    const m = Object.entries({ ...p, 1: h }).reduce(
      (y, [v, g]) => ({ ...y, [`--bpGray-${v}`]: g }),
      {}
    );
    o = {
      ...s,
      ...m
    };
  }
  n && (o = {
    ...o,
    "--bpRadius-scale": n.toString()
  });
  const l = s ? Py(s["--bpPrimary-600"], s["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)", c = i === "solid" ? {
    "--header-bg": "var(--bpPrimary-600)",
    "--header-bg-hover": "var(--bpPrimary-700)",
    "--header-hover-dark": "var(--bpPrimary-800)",
    "--header-title": l,
    "--header-description": l,
    "--header-description-icon": l,
    "--header-description-link": l,
    "--header-avatar-bg": "var(--bpPrimary-300)",
    "--header-avatar-text": "var(--bpPrimary-700)",
    "--message-bg": "var(--bpPrimary-600)",
    "--message-bg-hover": "var(--bpPrimary-700)",
    "--message-text": l,
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-50)",
    "--button-bg-hover": "var(--bpPrimary-100)",
    "--button-text": "var(--bpPrimary-800)",
    "--fab-bg": "var(--bpPrimary-600)",
    "--fab-bg-hover": "var(--bpPrimary-700)",
    "--fab-icon": l
  } : {
    "--header-bg": "var(--bpGray-50)",
    "--header-bg-hover": "var(--bpGray-100)",
    "--header-hover-dark": "var(--bpGray-200)",
    "--header-title": "var(--bpGray-900)",
    "--header-description": "var(--bpGray-800)",
    "--header-description-icon": "var(--bpPrimary-700)",
    "--header-description-link": "var(--bpPrimary-800)",
    "--header-avatar-bg": "var(--bpPrimary-600)",
    "--header-avatar-text": "var(--bpPrimary-50)",
    "--message-bg": "var(--bpPrimary-100)",
    "--message-bg-hover": "var(--bpPrimary-200)",
    "--message-text": "var(--bpPrimary-900)",
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-500)",
    "--button-bg-hover": "var(--bpPrimary-600)",
    "--button-text": s ? Py(s["--bpPrimary-500"], s["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)",
    "--fab-bg": "var(--bpPrimary-100)",
    "--fab-bg-hover": "var(--bpPrimary-200)",
    "--fab-icon": "var(--bpPrimary-700)"
  };
  return o = {
    ...o,
    ...c
  }, jy(":root", o) + (t ? jy(".bpContainer", { "font-family": `var(--${t}-font)` }) : "");
}
const AE = _n(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...a }, o) => {
    const s = fE(e ?? "", 15);
    return /* @__PURE__ */ C.jsxs(Km, { ref: o, "data-color": s, ...n, ...a, children: [
      /* @__PURE__ */ C.jsx(Gm, { src: t, ...r }),
      /* @__PURE__ */ C.jsx(Ym, { ...i, children: typeof a.children == "string" ? a.children[0] : a.children })
    ] });
  }
);
function iP(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const aP = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, oP = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, sP = {};
function Fy(e, t) {
  return (sP.jsx ? oP : aP).test(e);
}
const lP = /[ \t\n\f\r]/g;
function cP(e) {
  return typeof e == "object" ? e.type === "text" ? By(e.value) : !1 : By(e);
}
function By(e) {
  return e.replace(lP, "") === "";
}
class tl {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
tl.prototype.property = {};
tl.prototype.normal = {};
tl.prototype.space = null;
function PE(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new tl(n, r, t);
}
function mh(e) {
  return e.toLowerCase();
}
class Zn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Zn.prototype.space = null;
Zn.prototype.boolean = !1;
Zn.prototype.booleanish = !1;
Zn.prototype.overloadedBoolean = !1;
Zn.prototype.number = !1;
Zn.prototype.commaSeparated = !1;
Zn.prototype.spaceSeparated = !1;
Zn.prototype.commaOrSpaceSeparated = !1;
Zn.prototype.mustUseProperty = !1;
Zn.prototype.defined = !1;
let uP = 0;
const Fe = ca(), Mt = ca(), jE = ca(), ie = ca(), yt = ca(), Ba = ca(), Tn = ca();
function ca() {
  return 2 ** ++uP;
}
const vh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Fe,
  booleanish: Mt,
  commaOrSpaceSeparated: Tn,
  commaSeparated: Ba,
  number: ie,
  overloadedBoolean: jE,
  spaceSeparated: yt
}, Symbol.toStringTag, { value: "Module" })), Jf = Object.keys(vh);
class Xm extends Zn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), zy(this, "space", i), typeof r == "number")
      for (; ++a < Jf.length; ) {
        const o = Jf[a];
        zy(this, Jf[a], (r & vh[o]) === vh[o]);
      }
  }
}
Xm.prototype.defined = !0;
function zy(e, t, n) {
  n && (e[t] = n);
}
const fP = {}.hasOwnProperty;
function vo(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (fP.call(e.properties, r)) {
      const i = e.properties[r], a = new Xm(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[mh(r)] = r, n[mh(a.attribute)] = r;
    }
  return new tl(t, n, e.space);
}
const NE = vo({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), DE = vo({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function ME(e, t) {
  return t in e ? e[t] : t;
}
function LE(e, t) {
  return ME(e, t.toLowerCase());
}
const FE = vo({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: LE,
  properties: { xmlns: null, xmlnsXLink: null }
}), BE = vo({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Mt,
    ariaAutoComplete: null,
    ariaBusy: Mt,
    ariaChecked: Mt,
    ariaColCount: ie,
    ariaColIndex: ie,
    ariaColSpan: ie,
    ariaControls: yt,
    ariaCurrent: null,
    ariaDescribedBy: yt,
    ariaDetails: null,
    ariaDisabled: Mt,
    ariaDropEffect: yt,
    ariaErrorMessage: null,
    ariaExpanded: Mt,
    ariaFlowTo: yt,
    ariaGrabbed: Mt,
    ariaHasPopup: null,
    ariaHidden: Mt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: yt,
    ariaLevel: ie,
    ariaLive: null,
    ariaModal: Mt,
    ariaMultiLine: Mt,
    ariaMultiSelectable: Mt,
    ariaOrientation: null,
    ariaOwns: yt,
    ariaPlaceholder: null,
    ariaPosInSet: ie,
    ariaPressed: Mt,
    ariaReadOnly: Mt,
    ariaRelevant: null,
    ariaRequired: Mt,
    ariaRoleDescription: yt,
    ariaRowCount: ie,
    ariaRowIndex: ie,
    ariaRowSpan: ie,
    ariaSelected: Mt,
    ariaSetSize: ie,
    ariaSort: null,
    ariaValueMax: ie,
    ariaValueMin: ie,
    ariaValueNow: ie,
    ariaValueText: null,
    role: null
  }
}), dP = vo({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: LE,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ba,
    acceptCharset: yt,
    accessKey: yt,
    action: null,
    allow: null,
    allowFullScreen: Fe,
    allowPaymentRequest: Fe,
    allowUserMedia: Fe,
    alt: null,
    as: null,
    async: Fe,
    autoCapitalize: null,
    autoComplete: yt,
    autoFocus: Fe,
    autoPlay: Fe,
    blocking: yt,
    capture: null,
    charSet: null,
    checked: Fe,
    cite: null,
    className: yt,
    cols: ie,
    colSpan: null,
    content: null,
    contentEditable: Mt,
    controls: Fe,
    controlsList: yt,
    coords: ie | Ba,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Fe,
    defer: Fe,
    dir: null,
    dirName: null,
    disabled: Fe,
    download: jE,
    draggable: Mt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Fe,
    formTarget: null,
    headers: yt,
    height: ie,
    hidden: Fe,
    high: ie,
    href: null,
    hrefLang: null,
    htmlFor: yt,
    httpEquiv: yt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Fe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Fe,
    itemId: null,
    itemProp: yt,
    itemRef: yt,
    itemScope: Fe,
    itemType: yt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Fe,
    low: ie,
    manifest: null,
    max: null,
    maxLength: ie,
    media: null,
    method: null,
    min: null,
    minLength: ie,
    multiple: Fe,
    muted: Fe,
    name: null,
    nonce: null,
    noModule: Fe,
    noValidate: Fe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Fe,
    optimum: ie,
    pattern: null,
    ping: yt,
    placeholder: null,
    playsInline: Fe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Fe,
    referrerPolicy: null,
    rel: yt,
    required: Fe,
    reversed: Fe,
    rows: ie,
    rowSpan: ie,
    sandbox: yt,
    scope: null,
    scoped: Fe,
    seamless: Fe,
    selected: Fe,
    shadowRootClonable: Fe,
    shadowRootDelegatesFocus: Fe,
    shadowRootMode: null,
    shape: null,
    size: ie,
    sizes: null,
    slot: null,
    span: ie,
    spellCheck: Mt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ie,
    step: null,
    style: null,
    tabIndex: ie,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Fe,
    useMap: null,
    value: Mt,
    width: ie,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: yt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ie,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ie,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Fe,
    // Lists. Use CSS to reduce space between items instead
    declare: Fe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ie,
    // `<img>` and `<object>`
    leftMargin: ie,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ie,
    // `<body>`
    marginWidth: ie,
    // `<body>`
    noResize: Fe,
    // `<frame>`
    noHref: Fe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Fe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Fe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ie,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Mt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ie,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ie,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Fe,
    disableRemotePlayback: Fe,
    prefix: null,
    property: null,
    results: ie,
    security: null,
    unselectable: null
  }
}), pP = vo({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: ME,
  properties: {
    about: Tn,
    accentHeight: ie,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ie,
    amplitude: ie,
    arabicForm: null,
    ascent: ie,
    attributeName: null,
    attributeType: null,
    azimuth: ie,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ie,
    by: null,
    calcMode: null,
    capHeight: ie,
    className: yt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ie,
    diffuseConstant: ie,
    direction: null,
    display: null,
    dur: null,
    divisor: ie,
    dominantBaseline: null,
    download: Fe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ie,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ie,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ie,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ba,
    g2: Ba,
    glyphName: Ba,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ie,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ie,
    horizOriginX: ie,
    horizOriginY: ie,
    id: null,
    ideographic: ie,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ie,
    k: ie,
    k1: ie,
    k2: ie,
    k3: ie,
    k4: ie,
    kernelMatrix: Tn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ie,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ie,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ie,
    overlineThickness: ie,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ie,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: yt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ie,
    pointsAtY: ie,
    pointsAtZ: ie,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Tn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Tn,
    rev: Tn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Tn,
    requiredFeatures: Tn,
    requiredFonts: Tn,
    requiredFormats: Tn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ie,
    specularExponent: ie,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ie,
    strikethroughThickness: ie,
    string: null,
    stroke: null,
    strokeDashArray: Tn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ie,
    strokeOpacity: ie,
    strokeWidth: null,
    style: null,
    surfaceScale: ie,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Tn,
    tabIndex: ie,
    tableValues: null,
    target: null,
    targetX: ie,
    targetY: ie,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Tn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ie,
    underlineThickness: ie,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ie,
    values: null,
    vAlphabetic: ie,
    vMathematical: ie,
    vectorEffect: null,
    vHanging: ie,
    vIdeographic: ie,
    version: null,
    vertAdvY: ie,
    vertOriginX: ie,
    vertOriginY: ie,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ie,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), hP = /^data[-\w.:]+$/i, Uy = /-[a-z]/g, mP = /[A-Z]/g;
function vP(e, t) {
  const n = mh(t);
  let r = t, i = Zn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && hP.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Uy, yP);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Uy.test(a)) {
        let o = a.replace(mP, gP);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = Xm;
  }
  return new i(r, t);
}
function gP(e) {
  return "-" + e.toLowerCase();
}
function yP(e) {
  return e.charAt(1).toUpperCase();
}
const bP = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, xP = PE([DE, NE, FE, BE, dP], "html"), Qm = PE([DE, NE, FE, BE, pP], "svg");
function wP(e) {
  return e.join(" ").trim();
}
var zE = {}, qy = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, SP = /\n/g, EP = /^\s*/, _P = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, kP = /^:\s*/, $P = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, OP = /^[;\s]*/, TP = /^\s+|\s+$/g, CP = `
`, Wy = "/", Hy = "*", Hi = "", RP = "comment", IP = "declaration", AP = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(h) {
    var m = h.match(SP);
    m && (n += m.length);
    var y = h.lastIndexOf(CP);
    r = ~y ? h.length - y : r + h.length;
  }
  function a() {
    var h = { line: n, column: r };
    return function(m) {
      return m.position = new o(h), c(), m;
    };
  }
  function o(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = t.source;
  }
  o.prototype.content = e;
  function s(h) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + h
    );
    if (m.reason = h, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(h) {
    var m = h.exec(e);
    if (m) {
      var y = m[0];
      return i(y), e = e.slice(y.length), m;
    }
  }
  function c() {
    l(EP);
  }
  function u(h) {
    var m;
    for (h = h || []; m = f(); )
      m !== !1 && h.push(m);
    return h;
  }
  function f() {
    var h = a();
    if (!(Wy != e.charAt(0) || Hy != e.charAt(1))) {
      for (var m = 2; Hi != e.charAt(m) && (Hy != e.charAt(m) || Wy != e.charAt(m + 1)); )
        ++m;
      if (m += 2, Hi === e.charAt(m - 1))
        return s("End of comment missing");
      var y = e.slice(2, m - 2);
      return r += 2, i(y), e = e.slice(m), r += 2, h({
        type: RP,
        comment: y
      });
    }
  }
  function d() {
    var h = a(), m = l(_P);
    if (m) {
      if (f(), !l(kP)) return s("property missing ':'");
      var y = l($P), v = h({
        type: IP,
        property: Vy(m[0].replace(qy, Hi)),
        value: y ? Vy(y[0].replace(qy, Hi)) : Hi
      });
      return l(OP), v;
    }
  }
  function p() {
    var h = [];
    u(h);
    for (var m; m = d(); )
      m !== !1 && (h.push(m), u(h));
    return h;
  }
  return c(), p();
};
function Vy(e) {
  return e ? e.replace(TP, Hi) : Hi;
}
var PP = ft && ft.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zE, "__esModule", { value: !0 });
var Zy = zE.default = NP, jP = PP(AP);
function NP(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, jP.default)(e), i = typeof t == "function";
  return r.forEach(function(a) {
    if (a.type === "declaration") {
      var o = a.property, s = a.value;
      i ? t(o, s, a) : s && (n = n || {}, n[o] = s);
    }
  }), n;
}
const DP = Zy.default || Zy, UE = qE("end"), ev = qE("start");
function qE(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function MP(e) {
  const t = ev(e), n = UE(e);
  if (t && n)
    return { start: t, end: n };
}
function es(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Ky(e.position) : "start" in e || "end" in e ? Ky(e) : "line" in e || "column" in e ? gh(e) : "";
}
function gh(e) {
  return Gy(e && e.line) + ":" + Gy(e && e.column);
}
function Ky(e) {
  return gh(e && e.start) + "-" + gh(e && e.end);
}
function Gy(e) {
  return e && typeof e == "number" ? e : 1;
}
class cn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, o = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (o = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? a.ruleId = r : (a.source = r.slice(0, l), a.ruleId = r.slice(l + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const l = a.ancestors[a.ancestors.length - 1];
      l && (a.place = l.position);
    }
    const s = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = es(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = o && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
cn.prototype.file = "";
cn.prototype.name = "";
cn.prototype.reason = "";
cn.prototype.message = "";
cn.prototype.stack = "";
cn.prototype.column = void 0;
cn.prototype.line = void 0;
cn.prototype.ancestors = void 0;
cn.prototype.cause = void 0;
cn.prototype.fatal = void 0;
cn.prototype.place = void 0;
cn.prototype.ruleId = void 0;
cn.prototype.source = void 0;
const tv = {}.hasOwnProperty, LP = /* @__PURE__ */ new Map(), FP = /[A-Z]/g, BP = /-([a-z])/g, zP = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), UP = /* @__PURE__ */ new Set(["td", "th"]), WE = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function qP(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = JP(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = YP(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Qm : xP,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = HE(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function HE(e, t, n) {
  if (t.type === "element")
    return WP(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return HP(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return ZP(e, t, n);
  if (t.type === "mdxjsEsm")
    return VP(e, t);
  if (t.type === "root")
    return KP(e, t, n);
  if (t.type === "text")
    return GP(e, t);
}
function WP(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = Qm, e.schema = i), e.ancestors.push(t);
  const a = ZE(e, t.tagName, !1), o = XP(e, t);
  let s = rv(e, t);
  return zP.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !cP(l) : !0;
  })), VE(e, o, a, t), nv(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function HP(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  _s(e, t.position);
}
function VP(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  _s(e, t.position);
}
function ZP(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = Qm, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : ZE(e, t.name, !0), o = QP(e, t), s = rv(e, t);
  return VE(e, o, a, t), nv(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function KP(e, t, n) {
  const r = {};
  return nv(r, rv(e, t)), e.create(t, e.Fragment, r, n);
}
function GP(e, t) {
  return t.value;
}
function VE(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function nv(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function YP(e, t, n) {
  return r;
  function r(i, a, o, s) {
    const c = Array.isArray(o.children) ? n : t;
    return s ? c(a, o, s) : c(a, o);
  }
}
function JP(e, t) {
  return n;
  function n(r, i, a, o) {
    const s = Array.isArray(a.children), l = ev(r);
    return t(
      i,
      a,
      o,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function XP(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && tv.call(t.properties, i)) {
      const a = ej(e, i, t.properties[i]);
      if (a) {
        const [o, s] = a;
        e.tableCellAlignToStyle && o === "align" && typeof s == "string" && UP.has(t.tagName) ? r = s : n[o] = s;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function QP(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const o = a.expression;
        o.type;
        const s = o.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        _s(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, a = e.evaluater.evaluateExpression(s.expression);
        } else
          _s(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function rv(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : LP;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let o;
    if (e.passKeys) {
      const l = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (l) {
        const c = i.get(l) || 0;
        o = l + "-" + c, i.set(l, c + 1);
      }
    }
    const s = HE(e, a, o);
    s !== void 0 && n.push(s);
  }
  return n;
}
function ej(e, t, n) {
  const r = vP(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? iP(n) : wP(n)), r.property === "style") {
      let i = typeof n == "object" ? n : tj(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = nj(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? bP[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function tj(e, t) {
  const n = {};
  try {
    DP(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const a = (
        /** @type {Error} */
        i
      ), o = new cn("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: a,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = WE + "#cannot-parse-style-attribute", o;
    }
  }
  return n;
  function r(i, a) {
    let o = i;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(BP, ij)), n[o] = a;
  }
}
function ZE(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, o;
    for (; ++a < i.length; ) {
      const s = Fy(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      o = o ? {
        type: "MemberExpression",
        object: o,
        property: s,
        computed: !!(a && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = o;
  } else
    r = Fy(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return tv.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  _s(e);
}
function _s(e, t) {
  const n = new cn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = WE + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function nj(e) {
  const t = {};
  let n;
  for (n in e)
    tv.call(e, n) && (t[rj(n)] = e[n]);
  return t;
}
function rj(e) {
  let t = e.replace(FP, aj);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function ij(e, t) {
  return t.toUpperCase();
}
function aj(e) {
  return "-" + e.toLowerCase();
}
const Xf = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, oj = {};
function iv(e, t) {
  const n = oj, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return KE(e, r, i);
}
function KE(e, t, n) {
  if (sj(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Yy(e.children, t, n);
  }
  return Array.isArray(e) ? Yy(e, t, n) : "";
}
function Yy(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = KE(e[i], t, n);
  return r.join("");
}
function sj(e) {
  return !!(e && typeof e == "object");
}
const Jy = document.createElement("i");
function av(e) {
  const t = "&" + e + ";";
  Jy.innerHTML = t;
  const n = Jy.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Wn(e, t, n, r) {
  const i = e.length;
  let a = 0, o;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(t, n), e.splice(...o);
  else
    for (n && e.splice(t, n); a < r.length; )
      o = r.slice(a, a + 1e4), o.unshift(t, 0), e.splice(...o), a += 1e4, t += 1e4;
}
function Bn(e, t) {
  return e.length > 0 ? (Wn(e, e.length, 0, t), e) : t;
}
const Xy = {}.hasOwnProperty;
function GE(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    lj(t, e[n]);
  return t;
}
function lj(e, t) {
  let n;
  for (n in t) {
    const i = (Xy.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let o;
    if (a)
      for (o in a) {
        Xy.call(i, o) || (i[o] = []);
        const s = a[o];
        cj(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function cj(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Wn(e, 0, 0, r);
}
function YE(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function or(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const pn = Ni(/[A-Za-z]/), on = Ni(/[\dA-Za-z]/), uj = Ni(/[#-'*+\--9=?A-Z^-~]/);
function tu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const yh = Ni(/\d/), fj = Ni(/[\dA-Fa-f]/), dj = Ni(/[!-/:-@[-`{-~]/);
function Re(e) {
  return e !== null && e < -2;
}
function gt(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ve(e) {
  return e === -2 || e === -1 || e === 32;
}
const Qu = Ni(new RegExp("\\p{P}|\\p{S}", "u")), na = Ni(/\s/);
function Ni(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function go(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let o = "";
    if (a === 37 && on(e.charCodeAt(n + 1)) && on(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (o = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const s = e.charCodeAt(n + 1);
      a < 56320 && s > 56319 && s < 57344 ? (o = String.fromCharCode(a, s), i = 1) : o = "";
    } else
      o = String.fromCharCode(a);
    o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function tt(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return o;
  function o(l) {
    return Ve(l) ? (e.enter(n), s(l)) : t(l);
  }
  function s(l) {
    return Ve(l) && a++ < i ? (e.consume(l), s) : (e.exit(n), t(l));
  }
}
const pj = {
  tokenize: hj
};
function hj(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), tt(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), a(s);
  }
  function a(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(s);
  }
  function o(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Re(s) ? (e.consume(s), e.exit("chunkText"), a) : (e.consume(s), o);
  }
}
const mj = {
  tokenize: vj
}, Qy = {
  tokenize: gj
};
function vj(e) {
  const t = this, n = [];
  let r = 0, i, a, o;
  return s;
  function s(b) {
    if (r < n.length) {
      const k = n[r];
      return t.containerState = k[1], e.attempt(
        k[0].continuation,
        l,
        c
      )(b);
    }
    return c(b);
  }
  function l(b) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && g();
      const k = t.events.length;
      let S = k, _;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          _ = t.events[S][1].end;
          break;
        }
      v(r);
      let $ = k;
      for (; $ < t.events.length; )
        t.events[$][1].end = Object.assign({}, _), $++;
      return Wn(
        t.events,
        S + 1,
        0,
        t.events.slice(k)
      ), t.events.length = $, c(b);
    }
    return s(b);
  }
  function c(b) {
    if (r === n.length) {
      if (!i)
        return d(b);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return h(b);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Qy,
      u,
      f
    )(b);
  }
  function u(b) {
    return i && g(), v(r), d(b);
  }
  function f(b) {
    return t.parser.lazy[t.now().line] = r !== n.length, o = t.now().offset, h(b);
  }
  function d(b) {
    return t.containerState = {}, e.attempt(
      Qy,
      p,
      h
    )(b);
  }
  function p(b) {
    return r++, n.push([t.currentConstruct, t.containerState]), d(b);
  }
  function h(b) {
    if (b === null) {
      i && g(), v(0), e.consume(b);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: i
    }), m(b);
  }
  function m(b) {
    if (b === null) {
      y(e.exit("chunkFlow"), !0), v(0), e.consume(b);
      return;
    }
    return Re(b) ? (e.consume(b), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(b), m);
  }
  function y(b, k) {
    const S = t.sliceStream(b);
    if (k && S.push(null), b.previous = a, a && (a.next = b), a = b, i.defineSkip(b.start), i.write(S), t.parser.lazy[b.start.line]) {
      let _ = i.events.length;
      for (; _--; )
        if (
          // The token starts before the line ending
          i.events[_][1].start.offset < o && // and either is not ended yet
          (!i.events[_][1].end || // or ends after it.
          i.events[_][1].end.offset > o)
        )
          return;
      const $ = t.events.length;
      let j = $, B, O;
      for (; j--; )
        if (t.events[j][0] === "exit" && t.events[j][1].type === "chunkFlow") {
          if (B) {
            O = t.events[j][1].end;
            break;
          }
          B = !0;
        }
      for (v(r), _ = $; _ < t.events.length; )
        t.events[_][1].end = Object.assign({}, O), _++;
      Wn(
        t.events,
        j + 1,
        0,
        t.events.slice($)
      ), t.events.length = _;
    }
  }
  function v(b) {
    let k = n.length;
    for (; k-- > b; ) {
      const S = n[k];
      t.containerState = S[1], S[0].exit.call(t, e);
    }
    n.length = b;
  }
  function g() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function gj(e, t, n) {
  return tt(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function nu(e) {
  if (e === null || gt(e) || na(e))
    return 1;
  if (Qu(e))
    return 2;
}
function ef(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const bh = {
  name: "attention",
  tokenize: bj,
  resolveAll: yj
};
function yj(e, t) {
  let n = -1, r, i, a, o, s, l, c, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), d = Object.assign({}, e[n][1].start);
          eb(f, -l), eb(d, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: d
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, o.start), e[n][1].start = Object.assign({}, s.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = Bn(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = Bn(c, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["enter", a, t]]), c = Bn(c, ef(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = Bn(c, [["exit", a, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, c = Bn(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : u = 0, Wn(e, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function bj(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = nu(r);
  let a;
  return o;
  function o(l) {
    return a = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === a)
      return e.consume(l), s;
    const c = e.exit("attentionSequence"), u = nu(l), f = !u || u === 2 && i || n.includes(l), d = !i || i === 2 && u || n.includes(r);
    return c._open = !!(a === 42 ? f : f && (i || !d)), c._close = !!(a === 42 ? d : d && (u || !f)), t(l);
  }
}
function eb(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const xj = {
  name: "autolink",
  tokenize: wj
};
function wj(e, t, n) {
  let r = 0;
  return i;
  function i(p) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(p) {
    return pn(p) ? (e.consume(p), o) : p === 64 ? n(p) : c(p);
  }
  function o(p) {
    return p === 43 || p === 45 || p === 46 || on(p) ? (r = 1, s(p)) : c(p);
  }
  function s(p) {
    return p === 58 ? (e.consume(p), r = 0, l) : (p === 43 || p === 45 || p === 46 || on(p)) && r++ < 32 ? (e.consume(p), s) : (r = 0, c(p));
  }
  function l(p) {
    return p === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : p === null || p === 32 || p === 60 || tu(p) ? n(p) : (e.consume(p), l);
  }
  function c(p) {
    return p === 64 ? (e.consume(p), u) : uj(p) ? (e.consume(p), c) : n(p);
  }
  function u(p) {
    return on(p) ? f(p) : n(p);
  }
  function f(p) {
    return p === 46 ? (e.consume(p), r = 0, u) : p === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : d(p);
  }
  function d(p) {
    if ((p === 45 || on(p)) && r++ < 63) {
      const h = p === 45 ? d : f;
      return e.consume(p), h;
    }
    return n(p);
  }
}
const nl = {
  tokenize: Sj,
  partial: !0
};
function Sj(e, t, n) {
  return r;
  function r(a) {
    return Ve(a) ? tt(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Re(a) ? t(a) : n(a);
  }
}
const JE = {
  name: "blockQuote",
  tokenize: Ej,
  continuation: {
    tokenize: _j
  },
  exit: kj
};
function Ej(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), a;
    }
    return n(o);
  }
  function a(o) {
    return Ve(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(o));
  }
}
function _j(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return Ve(o) ? tt(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : a(o);
  }
  function a(o) {
    return e.attempt(JE, t, n)(o);
  }
}
function kj(e) {
  e.exit("blockQuote");
}
const XE = {
  name: "characterEscape",
  tokenize: $j
};
function $j(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return dj(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const QE = {
  name: "characterReference",
  tokenize: Oj
};
function Oj(e, t, n) {
  const r = this;
  let i = 0, a, o;
  return s;
  function s(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, o = on, u(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, o = fj, u) : (e.enter("characterReferenceValue"), a = 7, o = yh, u(f));
  }
  function u(f) {
    if (f === 59 && i) {
      const d = e.exit("characterReferenceValue");
      return o === on && !av(r.sliceSerialize(d)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return o(f) && i++ < a ? (e.consume(f), u) : n(f);
  }
}
const tb = {
  tokenize: Cj,
  partial: !0
}, nb = {
  name: "codeFenced",
  tokenize: Tj,
  concrete: !0
};
function Tj(e, t, n) {
  const r = this, i = {
    tokenize: S,
    partial: !0
  };
  let a = 0, o = 0, s;
  return l;
  function l(_) {
    return c(_);
  }
  function c(_) {
    const $ = r.events[r.events.length - 1];
    return a = $ && $[1].type === "linePrefix" ? $[2].sliceSerialize($[1], !0).length : 0, s = _, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(_);
  }
  function u(_) {
    return _ === s ? (o++, e.consume(_), u) : o < 3 ? n(_) : (e.exit("codeFencedFenceSequence"), Ve(_) ? tt(e, f, "whitespace")(_) : f(_));
  }
  function f(_) {
    return _ === null || Re(_) ? (e.exit("codeFencedFence"), r.interrupt ? t(_) : e.check(tb, m, k)(_)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), d(_));
  }
  function d(_) {
    return _ === null || Re(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(_)) : Ve(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), tt(e, p, "whitespace")(_)) : _ === 96 && _ === s ? n(_) : (e.consume(_), d);
  }
  function p(_) {
    return _ === null || Re(_) ? f(_) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(_));
  }
  function h(_) {
    return _ === null || Re(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(_)) : _ === 96 && _ === s ? n(_) : (e.consume(_), h);
  }
  function m(_) {
    return e.attempt(i, k, y)(_);
  }
  function y(_) {
    return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), v;
  }
  function v(_) {
    return a > 0 && Ve(_) ? tt(e, g, "linePrefix", a + 1)(_) : g(_);
  }
  function g(_) {
    return _ === null || Re(_) ? e.check(tb, m, k)(_) : (e.enter("codeFlowValue"), b(_));
  }
  function b(_) {
    return _ === null || Re(_) ? (e.exit("codeFlowValue"), g(_)) : (e.consume(_), b);
  }
  function k(_) {
    return e.exit("codeFenced"), t(_);
  }
  function S(_, $, j) {
    let B = 0;
    return O;
    function O(D) {
      return _.enter("lineEnding"), _.consume(D), _.exit("lineEnding"), N;
    }
    function N(D) {
      return _.enter("codeFencedFence"), Ve(D) ? tt(_, q, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : q(D);
    }
    function q(D) {
      return D === s ? (_.enter("codeFencedFenceSequence"), M(D)) : j(D);
    }
    function M(D) {
      return D === s ? (B++, _.consume(D), M) : B >= o ? (_.exit("codeFencedFenceSequence"), Ve(D) ? tt(_, z, "whitespace")(D) : z(D)) : j(D);
    }
    function z(D) {
      return D === null || Re(D) ? (_.exit("codeFencedFence"), $(D)) : j(D);
    }
  }
}
function Cj(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
const Qf = {
  name: "codeIndented",
  tokenize: Ij
}, Rj = {
  tokenize: Aj,
  partial: !0
};
function Ij(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), tt(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c);
  }
  function o(c) {
    return c === null ? l(c) : Re(c) ? e.attempt(Rj, o, l)(c) : (e.enter("codeFlowValue"), s(c));
  }
  function s(c) {
    return c === null || Re(c) ? (e.exit("codeFlowValue"), o(c)) : (e.consume(c), s);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function Aj(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : Re(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i) : tt(e, a, "linePrefix", 5)(o);
  }
  function a(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : Re(o) ? i(o) : n(o);
  }
}
const Pj = {
  name: "codeText",
  tokenize: Dj,
  resolve: jj,
  previous: Nj
};
function jj(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function Nj(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Dj(e, t, n) {
  let r = 0, i, a;
  return o;
  function o(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(f);
  }
  function s(f) {
    return f === 96 ? (e.consume(f), r++, s) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (a = e.enter("codeTextSequence"), i = 0, u(f)) : Re(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || Re(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), c);
  }
  function u(f) {
    return f === 96 ? (e.consume(f), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", c(f));
  }
}
class Mj {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && jo(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), jo(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), jo(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        jo(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        jo(this.left, n.reverse());
      }
  }
}
function jo(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function e_(e) {
  const t = {};
  let n = -1, r, i, a, o, s, l, c;
  const u = new Mj(e);
  for (; ++n < u.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, Lj(u, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a-- && (o = u.get(a), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = a);
      i && (r[1].end = Object.assign({}, u.get(i)[1].start), s = u.slice(i, n), s.unshift(r), u.splice(i, n - i + 1, s));
    }
  }
  return Wn(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function Lj(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [], o = n._tokenizer || r.parser[n.contentType](n.start), s = o.events, l = [], c = {};
  let u, f, d = -1, p = n, h = 0, m = 0;
  const y = [m];
  for (; p; ) {
    for (; e.get(++i)[1] !== p; )
      ;
    a.push(i), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), f && o.defineSkip(p.start), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = p, p = p.next;
  }
  for (p = n; ++d < s.length; )
    // Find a void token that includes a break.
    s[d][0] === "exit" && s[d - 1][0] === "enter" && s[d][1].type === s[d - 1][1].type && s[d][1].start.line !== s[d][1].end.line && (m = d + 1, y.push(m), p._tokenizer = void 0, p.previous = void 0, p = p.next);
  for (o.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : y.pop(), d = y.length; d--; ) {
    const v = s.slice(y[d], y[d + 1]), g = a.pop();
    l.push([g, g + v.length - 1]), e.splice(g, 2, v);
  }
  for (l.reverse(), d = -1; ++d < l.length; )
    c[h + l[d][0]] = h + l[d][1], h += l[d][1] - l[d][0] - 1;
  return c;
}
const Fj = {
  tokenize: Uj,
  resolve: zj
}, Bj = {
  tokenize: qj,
  partial: !0
};
function zj(e) {
  return e_(e), e;
}
function Uj(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? a(s) : Re(s) ? e.check(Bj, o, a)(s) : (e.consume(s), i);
  }
  function a(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function o(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function qj(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), tt(e, a, "linePrefix");
  }
  function a(o) {
    if (o === null || Re(o))
      return n(o);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o);
  }
}
function t_(e, t, n, r, i, a, o, s, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return f;
  function f(v) {
    return v === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(v), e.exit(a), d) : v === null || v === 32 || v === 41 || tu(v) ? n(v) : (e.enter(r), e.enter(o), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), m(v));
  }
  function d(v) {
    return v === 62 ? (e.enter(a), e.consume(v), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), p(v));
  }
  function p(v) {
    return v === 62 ? (e.exit("chunkString"), e.exit(s), d(v)) : v === null || v === 60 || Re(v) ? n(v) : (e.consume(v), v === 92 ? h : p);
  }
  function h(v) {
    return v === 60 || v === 62 || v === 92 ? (e.consume(v), p) : p(v);
  }
  function m(v) {
    return !u && (v === null || v === 41 || gt(v)) ? (e.exit("chunkString"), e.exit(s), e.exit(o), e.exit(r), t(v)) : u < c && v === 40 ? (e.consume(v), u++, m) : v === 41 ? (e.consume(v), u--, m) : v === null || v === 32 || v === 40 || tu(v) ? n(v) : (e.consume(v), v === 92 ? y : m);
  }
  function y(v) {
    return v === 40 || v === 41 || v === 92 ? (e.consume(v), m) : m(v);
  }
}
function n_(e, t, n, r, i, a) {
  const o = this;
  let s = 0, l;
  return c;
  function c(p) {
    return e.enter(r), e.enter(i), e.consume(p), e.exit(i), e.enter(a), u;
  }
  function u(p) {
    return s > 999 || p === null || p === 91 || p === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    p === 94 && !s && "_hiddenFootnoteSupport" in o.parser.constructs ? n(p) : p === 93 ? (e.exit(a), e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : Re(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), f(p));
  }
  function f(p) {
    return p === null || p === 91 || p === 93 || Re(p) || s++ > 999 ? (e.exit("chunkString"), u(p)) : (e.consume(p), l || (l = !Ve(p)), p === 92 ? d : f);
  }
  function d(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), s++, f) : f(p);
  }
}
function r_(e, t, n, r, i, a) {
  let o;
  return s;
  function s(d) {
    return d === 34 || d === 39 || d === 40 ? (e.enter(r), e.enter(i), e.consume(d), e.exit(i), o = d === 40 ? 41 : d, l) : n(d);
  }
  function l(d) {
    return d === o ? (e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : (e.enter(a), c(d));
  }
  function c(d) {
    return d === o ? (e.exit(a), l(o)) : d === null ? n(d) : Re(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), tt(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(d));
  }
  function u(d) {
    return d === o || d === null || Re(d) ? (e.exit("chunkString"), c(d)) : (e.consume(d), d === 92 ? f : u);
  }
  function f(d) {
    return d === o || d === 92 ? (e.consume(d), u) : u(d);
  }
}
function ts(e, t) {
  let n;
  return r;
  function r(i) {
    return Re(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Ve(i) ? tt(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const Wj = {
  name: "definition",
  tokenize: Vj
}, Hj = {
  tokenize: Zj,
  partial: !0
};
function Vj(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(p) {
    return e.enter("definition"), o(p);
  }
  function o(p) {
    return n_.call(
      r,
      e,
      s,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(p);
  }
  function s(p) {
    return i = or(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), l) : n(p);
  }
  function l(p) {
    return gt(p) ? ts(e, c)(p) : c(p);
  }
  function c(p) {
    return t_(
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(p);
  }
  function u(p) {
    return e.attempt(Hj, f, f)(p);
  }
  function f(p) {
    return Ve(p) ? tt(e, d, "whitespace")(p) : d(p);
  }
  function d(p) {
    return p === null || Re(p) ? (e.exit("definition"), r.parser.defined.push(i), t(p)) : n(p);
  }
}
function Zj(e, t, n) {
  return r;
  function r(s) {
    return gt(s) ? ts(e, i)(s) : n(s);
  }
  function i(s) {
    return r_(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function a(s) {
    return Ve(s) ? tt(e, o, "whitespace")(s) : o(s);
  }
  function o(s) {
    return s === null || Re(s) ? t(s) : n(s);
  }
}
const Kj = {
  name: "hardBreakEscape",
  tokenize: Gj
};
function Gj(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return Re(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Yj = {
  name: "headingAtx",
  tokenize: Xj,
  resolve: Jj
};
function Jj(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Wn(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function Xj(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), a(u);
  }
  function a(u) {
    return e.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), o) : u === null || gt(u) ? (e.exit("atxHeadingSequence"), s(u)) : n(u);
  }
  function s(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), l(u)) : u === null || Re(u) ? (e.exit("atxHeading"), t(u)) : Ve(u) ? tt(e, s, "whitespace")(u) : (e.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (e.consume(u), l) : (e.exit("atxHeadingSequence"), s(u));
  }
  function c(u) {
    return u === null || u === 35 || gt(u) ? (e.exit("atxHeadingText"), s(u)) : (e.consume(u), c);
  }
}
const Qj = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], rb = ["pre", "script", "style", "textarea"], eN = {
  name: "htmlFlow",
  tokenize: iN,
  resolveTo: rN,
  concrete: !0
}, tN = {
  tokenize: oN,
  partial: !0
}, nN = {
  tokenize: aN,
  partial: !0
};
function rN(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function iN(e, t, n) {
  const r = this;
  let i, a, o, s, l;
  return c;
  function c(E) {
    return u(E);
  }
  function u(E) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(E), f;
  }
  function f(E) {
    return E === 33 ? (e.consume(E), d) : E === 47 ? (e.consume(E), a = !0, m) : E === 63 ? (e.consume(E), i = 3, r.interrupt ? t : x) : pn(E) ? (e.consume(E), o = String.fromCharCode(E), y) : n(E);
  }
  function d(E) {
    return E === 45 ? (e.consume(E), i = 2, p) : E === 91 ? (e.consume(E), i = 5, s = 0, h) : pn(E) ? (e.consume(E), i = 4, r.interrupt ? t : x) : n(E);
  }
  function p(E) {
    return E === 45 ? (e.consume(E), r.interrupt ? t : x) : n(E);
  }
  function h(E) {
    const X = "CDATA[";
    return E === X.charCodeAt(s++) ? (e.consume(E), s === X.length ? r.interrupt ? t : q : h) : n(E);
  }
  function m(E) {
    return pn(E) ? (e.consume(E), o = String.fromCharCode(E), y) : n(E);
  }
  function y(E) {
    if (E === null || E === 47 || E === 62 || gt(E)) {
      const X = E === 47, ae = o.toLowerCase();
      return !X && !a && rb.includes(ae) ? (i = 1, r.interrupt ? t(E) : q(E)) : Qj.includes(o.toLowerCase()) ? (i = 6, X ? (e.consume(E), v) : r.interrupt ? t(E) : q(E)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(E) : a ? g(E) : b(E));
    }
    return E === 45 || on(E) ? (e.consume(E), o += String.fromCharCode(E), y) : n(E);
  }
  function v(E) {
    return E === 62 ? (e.consume(E), r.interrupt ? t : q) : n(E);
  }
  function g(E) {
    return Ve(E) ? (e.consume(E), g) : O(E);
  }
  function b(E) {
    return E === 47 ? (e.consume(E), O) : E === 58 || E === 95 || pn(E) ? (e.consume(E), k) : Ve(E) ? (e.consume(E), b) : O(E);
  }
  function k(E) {
    return E === 45 || E === 46 || E === 58 || E === 95 || on(E) ? (e.consume(E), k) : S(E);
  }
  function S(E) {
    return E === 61 ? (e.consume(E), _) : Ve(E) ? (e.consume(E), S) : b(E);
  }
  function _(E) {
    return E === null || E === 60 || E === 61 || E === 62 || E === 96 ? n(E) : E === 34 || E === 39 ? (e.consume(E), l = E, $) : Ve(E) ? (e.consume(E), _) : j(E);
  }
  function $(E) {
    return E === l ? (e.consume(E), l = null, B) : E === null || Re(E) ? n(E) : (e.consume(E), $);
  }
  function j(E) {
    return E === null || E === 34 || E === 39 || E === 47 || E === 60 || E === 61 || E === 62 || E === 96 || gt(E) ? S(E) : (e.consume(E), j);
  }
  function B(E) {
    return E === 47 || E === 62 || Ve(E) ? b(E) : n(E);
  }
  function O(E) {
    return E === 62 ? (e.consume(E), N) : n(E);
  }
  function N(E) {
    return E === null || Re(E) ? q(E) : Ve(E) ? (e.consume(E), N) : n(E);
  }
  function q(E) {
    return E === 45 && i === 2 ? (e.consume(E), R) : E === 60 && i === 1 ? (e.consume(E), W) : E === 62 && i === 4 ? (e.consume(E), U) : E === 63 && i === 3 ? (e.consume(E), x) : E === 93 && i === 5 ? (e.consume(E), A) : Re(E) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(tN, Z, M)(E)) : E === null || Re(E) ? (e.exit("htmlFlowData"), M(E)) : (e.consume(E), q);
  }
  function M(E) {
    return e.check(nN, z, Z)(E);
  }
  function z(E) {
    return e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), D;
  }
  function D(E) {
    return E === null || Re(E) ? M(E) : (e.enter("htmlFlowData"), q(E));
  }
  function R(E) {
    return E === 45 ? (e.consume(E), x) : q(E);
  }
  function W(E) {
    return E === 47 ? (e.consume(E), o = "", F) : q(E);
  }
  function F(E) {
    if (E === 62) {
      const X = o.toLowerCase();
      return rb.includes(X) ? (e.consume(E), U) : q(E);
    }
    return pn(E) && o.length < 8 ? (e.consume(E), o += String.fromCharCode(E), F) : q(E);
  }
  function A(E) {
    return E === 93 ? (e.consume(E), x) : q(E);
  }
  function x(E) {
    return E === 62 ? (e.consume(E), U) : E === 45 && i === 2 ? (e.consume(E), x) : q(E);
  }
  function U(E) {
    return E === null || Re(E) ? (e.exit("htmlFlowData"), Z(E)) : (e.consume(E), U);
  }
  function Z(E) {
    return e.exit("htmlFlow"), t(E);
  }
}
function aN(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return Re(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a) : n(o);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
function oN(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(nl, t, n);
  }
}
const sN = {
  name: "htmlText",
  tokenize: lN
};
function lN(e, t, n) {
  const r = this;
  let i, a, o;
  return s;
  function s(x) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(x), l;
  }
  function l(x) {
    return x === 33 ? (e.consume(x), c) : x === 47 ? (e.consume(x), S) : x === 63 ? (e.consume(x), b) : pn(x) ? (e.consume(x), j) : n(x);
  }
  function c(x) {
    return x === 45 ? (e.consume(x), u) : x === 91 ? (e.consume(x), a = 0, h) : pn(x) ? (e.consume(x), g) : n(x);
  }
  function u(x) {
    return x === 45 ? (e.consume(x), p) : n(x);
  }
  function f(x) {
    return x === null ? n(x) : x === 45 ? (e.consume(x), d) : Re(x) ? (o = f, W(x)) : (e.consume(x), f);
  }
  function d(x) {
    return x === 45 ? (e.consume(x), p) : f(x);
  }
  function p(x) {
    return x === 62 ? R(x) : x === 45 ? d(x) : f(x);
  }
  function h(x) {
    const U = "CDATA[";
    return x === U.charCodeAt(a++) ? (e.consume(x), a === U.length ? m : h) : n(x);
  }
  function m(x) {
    return x === null ? n(x) : x === 93 ? (e.consume(x), y) : Re(x) ? (o = m, W(x)) : (e.consume(x), m);
  }
  function y(x) {
    return x === 93 ? (e.consume(x), v) : m(x);
  }
  function v(x) {
    return x === 62 ? R(x) : x === 93 ? (e.consume(x), v) : m(x);
  }
  function g(x) {
    return x === null || x === 62 ? R(x) : Re(x) ? (o = g, W(x)) : (e.consume(x), g);
  }
  function b(x) {
    return x === null ? n(x) : x === 63 ? (e.consume(x), k) : Re(x) ? (o = b, W(x)) : (e.consume(x), b);
  }
  function k(x) {
    return x === 62 ? R(x) : b(x);
  }
  function S(x) {
    return pn(x) ? (e.consume(x), _) : n(x);
  }
  function _(x) {
    return x === 45 || on(x) ? (e.consume(x), _) : $(x);
  }
  function $(x) {
    return Re(x) ? (o = $, W(x)) : Ve(x) ? (e.consume(x), $) : R(x);
  }
  function j(x) {
    return x === 45 || on(x) ? (e.consume(x), j) : x === 47 || x === 62 || gt(x) ? B(x) : n(x);
  }
  function B(x) {
    return x === 47 ? (e.consume(x), R) : x === 58 || x === 95 || pn(x) ? (e.consume(x), O) : Re(x) ? (o = B, W(x)) : Ve(x) ? (e.consume(x), B) : R(x);
  }
  function O(x) {
    return x === 45 || x === 46 || x === 58 || x === 95 || on(x) ? (e.consume(x), O) : N(x);
  }
  function N(x) {
    return x === 61 ? (e.consume(x), q) : Re(x) ? (o = N, W(x)) : Ve(x) ? (e.consume(x), N) : B(x);
  }
  function q(x) {
    return x === null || x === 60 || x === 61 || x === 62 || x === 96 ? n(x) : x === 34 || x === 39 ? (e.consume(x), i = x, M) : Re(x) ? (o = q, W(x)) : Ve(x) ? (e.consume(x), q) : (e.consume(x), z);
  }
  function M(x) {
    return x === i ? (e.consume(x), i = void 0, D) : x === null ? n(x) : Re(x) ? (o = M, W(x)) : (e.consume(x), M);
  }
  function z(x) {
    return x === null || x === 34 || x === 39 || x === 60 || x === 61 || x === 96 ? n(x) : x === 47 || x === 62 || gt(x) ? B(x) : (e.consume(x), z);
  }
  function D(x) {
    return x === 47 || x === 62 || gt(x) ? B(x) : n(x);
  }
  function R(x) {
    return x === 62 ? (e.consume(x), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(x);
  }
  function W(x) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), F;
  }
  function F(x) {
    return Ve(x) ? tt(e, A, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(x) : A(x);
  }
  function A(x) {
    return e.enter("htmlTextData"), o(x);
  }
}
const ov = {
  name: "labelEnd",
  tokenize: hN,
  resolveTo: pN,
  resolveAll: dN
}, cN = {
  tokenize: mN
}, uN = {
  tokenize: vN
}, fN = {
  tokenize: gN
};
function dN(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function pN(e, t) {
  let n = e.length, r = 0, i, a, o, s;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[o][1].end)
  }, u = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[o - 2][1].start)
  };
  return s = [["enter", l, t], ["enter", c, t]], s = Bn(s, e.slice(a + 1, a + r + 3)), s = Bn(s, [["enter", u, t]]), s = Bn(s, ef(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, o - 3), t)), s = Bn(s, [["exit", u, t], e[o - 2], e[o - 1], ["exit", c, t]]), s = Bn(s, e.slice(o + 1)), s = Bn(s, [["exit", l, t]]), Wn(e, a, e.length, s), e;
}
function hN(e, t, n) {
  const r = this;
  let i = r.events.length, a, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return s;
  function s(d) {
    return a ? a._inactive ? f(d) : (o = r.parser.defined.includes(or(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(d), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(d);
  }
  function l(d) {
    return d === 40 ? e.attempt(cN, u, o ? u : f)(d) : d === 91 ? e.attempt(uN, u, o ? c : f)(d) : o ? u(d) : f(d);
  }
  function c(d) {
    return e.attempt(fN, u, f)(d);
  }
  function u(d) {
    return t(d);
  }
  function f(d) {
    return a._balanced = !0, n(d);
  }
}
function mN(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), i;
  }
  function i(f) {
    return gt(f) ? ts(e, a)(f) : a(f);
  }
  function a(f) {
    return f === 41 ? u(f) : t_(e, o, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(f);
  }
  function o(f) {
    return gt(f) ? ts(e, l)(f) : u(f);
  }
  function s(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? r_(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(f) : u(f);
  }
  function c(f) {
    return gt(f) ? ts(e, u)(f) : u(f);
  }
  function u(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function vN(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return n_.call(r, e, a, o, "reference", "referenceMarker", "referenceString")(s);
  }
  function a(s) {
    return r.parser.defined.includes(or(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
  }
  function o(s) {
    return n(s);
  }
}
function gN(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const yN = {
  name: "labelStartImage",
  tokenize: bN,
  resolveAll: ov.resolveAll
};
function bN(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), a;
  }
  function a(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), o) : n(s);
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const xN = {
  name: "labelStartLink",
  tokenize: wN,
  resolveAll: ov.resolveAll
};
function wN(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const ed = {
  name: "lineEnding",
  tokenize: SN
};
function SN(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), tt(e, t, "linePrefix");
  }
}
const hc = {
  name: "thematicBreak",
  tokenize: EN
};
function EN(e, t, n) {
  let r = 0, i;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, s(c);
  }
  function s(c) {
    return c === i ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || Re(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === i ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), Ve(c) ? tt(e, s, "whitespace")(c) : s(c));
  }
}
const bn = {
  name: "list",
  tokenize: $N,
  continuation: {
    tokenize: ON
  },
  exit: CN
}, _N = {
  tokenize: RN,
  partial: !0
}, kN = {
  tokenize: TN,
  partial: !0
};
function $N(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return s;
  function s(p) {
    const h = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : yh(p)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), p === 42 || p === 45 ? e.check(hc, n, c)(p) : c(p);
      if (!r.interrupt || p === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(p);
    }
    return n(p);
  }
  function l(p) {
    return yh(p) && ++o < 10 ? (e.consume(p), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46) ? (e.exit("listItemValue"), c(p)) : n(p);
  }
  function c(p) {
    return e.enter("listItemMarker"), e.consume(p), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || p, e.check(
      nl,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(_N, d, f)
    );
  }
  function u(p) {
    return r.containerState.initialBlankLine = !0, a++, d(p);
  }
  function f(p) {
    return Ve(p) ? (e.enter("listItemPrefixWhitespace"), e.consume(p), e.exit("listItemPrefixWhitespace"), d) : n(p);
  }
  function d(p) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(p);
  }
}
function ON(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(nl, i, a);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, tt(e, t, "listItemIndent", r.containerState.size + 1)(s);
  }
  function a(s) {
    return r.containerState.furtherBlankLines || !Ve(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(kN, t, o)(s));
  }
  function o(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, tt(e, e.attempt(bn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function TN(e, t, n) {
  const r = this;
  return tt(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function CN(e) {
  e.exit(this.containerState.type);
}
function RN(e, t, n) {
  const r = this;
  return tt(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return !Ve(a) && o && o[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const ib = {
  name: "setextUnderline",
  tokenize: AN,
  resolveTo: IN
};
function IN(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", o, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = o, e.push(["exit", o, t]), e;
}
function AN(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(c) {
    let u = r.events.length, f;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        f = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), i = c, o(c)) : n(c);
  }
  function o(c) {
    return e.enter("setextHeadingLineSequence"), s(c);
  }
  function s(c) {
    return c === i ? (e.consume(c), s) : (e.exit("setextHeadingLineSequence"), Ve(c) ? tt(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || Re(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const PN = {
  tokenize: jN
};
function jN(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    nl,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      tt(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(Fj, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const NN = {
  resolveAll: a_()
}, DN = i_("string"), MN = i_("text");
function i_(e) {
  return {
    tokenize: t,
    resolveAll: a_(
      e === "text" ? LN : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, o, s);
    return o;
    function o(u) {
      return c(u) ? a(u) : s(u);
    }
    function s(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), a(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const f = i[u];
      let d = -1;
      if (f)
        for (; ++d < f.length; ) {
          const p = f[d];
          if (!p.previous || p.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function a_(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function LN(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, o = -1, s = 0, l;
      for (; a--; ) {
        const c = i[a];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            s++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          l = !0, s++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (s) {
        const c = {
          type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + a,
            _bufferIndex: a ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function FN(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, a = [];
  let o = [], s = [];
  const l = {
    consume: g,
    enter: b,
    exit: k,
    attempt: $(S),
    check: $(_),
    interrupt: $(_, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: p,
    sliceSerialize: d,
    now: h,
    defineSkip: m,
    write: f
  };
  let u = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function f(N) {
    return o = Bn(o, N), y(), o[o.length - 1] !== null ? [] : (j(t, 0), c.events = ef(a, c.events, c), c.events);
  }
  function d(N, q) {
    return zN(p(N), q);
  }
  function p(N) {
    return BN(o, N);
  }
  function h() {
    const { line: N, column: q, offset: M, _index: z, _bufferIndex: D } = r;
    return {
      line: N,
      column: q,
      offset: M,
      _index: z,
      _bufferIndex: D
    };
  }
  function m(N) {
    i[N.line] = N.column, O();
  }
  function y() {
    let N;
    for (; r._index < o.length; ) {
      const q = o[r._index];
      if (typeof q == "string")
        for (N = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === N && r._bufferIndex < q.length; )
          v(q.charCodeAt(r._bufferIndex));
      else
        v(q);
    }
  }
  function v(N) {
    u = u(N);
  }
  function g(N) {
    Re(N) ? (r.line++, r.column = 1, r.offset += N === -3 ? 2 : 1, O()) : N !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = N;
  }
  function b(N, q) {
    const M = q || {};
    return M.type = N, M.start = h(), c.events.push(["enter", M, c]), s.push(M), M;
  }
  function k(N) {
    const q = s.pop();
    return q.end = h(), c.events.push(["exit", q, c]), q;
  }
  function S(N, q) {
    j(N, q.from);
  }
  function _(N, q) {
    q.restore();
  }
  function $(N, q) {
    return M;
    function M(z, D, R) {
      let W, F, A, x;
      return Array.isArray(z) ? Z(z) : "tokenize" in z ? (
        // @ts-expect-error Looks like a construct.
        Z([z])
      ) : U(z);
      function U(te) {
        return se;
        function se(de) {
          const pe = de !== null && te[de], le = de !== null && te.null, J = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(pe) ? pe : pe ? [pe] : [],
            ...Array.isArray(le) ? le : le ? [le] : []
          ];
          return Z(J)(de);
        }
      }
      function Z(te) {
        return W = te, F = 0, te.length === 0 ? R : E(te[F]);
      }
      function E(te) {
        return se;
        function se(de) {
          return x = B(), A = te, te.partial || (c.currentConstruct = te), te.name && c.parser.constructs.disable.null.includes(te.name) ? ae() : te.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            q ? Object.assign(Object.create(c), q) : c,
            l,
            X,
            ae
          )(de);
        }
      }
      function X(te) {
        return N(A, x), D;
      }
      function ae(te) {
        return x.restore(), ++F < W.length ? E(W[F]) : R;
      }
    }
  }
  function j(N, q) {
    N.resolveAll && !a.includes(N) && a.push(N), N.resolve && Wn(
      c.events,
      q,
      c.events.length - q,
      N.resolve(c.events.slice(q), c)
    ), N.resolveTo && (c.events = N.resolveTo(c.events, c));
  }
  function B() {
    const N = h(), q = c.previous, M = c.currentConstruct, z = c.events.length, D = Array.from(s);
    return {
      restore: R,
      from: z
    };
    function R() {
      r = N, c.previous = q, c.currentConstruct = M, c.events.length = z, s = D, O();
    }
  }
  function O() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function BN(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let o;
  if (n === i)
    o = [e[n].slice(r, a)];
  else {
    if (o = e.slice(n, i), r > -1) {
      const s = o[0];
      typeof s == "string" ? o[0] = s.slice(r) : o.shift();
    }
    a > 0 && o.push(e[i].slice(0, a));
  }
  return o;
}
function zN(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let o;
    if (typeof a == "string")
      o = a;
    else
      switch (a) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(a);
      }
    i = a === -2, r.push(o);
  }
  return r.join("");
}
const UN = {
  42: bn,
  43: bn,
  45: bn,
  48: bn,
  49: bn,
  50: bn,
  51: bn,
  52: bn,
  53: bn,
  54: bn,
  55: bn,
  56: bn,
  57: bn,
  62: JE
}, qN = {
  91: Wj
}, WN = {
  [-2]: Qf,
  [-1]: Qf,
  32: Qf
}, HN = {
  35: Yj,
  42: hc,
  45: [ib, hc],
  60: eN,
  61: ib,
  95: hc,
  96: nb,
  126: nb
}, VN = {
  38: QE,
  92: XE
}, ZN = {
  [-5]: ed,
  [-4]: ed,
  [-3]: ed,
  33: yN,
  38: QE,
  42: bh,
  60: [xj, sN],
  91: xN,
  92: [Kj, XE],
  93: ov,
  95: bh,
  96: Pj
}, KN = {
  null: [bh, NN]
}, GN = {
  null: [42, 95]
}, YN = {
  null: []
}, JN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: GN,
  contentInitial: qN,
  disable: YN,
  document: UN,
  flow: HN,
  flowInitial: WN,
  insideSpan: KN,
  string: VN,
  text: ZN
}, Symbol.toStringTag, { value: "Module" }));
function XN(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    GE([JN, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(pj),
    document: i(mj),
    flow: i(PN),
    string: i(DN),
    text: i(MN)
  };
  return r;
  function i(a) {
    return o;
    function o(s) {
      return FN(r, a, s);
    }
  }
}
function QN(e) {
  for (; !e_(e); )
    ;
  return e;
}
const ab = /[\0\t\n\r]/g;
function eD() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, o, s) {
    const l = [];
    let c, u, f, d, p;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(o || void 0).decode(a)), f = 0, t = "", n && (a.charCodeAt(0) === 65279 && f++, n = void 0); f < a.length; ) {
      if (ab.lastIndex = f, c = ab.exec(a), d = c && c.index !== void 0 ? c.index : a.length, p = a.charCodeAt(d), !c) {
        t = a.slice(f);
        break;
      }
      if (p === 10 && f === d && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < d && (l.push(a.slice(f, d)), e += d - f), p) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, l.push(-2); e++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = d + 1;
    }
    return s && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const tD = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function nD(e) {
  return e.replace(tD, rD);
}
function rD(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return YE(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return av(n) || e;
}
const o_ = {}.hasOwnProperty;
function iD(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), aD(n)(QN(XN(n).document().write(eD()(e, t, !0))));
}
function aD(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(Q),
      autolinkProtocol: B,
      autolinkEmail: B,
      atxHeading: a(Oe),
      blockQuote: a(le),
      characterEscape: B,
      characterReference: B,
      codeFenced: a(J),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: a(J, o),
      codeText: a(V, o),
      codeTextData: B,
      data: B,
      codeFlowValue: B,
      definition: a(fe),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: a(me),
      hardBreakEscape: a(I),
      hardBreakTrailing: a(I),
      htmlFlow: a(G, o),
      htmlFlowData: B,
      htmlText: a(G, o),
      htmlTextData: B,
      image: a(re),
      label: o,
      link: a(Q),
      listItem: a(xe),
      listItemValue: d,
      listOrdered: a(_e, f),
      listUnordered: a(_e),
      paragraph: a(Ce),
      reference: E,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: a(Oe),
      strong: a(We),
      thematicBreak: a(Me)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: S,
      autolink: l(),
      autolinkEmail: pe,
      autolinkProtocol: de,
      blockQuote: l(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: ae,
      characterReferenceMarkerNumeric: ae,
      characterReferenceValue: te,
      characterReference: se,
      codeFenced: l(y),
      codeFencedFence: m,
      codeFencedFenceInfo: p,
      codeFencedFenceMeta: h,
      codeFlowValue: O,
      codeIndented: l(v),
      codeText: l(D),
      codeTextData: O,
      data: O,
      definition: l(),
      definitionDestinationString: k,
      definitionLabelString: g,
      definitionTitleString: b,
      emphasis: l(),
      hardBreakEscape: l(q),
      hardBreakTrailing: l(q),
      htmlFlow: l(M),
      htmlFlowData: O,
      htmlText: l(z),
      htmlTextData: O,
      image: l(W),
      label: A,
      labelText: F,
      lineEnding: N,
      link: l(R),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: X,
      resourceDestinationString: x,
      resourceTitleString: U,
      resource: Z,
      setextHeading: l(j),
      setextHeadingLineSequence: $,
      setextHeadingText: _,
      strong: l(),
      thematicBreak: l()
    }
  };
  s_(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(L) {
    let P = {
      type: "root",
      children: []
    };
    const Y = {
      stack: [P],
      tokenStack: [],
      config: t,
      enter: s,
      exit: c,
      buffer: o,
      resume: u,
      data: n
    }, ce = [];
    let Ee = -1;
    for (; ++Ee < L.length; )
      if (L[Ee][1].type === "listOrdered" || L[Ee][1].type === "listUnordered")
        if (L[Ee][0] === "enter")
          ce.push(Ee);
        else {
          const $e = ce.pop();
          Ee = i(L, $e, Ee);
        }
    for (Ee = -1; ++Ee < L.length; ) {
      const $e = t[L[Ee][0]];
      o_.call($e, L[Ee][1].type) && $e[L[Ee][1].type].call(Object.assign({
        sliceSerialize: L[Ee][2].sliceSerialize
      }, Y), L[Ee][1]);
    }
    if (Y.tokenStack.length > 0) {
      const $e = Y.tokenStack[Y.tokenStack.length - 1];
      ($e[1] || ob).call(Y, void 0, $e[0]);
    }
    for (P.position = {
      start: li(L.length > 0 ? L[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: li(L.length > 0 ? L[L.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ee = -1; ++Ee < t.transforms.length; )
      P = t.transforms[Ee](P) || P;
    return P;
  }
  function i(L, P, Y) {
    let ce = P - 1, Ee = -1, $e = !1, Ye, at, Bt, Rt;
    for (; ++ce <= Y; ) {
      const He = L[ce];
      switch (He[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          He[0] === "enter" ? Ee++ : Ee--, Rt = void 0;
          break;
        }
        case "lineEndingBlank": {
          He[0] === "enter" && (Ye && !Rt && !Ee && !Bt && (Bt = ce), Rt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Rt = void 0;
      }
      if (!Ee && He[0] === "enter" && He[1].type === "listItemPrefix" || Ee === -1 && He[0] === "exit" && (He[1].type === "listUnordered" || He[1].type === "listOrdered")) {
        if (Ye) {
          let It = ce;
          for (at = void 0; It--; ) {
            const Je = L[It];
            if (Je[1].type === "lineEnding" || Je[1].type === "lineEndingBlank") {
              if (Je[0] === "exit") continue;
              at && (L[at][1].type = "lineEndingBlank", $e = !0), Je[1].type = "lineEnding", at = It;
            } else if (!(Je[1].type === "linePrefix" || Je[1].type === "blockQuotePrefix" || Je[1].type === "blockQuotePrefixWhitespace" || Je[1].type === "blockQuoteMarker" || Je[1].type === "listItemIndent")) break;
          }
          Bt && (!at || Bt < at) && (Ye._spread = !0), Ye.end = Object.assign({}, at ? L[at][1].start : He[1].end), L.splice(at || ce, 0, ["exit", Ye, He[2]]), ce++, Y++;
        }
        if (He[1].type === "listItemPrefix") {
          const It = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, He[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Ye = It, L.splice(ce, 0, ["enter", It, He[2]]), ce++, Y++, Bt = void 0, Rt = !0;
        }
      }
    }
    return L[P][1]._spread = $e, Y;
  }
  function a(L, P) {
    return Y;
    function Y(ce) {
      s.call(this, L(ce), ce), P && P.call(this, ce);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(L, P, Y) {
    this.stack[this.stack.length - 1].children.push(L), this.stack.push(L), this.tokenStack.push([P, Y]), L.position = {
      start: li(P.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(L) {
    return P;
    function P(Y) {
      L && L.call(this, Y), c.call(this, Y);
    }
  }
  function c(L, P) {
    const Y = this.stack.pop(), ce = this.tokenStack.pop();
    if (ce)
      ce[0].type !== L.type && (P ? P.call(this, L, ce[0]) : (ce[1] || ob).call(this, L, ce[0]));
    else throw new Error("Cannot close `" + L.type + "` (" + es({
      start: L.start,
      end: L.end
    }) + "): its not open");
    Y.position.end = li(L.end);
  }
  function u() {
    return iv(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function d(L) {
    if (this.data.expectingFirstListItemValue) {
      const P = this.stack[this.stack.length - 2];
      P.start = Number.parseInt(this.sliceSerialize(L), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function p() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.lang = L;
  }
  function h() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.meta = L;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.value = L.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function v() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.value = L.replace(/(\r?\n|\r)$/g, "");
  }
  function g(L) {
    const P = this.resume(), Y = this.stack[this.stack.length - 1];
    Y.label = P, Y.identifier = or(this.sliceSerialize(L)).toLowerCase();
  }
  function b() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.title = L;
  }
  function k() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.url = L;
  }
  function S(L) {
    const P = this.stack[this.stack.length - 1];
    if (!P.depth) {
      const Y = this.sliceSerialize(L).length;
      P.depth = Y;
    }
  }
  function _() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function $(L) {
    const P = this.stack[this.stack.length - 1];
    P.depth = this.sliceSerialize(L).codePointAt(0) === 61 ? 1 : 2;
  }
  function j() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function B(L) {
    const Y = this.stack[this.stack.length - 1].children;
    let ce = Y[Y.length - 1];
    (!ce || ce.type !== "text") && (ce = Ie(), ce.position = {
      start: li(L.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Y.push(ce)), this.stack.push(ce);
  }
  function O(L) {
    const P = this.stack.pop();
    P.value += this.sliceSerialize(L), P.position.end = li(L.end);
  }
  function N(L) {
    const P = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Y = P.children[P.children.length - 1];
      Y.position.end = li(L.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(P.type) && (B.call(this, L), O.call(this, L));
  }
  function q() {
    this.data.atHardBreak = !0;
  }
  function M() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.value = L;
  }
  function z() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.value = L;
  }
  function D() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.value = L;
  }
  function R() {
    const L = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const P = this.data.referenceType || "shortcut";
      L.type += "Reference", L.referenceType = P, delete L.url, delete L.title;
    } else
      delete L.identifier, delete L.label;
    this.data.referenceType = void 0;
  }
  function W() {
    const L = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const P = this.data.referenceType || "shortcut";
      L.type += "Reference", L.referenceType = P, delete L.url, delete L.title;
    } else
      delete L.identifier, delete L.label;
    this.data.referenceType = void 0;
  }
  function F(L) {
    const P = this.sliceSerialize(L), Y = this.stack[this.stack.length - 2];
    Y.label = nD(P), Y.identifier = or(P).toLowerCase();
  }
  function A() {
    const L = this.stack[this.stack.length - 1], P = this.resume(), Y = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Y.type === "link") {
      const ce = L.children;
      Y.children = ce;
    } else
      Y.alt = P;
  }
  function x() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.url = L;
  }
  function U() {
    const L = this.resume(), P = this.stack[this.stack.length - 1];
    P.title = L;
  }
  function Z() {
    this.data.inReference = void 0;
  }
  function E() {
    this.data.referenceType = "collapsed";
  }
  function X(L) {
    const P = this.resume(), Y = this.stack[this.stack.length - 1];
    Y.label = P, Y.identifier = or(this.sliceSerialize(L)).toLowerCase(), this.data.referenceType = "full";
  }
  function ae(L) {
    this.data.characterReferenceType = L.type;
  }
  function te(L) {
    const P = this.sliceSerialize(L), Y = this.data.characterReferenceType;
    let ce;
    Y ? (ce = YE(P, Y === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : ce = av(P);
    const Ee = this.stack[this.stack.length - 1];
    Ee.value += ce;
  }
  function se(L) {
    const P = this.stack.pop();
    P.position.end = li(L.end);
  }
  function de(L) {
    O.call(this, L);
    const P = this.stack[this.stack.length - 1];
    P.url = this.sliceSerialize(L);
  }
  function pe(L) {
    O.call(this, L);
    const P = this.stack[this.stack.length - 1];
    P.url = "mailto:" + this.sliceSerialize(L);
  }
  function le() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function J() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function V() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function fe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function me() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Oe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function I() {
    return {
      type: "break"
    };
  }
  function G() {
    return {
      type: "html",
      value: ""
    };
  }
  function re() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Q() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function _e(L) {
    return {
      type: "list",
      ordered: L.type === "listOrdered",
      start: null,
      spread: L._spread,
      children: []
    };
  }
  function xe(L) {
    return {
      type: "listItem",
      spread: L._spread,
      checked: null,
      children: []
    };
  }
  function Ce() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function We() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ie() {
    return {
      type: "text",
      value: ""
    };
  }
  function Me() {
    return {
      type: "thematicBreak"
    };
  }
}
function li(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function s_(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? s_(e, r) : oD(e, r);
  }
}
function oD(e, t) {
  let n;
  for (n in t)
    if (o_.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function ob(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + es({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + es({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + es({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function sD(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return iD(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function lD(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cD(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function uD(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function fD(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dD(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function pD(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = go(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let o, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = a + 1, s += 1, e.footnoteCounts.set(r, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(o) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function hD(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function mD(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function l_(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function vD(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return l_(e, t);
  const i = { src: go(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function gD(e, t) {
  const n = { src: go(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function yD(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function bD(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return l_(e, t);
  const i = { href: go(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function xD(e, t) {
  const n = { href: go(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function wD(e, t, n) {
  const r = e.all(t), i = n ? SD(n) : c_(t), a = {}, o = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let f;
    u && u.type === "element" && u.tagName === "p" ? f = u : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const u = r[s];
    (i || s !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? o.push(...u.children) : o.push(u);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: o };
  return e.patch(t, c), e.applyData(t, c);
}
function SD(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = c_(n[r]);
  }
  return t;
}
function c_(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function ED(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function _D(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function kD(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function $D(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function OD(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = ev(t.children[1]), l = UE(t.children[t.children.length - 1]);
    s && l && (o.position = { start: s, end: l }), i.push(o);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function TD(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, s = o ? o.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < s; ) {
    const f = t.children[l], d = {}, p = o ? o[l] : void 0;
    p && (d.align = p);
    let h = { type: "element", tagName: a, properties: d, children: [] };
    f && (h.children = e.all(f), e.patch(f, h), h = e.applyData(f, h)), c.push(h);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function CD(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const sb = 9, lb = 32;
function RD(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      cb(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(cb(t.slice(i), i > 0, !1)), a.join("");
}
function cb(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === sb || a === lb; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === sb || a === lb; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function ID(e, t) {
  const n = { type: "text", value: RD(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function AD(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const PD = {
  blockquote: lD,
  break: cD,
  code: uD,
  delete: fD,
  emphasis: dD,
  footnoteReference: pD,
  heading: hD,
  html: mD,
  imageReference: vD,
  image: gD,
  inlineCode: yD,
  linkReference: bD,
  link: xD,
  listItem: wD,
  list: ED,
  paragraph: _D,
  // @ts-expect-error: root is different, but hard to type.
  root: kD,
  strong: $D,
  table: OD,
  tableCell: CD,
  tableRow: TD,
  text: ID,
  thematicBreak: AD,
  toml: jl,
  yaml: jl,
  definition: jl,
  footnoteDefinition: jl
};
function jl() {
}
const u_ = -1, tf = 0, ru = 1, iu = 2, sv = 3, lv = 4, cv = 5, uv = 6, f_ = 7, d_ = 8, ub = typeof self == "object" ? self : globalThis, jD = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, o] = t[i];
    switch (a) {
      case tf:
      case u_:
        return n(o, i);
      case ru: {
        const s = n([], i);
        for (const l of o)
          s.push(r(l));
        return s;
      }
      case iu: {
        const s = n({}, i);
        for (const [l, c] of o)
          s[r(l)] = r(c);
        return s;
      }
      case sv:
        return n(new Date(o), i);
      case lv: {
        const { source: s, flags: l } = o;
        return n(new RegExp(s, l), i);
      }
      case cv: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [l, c] of o)
          s.set(r(l), r(c));
        return s;
      }
      case uv: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const l of o)
          s.add(r(l));
        return s;
      }
      case f_: {
        const { name: s, message: l } = o;
        return n(new ub[s](l), i);
      }
      case d_:
        return n(BigInt(o), i);
      case "BigInt":
        return n(Object(BigInt(o)), i);
    }
    return n(new ub[a](o), i);
  };
  return r;
}, fb = (e) => jD(/* @__PURE__ */ new Map(), e)(0), ba = "", { toString: ND } = {}, { keys: DD } = Object, No = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [tf, t];
  const n = ND.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [ru, ba];
    case "Object":
      return [iu, ba];
    case "Date":
      return [sv, ba];
    case "RegExp":
      return [lv, ba];
    case "Map":
      return [cv, ba];
    case "Set":
      return [uv, ba];
  }
  return n.includes("Array") ? [ru, n] : n.includes("Error") ? [f_, n] : [iu, n];
}, Nl = ([e, t]) => e === tf && (t === "function" || t === "symbol"), MD = (e, t, n, r) => {
  const i = (o, s) => {
    const l = r.push(o) - 1;
    return n.set(s, l), l;
  }, a = (o) => {
    if (n.has(o))
      return n.get(o);
    let [s, l] = No(o);
    switch (s) {
      case tf: {
        let u = o;
        switch (l) {
          case "bigint":
            s = d_, u = o.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return i([u_], o);
        }
        return i([s, u], o);
      }
      case ru: {
        if (l)
          return i([l, [...o]], o);
        const u = [], f = i([s, u], o);
        for (const d of o)
          u.push(a(d));
        return f;
      }
      case iu: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, o.valueOf()], o);
          }
        if (t && "toJSON" in o)
          return a(o.toJSON());
        const u = [], f = i([s, u], o);
        for (const d of DD(o))
          (e || !Nl(No(o[d]))) && u.push([a(d), a(o[d])]);
        return f;
      }
      case sv:
        return i([s, o.toISOString()], o);
      case lv: {
        const { source: u, flags: f } = o;
        return i([s, { source: u, flags: f }], o);
      }
      case cv: {
        const u = [], f = i([s, u], o);
        for (const [d, p] of o)
          (e || !(Nl(No(d)) || Nl(No(p)))) && u.push([a(d), a(p)]);
        return f;
      }
      case uv: {
        const u = [], f = i([s, u], o);
        for (const d of o)
          (e || !Nl(No(d))) && u.push(a(d));
        return f;
      }
    }
    const { message: c } = o;
    return i([s, { name: l, message: c }], o);
  };
  return a;
}, db = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return MD(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, au = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? fb(db(e, t)) : structuredClone(e)
) : (e, t) => fb(db(e, t));
function LD(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function FD(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function BD(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || LD, r = e.options.footnoteBackLabel || FD, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const u = e.all(c), f = String(c.identifier).toUpperCase(), d = go(f.toLowerCase());
    let p = 0;
    const h = [], m = e.footnoteCounts.get(f);
    for (; m !== void 0 && ++p <= m; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let g = typeof n == "string" ? n : n(l, p);
      typeof g == "string" && (g = { type: "text", value: g }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + d + (p > 1 ? "-" + p : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, p),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(g) ? g : [g]
      });
    }
    const y = u[u.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const g = y.children[y.children.length - 1];
      g && g.type === "text" ? g.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...h);
    } else
      u.push(...h);
    const v = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + d },
      children: e.wrap(u, !0)
    };
    e.patch(c, v), s.push(v);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...au(o),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const nf = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return WD;
    if (typeof e == "function")
      return rf(e);
    if (typeof e == "object")
      return Array.isArray(e) ? zD(e) : UD(e);
    if (typeof e == "string")
      return qD(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function zD(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = nf(e[n]);
  return rf(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function UD(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return rf(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function qD(e) {
  return rf(t);
  function t(n) {
    return n && n.type === e;
  }
}
function rf(e) {
  return t;
  function t(n, r, i) {
    return !!(HD(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function WD() {
  return !0;
}
function HD(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const p_ = [], VD = !0, xh = !1, ZD = "skip";
function h_(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = nf(i), o = r ? -1 : 1;
  s(e, void 0, [])();
  function s(l, c, u) {
    const f = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof f.type == "string") {
      const p = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (l.type + (p ? "<" + p + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let p = p_, h, m, y;
      if ((!t || a(l, c, u[u.length - 1] || void 0)) && (p = KD(n(l, u)), p[0] === xh))
        return p;
      if ("children" in l && l.children) {
        const v = (
          /** @type {UnistParent} */
          l
        );
        if (v.children && p[0] !== ZD)
          for (m = (r ? v.children.length : -1) + o, y = u.concat(v); m > -1 && m < v.children.length; ) {
            const g = v.children[m];
            if (h = s(g, m, y)(), h[0] === xh)
              return h;
            m = typeof h[1] == "number" ? h[1] : m + o;
          }
      }
      return p;
    }
  }
}
function KD(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [VD, e] : e == null ? p_ : [e];
}
function fv(e, t, n, r) {
  let i, a, o;
  typeof t == "function" && typeof n != "function" ? (a = void 0, o = t, i = n) : (a = t, o = n, i = r), h_(e, a, s, i);
  function s(l, c) {
    const u = c[c.length - 1], f = u ? u.children.indexOf(l) : void 0;
    return o(l, f, u);
  }
}
const wh = {}.hasOwnProperty, GD = {};
function YD(e, t) {
  const n = t || GD, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), o = { ...PD, ...n.handlers }, s = {
    all: c,
    applyData: XD,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: o,
    one: l,
    options: n,
    patch: JD,
    wrap: eM
  };
  return fv(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const f = u.type === "definition" ? r : i, d = String(u.identifier).toUpperCase();
      f.has(d) || f.set(d, u);
    }
  }), s;
  function l(u, f) {
    const d = u.type, p = s.handlers[d];
    if (wh.call(s.handlers, d) && p)
      return p(s, u, f);
    if (s.options.passThrough && s.options.passThrough.includes(d)) {
      if ("children" in u) {
        const { children: m, ...y } = u, v = au(y);
        return v.children = s.all(u), v;
      }
      return au(u);
    }
    return (s.options.unknownHandler || QD)(s, u, f);
  }
  function c(u) {
    const f = [];
    if ("children" in u) {
      const d = u.children;
      let p = -1;
      for (; ++p < d.length; ) {
        const h = s.one(d[p], u);
        if (h) {
          if (p && d[p - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = pb(h.value)), !Array.isArray(h) && h.type === "element")) {
            const m = h.children[0];
            m && m.type === "text" && (m.value = pb(m.value));
          }
          Array.isArray(h) ? f.push(...h) : f.push(h);
        }
      }
    }
    return f;
  }
}
function JD(e, t) {
  e.position && (t.position = MP(e));
}
function XD(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const o = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: o };
      }
    n.type === "element" && a && Object.assign(n.properties, au(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function QD(e, t) {
  const n = t.data || {}, r = "value" in t && !(wh.call(n, "hProperties") || wh.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function eM(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function pb(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function hb(e, t) {
  const n = YD(e, t), r = n.one(e, void 0), i = BD(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function tM(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      hb(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      hb(n, { file: r, ...e || t })
    );
  };
}
function mb(e) {
  if (e)
    throw e;
}
var mc = Object.prototype.hasOwnProperty, m_ = Object.prototype.toString, vb = Object.defineProperty, gb = Object.getOwnPropertyDescriptor, yb = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : m_.call(t) === "[object Array]";
}, bb = function(t) {
  if (!t || m_.call(t) !== "[object Object]")
    return !1;
  var n = mc.call(t, "constructor"), r = t.constructor && t.constructor.prototype && mc.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || mc.call(t, i);
}, xb = function(t, n) {
  vb && n.name === "__proto__" ? vb(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, wb = function(t, n) {
  if (n === "__proto__")
    if (mc.call(t, n)) {
      if (gb)
        return gb(t, n).value;
    } else return;
  return t[n];
}, nM = function e() {
  var t, n, r, i, a, o, s = arguments[0], l = 1, c = arguments.length, u = !1;
  for (typeof s == "boolean" && (u = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < c; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = wb(s, n), i = wb(t, n), s !== i && (u && i && (bb(i) || (a = yb(i))) ? (a ? (a = !1, o = r && yb(r) ? r : []) : o = r && bb(r) ? r : {}, xb(s, { name: n, newValue: e(u, o, i) })) : typeof i < "u" && xb(s, { name: n, newValue: i }));
  return s;
};
const td = /* @__PURE__ */ Ze(nM);
function Sh(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function rM() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    s(null, ...i);
    function s(l, ...c) {
      const u = e[++a];
      let f = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++f < i.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = i[f]);
      i = c, u ? iM(u, s)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function iM(e, t) {
  let n;
  return r;
  function r(...o) {
    const s = e.length > o.length;
    let l;
    s && o.push(i);
    try {
      l = e.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (s && n)
        throw u;
      return i(u);
    }
    s || (l && l.then && typeof l.then == "function" ? l.then(a, i) : l instanceof Error ? i(l) : a(l));
  }
  function i(o, ...s) {
    n || (n = !0, t(o, ...s));
  }
  function a(o) {
    i(null, o);
  }
}
const wr = { basename: aM, dirname: oM, extname: sM, join: lM, sep: "/" };
function aM(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  rl(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let o = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (a = !0, o = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = o));
  return n === r ? r = o : r < 0 && (r = e.length), e.slice(n, r);
}
function oM(e) {
  if (rl(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function sM(e) {
  rl(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, o;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = t + 1), s === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function lM(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    rl(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : cM(n);
}
function cM(e) {
  rl(e);
  const t = e.codePointAt(0) === 47;
  let n = uM(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function uM(e, t) {
  let n = "", r = 0, i = -1, a = 0, o = -1, s, l;
  for (; ++o <= e.length; ) {
    if (o < e.length)
      s = e.codePointAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === o - 1 || a === 1)) if (i !== o - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = o, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = o, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, o) : n = e.slice(i + 1, o), r = o - i - 1;
      i = o, a = 0;
    } else s === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function rl(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const fM = { cwd: dM };
function dM() {
  return "/";
}
function Eh(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function pM(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Eh(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return hM(e);
}
function hM(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const nd = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class v_ {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Eh(t) ? n = { path: t } : typeof t == "string" || mM(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : fM.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < nd.length; ) {
      const a = nd[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      nd.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? wr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    id(t, "basename"), rd(t, "basename"), this.path = wr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? wr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Sb(this.basename, "dirname"), this.path = wr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? wr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (rd(t, "extname"), Sb(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = wr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Eh(t) && (t = pM(t)), id(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? wr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    id(t, "stem"), rd(t, "stem"), this.path = wr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new cn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function rd(e, t) {
  if (e && e.includes(wr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + wr.sep + "`"
    );
}
function id(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Sb(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function mM(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const vM = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), gM = {}.hasOwnProperty;
class dv extends vM {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = rM();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new dv()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(td(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (sd("data", this.frozen), this.namespace[t] = n, this) : gM.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (sd("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Dl(t), r = this.parser || this.Parser;
    return ad("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), ad("process", this.parser || this.Parser), od("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, o) {
      const s = Dl(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(l, s, function(u, f, d) {
        if (u || !f || !d)
          return c(u);
        const p = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), h = r.stringify(p, d);
        xM(h) ? d.value = h : d.result = h, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          d
        );
      });
      function c(u, f) {
        u || !f ? o(u) : a ? a(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), ad("processSync", this.parser || this.Parser), od("processSync", this.compiler || this.Compiler), this.process(t, i), _b("processSync", "process", n), r;
    function i(a, o) {
      n = !0, mb(a), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Eb(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(o, s) {
      const l = Dl(n);
      i.run(t, l, c);
      function c(u, f, d) {
        const p = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        u ? s(u) : o ? o(p) : r(void 0, p, d);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), _b("runSync", "run", r), i;
    function a(o, s) {
      mb(o), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Dl(n), i = this.compiler || this.Compiler;
    return od("stringify", i), Eb(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (sd("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : o(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, f);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(c.plugins), c.settings && (i.settings = td(!0, i.settings, c.settings));
    }
    function s(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const f = c[u];
          a(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let f = -1, d = -1;
      for (; ++f < r.length; )
        if (r[f][0] === c) {
          d = f;
          break;
        }
      if (d === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [p, ...h] = u;
        const m = r[d][1];
        Sh(m) && Sh(p) && (p = td(!0, m, p)), r[d] = [c, p, ...h];
      }
    }
  }
}
const yM = new dv().freeze();
function ad(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function od(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function sd(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Eb(e) {
  if (!Sh(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function _b(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Dl(e) {
  return bM(e) ? e : new v_(e);
}
function bM(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function xM(e) {
  return typeof e == "string" || wM(e);
}
function wM(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const SM = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", kb = [], $b = { allowDangerousHtml: !0 }, EM = /^(https?|ircs?|mailto|xmpp)$/i, _M = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function kM(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, a = e.components, o = e.disallowedElements, s = e.rehypePlugins || kb, l = e.remarkPlugins || kb, c = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...$b } : $b, u = e.skipHtml, f = e.unwrapDisallowed, d = e.urlTransform || $M, p = yM().use(sD).use(l).use(tM, c).use(s), h = new v_();
  typeof r == "string" && (h.value = r);
  for (const g of _M)
    Object.hasOwn(e, g.from) && ("" + g.from + (g.to ? "use `" + g.to + "` instead" : "remove it") + SM + g.id, void 0);
  const m = p.parse(h);
  let y = p.runSync(m, h);
  return i && (y = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), fv(y, v), qP(y, {
    Fragment: C.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: C.jsx,
    jsxs: C.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function v(g, b, k) {
    if (g.type === "raw" && k && typeof b == "number")
      return u ? k.children.splice(b, 1) : k.children[b] = { type: "text", value: g.value }, b;
    if (g.type === "element") {
      let S;
      for (S in Xf)
        if (Object.hasOwn(Xf, S) && Object.hasOwn(g.properties, S)) {
          const _ = g.properties[S], $ = Xf[S];
          ($ === null || $.includes(g.tagName)) && (g.properties[S] = d(String(_ || ""), S, g));
        }
    }
    if (g.type === "element") {
      let S = t ? !t.includes(g.tagName) : o ? o.includes(g.tagName) : !1;
      if (!S && n && typeof b == "number" && (S = !n(g, b, k)), S && k && typeof b == "number")
        return f && g.children ? k.children.splice(b, 1, ...g.children) : k.children.splice(b, 1), b;
    }
  }
}
function $M(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    EM.test(e.slice(0, t)) ? e : ""
  );
}
function OM(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function g_(e, t, n) {
  const i = nf((n || {}).ignore || []), a = TM(t);
  let o = -1;
  for (; ++o < a.length; )
    h_(e, "text", s);
  function s(c, u) {
    let f = -1, d;
    for (; ++f < u.length; ) {
      const p = u[f], h = d ? d.children : void 0;
      if (i(
        p,
        h ? h.indexOf(p) : void 0,
        d
      ))
        return;
      d = p;
    }
    if (d)
      return l(c, u);
  }
  function l(c, u) {
    const f = u[u.length - 1], d = a[o][0], p = a[o][1];
    let h = 0;
    const y = f.children.indexOf(c);
    let v = !1, g = [];
    d.lastIndex = 0;
    let b = d.exec(c.value);
    for (; b; ) {
      const k = b.index, S = {
        index: b.index,
        input: b.input,
        stack: [...u, c]
      };
      let _ = p(...b, S);
      if (typeof _ == "string" && (_ = _.length > 0 ? { type: "text", value: _ } : void 0), _ === !1 ? d.lastIndex = k + 1 : (h !== k && g.push({
        type: "text",
        value: c.value.slice(h, k)
      }), Array.isArray(_) ? g.push(..._) : _ && g.push(_), h = k + b[0].length, v = !0), !d.global)
        break;
      b = d.exec(c.value);
    }
    return v ? (h < c.value.length && g.push({ type: "text", value: c.value.slice(h) }), f.children.splice(y, 1, ...g)) : g = [c], y + g.length;
  }
}
function TM(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([CM(i[0]), RM(i[1])]);
  }
  return t;
}
function CM(e) {
  return typeof e == "string" ? new RegExp(OM(e), "g") : e;
}
function RM(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function IM(e) {
  g_(e, [/\r?\n|\r/g, AM]);
}
function AM() {
  return { type: "break" };
}
function PM() {
  return function(e) {
    IM(e);
  };
}
function Ob(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const ld = "phrasing", cd = ["autolink", "link", "image", "label"];
function jM() {
  return {
    transforms: [zM],
    enter: {
      literalAutolink: DM,
      literalAutolinkEmail: ud,
      literalAutolinkHttp: ud,
      literalAutolinkWww: ud
    },
    exit: {
      literalAutolink: BM,
      literalAutolinkEmail: FM,
      literalAutolinkHttp: MM,
      literalAutolinkWww: LM
    }
  };
}
function NM() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: ld,
        notInConstruct: cd
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: ld,
        notInConstruct: cd
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: ld,
        notInConstruct: cd
      }
    ]
  };
}
function DM(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function ud(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function MM(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function LM(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function FM(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function BM(e) {
  this.exit(e);
}
function zM(e) {
  g_(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, UM],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), qM]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function UM(e, t, n, r, i) {
  let a = "";
  if (!y_(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !WM(n)))
    return !1;
  const o = HM(n + r);
  if (!o[0]) return !1;
  const s = {
    type: "link",
    title: null,
    url: a + t + o[0],
    children: [{ type: "text", value: t + o[0] }]
  };
  return o[1] ? [s, { type: "text", value: o[1] }] : s;
}
function qM(e, t, n, r) {
  return (
    // Not an expected previous character.
    !y_(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function WM(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function HM(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Ob(e, "(");
  let a = Ob(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function y_(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || na(n) || Qu(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
b_.peek = n2;
function VM() {
  return {
    enter: {
      gfmFootnoteDefinition: KM,
      gfmFootnoteDefinitionLabelString: GM,
      gfmFootnoteCall: XM,
      gfmFootnoteCallString: QM
    },
    exit: {
      gfmFootnoteDefinition: JM,
      gfmFootnoteDefinitionLabelString: YM,
      gfmFootnoteCall: t2,
      gfmFootnoteCallString: e2
    }
  };
}
function ZM() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: r2, footnoteReference: b_ }
  };
}
function KM(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function GM() {
  this.buffer();
}
function YM(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = or(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function JM(e) {
  this.exit(e);
}
function XM(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function QM() {
  this.buffer();
}
function e2(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = or(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function t2(e) {
  this.exit(e);
}
function b_(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteReference"), s = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), o(), a += i.move("]"), a;
}
function n2() {
  return "[";
}
function r2(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteDefinition"), s = n.enter("label");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), a += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), a += i.move(
    n.indentLines(n.containerFlow(e, i.current()), i2)
  ), o(), a;
}
function i2(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const a2 = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
x_.peek = u2;
function o2() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: l2 },
    exit: { strikethrough: c2 }
  };
}
function s2() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: a2
      }
    ],
    handlers: { delete: x_ }
  };
}
function l2(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function c2(e) {
  this.exit(e);
}
function x_(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let o = i.move("~~");
  return o += n.containerPhrasing(e, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), a(), o;
}
function u2() {
  return "~";
}
function f2(e) {
  return e.length;
}
function d2(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || f2, a = [], o = [], s = [], l = [];
  let c = 0, u = -1;
  for (; ++u < e.length; ) {
    const m = [], y = [];
    let v = -1;
    for (e[u].length > c && (c = e[u].length); ++v < e[u].length; ) {
      const g = p2(e[u][v]);
      if (n.alignDelimiters !== !1) {
        const b = i(g);
        y[v] = b, (l[v] === void 0 || b > l[v]) && (l[v] = b);
      }
      m.push(g);
    }
    o[u] = m, s[u] = y;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < c; )
      a[f] = Tb(r[f]);
  else {
    const m = Tb(r);
    for (; ++f < c; )
      a[f] = m;
  }
  f = -1;
  const d = [], p = [];
  for (; ++f < c; ) {
    const m = a[f];
    let y = "", v = "";
    m === 99 ? (y = ":", v = ":") : m === 108 ? y = ":" : m === 114 && (v = ":");
    let g = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - y.length - v.length
    );
    const b = y + "-".repeat(g) + v;
    n.alignDelimiters !== !1 && (g = y.length + g + v.length, g > l[f] && (l[f] = g), p[f] = g), d[f] = b;
  }
  o.splice(1, 0, d), s.splice(1, 0, p), u = -1;
  const h = [];
  for (; ++u < o.length; ) {
    const m = o[u], y = s[u];
    f = -1;
    const v = [];
    for (; ++f < c; ) {
      const g = m[f] || "";
      let b = "", k = "";
      if (n.alignDelimiters !== !1) {
        const S = l[f] - (y[f] || 0), _ = a[f];
        _ === 114 ? b = " ".repeat(S) : _ === 99 ? S % 2 ? (b = " ".repeat(S / 2 + 0.5), k = " ".repeat(S / 2 - 0.5)) : (b = " ".repeat(S / 2), k = b) : k = " ".repeat(S);
      }
      n.delimiterStart !== !1 && !f && v.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && g === "") && (n.delimiterStart !== !1 || f) && v.push(" "), n.alignDelimiters !== !1 && v.push(b), v.push(g), n.alignDelimiters !== !1 && v.push(k), n.padding !== !1 && v.push(" "), (n.delimiterEnd !== !1 || f !== c - 1) && v.push("|");
    }
    h.push(
      n.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return h.join(`
`);
}
function p2(e) {
  return e == null ? "" : String(e);
}
function Tb(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function h2(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const o = n.indentLines(
    n.containerFlow(e, a.current()),
    m2
  );
  return i(), o;
}
function m2(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function v2(e, t) {
  return Cb(e, t.inConstruct, !0) && !Cb(e, t.notInConstruct, !1);
}
function Cb(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Rb(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && v2(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function g2(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, o = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > o && (o = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return o;
}
function y2(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function b2(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function x2(e, t, n, r) {
  const i = b2(n), a = e.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (y2(e, n)) {
    const f = n.enter("codeIndented"), d = n.indentLines(a, w2);
    return f(), d;
  }
  const s = n.createTracker(r), l = i.repeat(Math.max(g2(a, i) + 1, 3)), c = n.enter("codeFenced");
  let u = s.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${o}`);
    u += s.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${o}`);
    u += s.move(" "), u += s.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  return u += s.move(`
`), a && (u += s.move(a + `
`)), u += s.move(l), c(), u;
}
function w2(e, t, n) {
  return (n ? "" : "    ") + e;
}
function pv(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function S2(e, t, n, r) {
  const i = pv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), s(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), s()), o(), c;
}
function E2(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
w_.peek = _2;
function w_(e, t, n, r) {
  const i = E2(n), a = n.enter("emphasis"), o = n.createTracker(r);
  let s = o.move(i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i), a(), s;
}
function _2(e, t, n) {
  return n.options.emphasis || "*";
}
function k2(e, t) {
  let n = !1;
  return fv(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, xh;
  }), !!((!e.depth || e.depth < 3) && iv(e) && (t.options.setext || n));
}
function $2(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (k2(e, n)) {
    const u = n.enter("headingSetext"), f = n.enter("phrasing"), d = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f(), u(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), s = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(o + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), s(), c;
}
S_.peek = O2;
function S_(e) {
  return e.value || "";
}
function O2() {
  return "<";
}
E_.peek = T2;
function E_(e, t, n, r) {
  const i = pv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), s(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), s()), c += l.move(")"), o(), c;
}
function T2() {
  return "!";
}
__.peek = C2;
function __(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !c || c !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function C2() {
  return "!";
}
k_.peek = R2;
function k_(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const o = n.unsafe[a], s = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = s.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function R2() {
  return "`";
}
function $_(e, t) {
  const n = iv(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
O_.peek = I2;
function O_(e, t, n, r) {
  const i = pv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let s, l;
  if ($_(e, n)) {
    const u = n.stack;
    n.stack = [], s = n.enter("autolink");
    let f = o.move("<");
    return f += o.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...o.current()
      })
    ), f += o.move(">"), s(), n.stack = u, f;
  }
  s = n.enter("link"), l = n.enter("label");
  let c = o.move("[");
  return c += o.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    n.safe(e.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...o.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += o.move(" " + i), c += o.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), l()), c += o.move(")"), s(), c;
}
function I2(e, t, n) {
  return $_(e, n) ? "<" : "[";
}
T_.peek = A2;
function T_(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !c || c !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function A2() {
  return "[";
}
function hv(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function P2(e) {
  const t = hv(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function j2(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function C_(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function N2(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let o = e.ordered ? j2(n) : hv(n);
  const s = e.ordered ? o === "." ? ")" : "." : P2(n);
  let l = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), C_(n) === o && u
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const d = e.children[f];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = s), n.bulletCurrent = o;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = o, n.bulletCurrent = a, i(), c;
}
function D2(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function M2(e, t, n, r) {
  const i = D2(n);
  let a = n.bulletCurrent || hv(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let o = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const s = n.createTracker(r);
  s.move(a + " ".repeat(o - a.length)), s.shift(o);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, s.current()),
    u
  );
  return l(), c;
  function u(f, d, p) {
    return d ? (p ? "" : " ".repeat(o)) + f : (p ? a : a + " ".repeat(o - a.length)) + f;
  }
}
function L2(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), o = n.containerPhrasing(e, r);
  return a(), i(), o;
}
const F2 = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  nf([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function B2(e, t, n, r) {
  return (e.children.some(function(o) {
    return F2(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function z2(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
R_.peek = U2;
function R_(e, t, n, r) {
  const i = z2(n), a = n.enter("strong"), o = n.createTracker(r);
  let s = o.move(i + i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i + i), a(), s;
}
function U2(e, t, n) {
  return n.options.strong || "*";
}
function q2(e, t, n, r) {
  return n.safe(e.value, r);
}
function W2(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function H2(e, t, n) {
  const r = (C_(n) + (n.options.ruleSpaces ? " " : "")).repeat(W2(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const I_ = {
  blockquote: h2,
  break: Rb,
  code: x2,
  definition: S2,
  emphasis: w_,
  hardBreak: Rb,
  heading: $2,
  html: S_,
  image: E_,
  imageReference: __,
  inlineCode: k_,
  link: O_,
  linkReference: T_,
  list: N2,
  listItem: M2,
  paragraph: L2,
  root: B2,
  strong: R_,
  text: q2,
  thematicBreak: H2
};
function V2() {
  return {
    enter: {
      table: Z2,
      tableData: Ib,
      tableHeader: Ib,
      tableRow: G2
    },
    exit: {
      codeText: Y2,
      table: K2,
      tableData: fd,
      tableHeader: fd,
      tableRow: fd
    }
  };
}
function Z2(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function K2(e) {
  this.exit(e), this.data.inTable = void 0;
}
function G2(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function fd(e) {
  this.exit(e);
}
function Ib(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Y2(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, J2));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function J2(e, t) {
  return t === "|" ? t : e;
}
function X2(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: o,
      tableCell: l,
      tableRow: s
    }
  };
  function o(p, h, m, y) {
    return c(u(p, m, y), p.align);
  }
  function s(p, h, m, y) {
    const v = f(p, m, y), g = c([v]);
    return g.slice(0, g.indexOf(`
`));
  }
  function l(p, h, m, y) {
    const v = m.enter("tableCell"), g = m.enter("phrasing"), b = m.containerPhrasing(p, {
      ...y,
      before: a,
      after: a
    });
    return g(), v(), b;
  }
  function c(p, h) {
    return d2(p, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(p, h, m) {
    const y = p.children;
    let v = -1;
    const g = [], b = h.enter("table");
    for (; ++v < y.length; )
      g[v] = f(y[v], h, m);
    return b(), g;
  }
  function f(p, h, m) {
    const y = p.children;
    let v = -1;
    const g = [], b = h.enter("tableRow");
    for (; ++v < y.length; )
      g[v] = l(y[v], p, h, m);
    return b(), g;
  }
  function d(p, h, m) {
    let y = I_.inlineCode(p, h, m);
    return m.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function Q2() {
  return {
    exit: {
      taskListCheckValueChecked: Ab,
      taskListCheckValueUnchecked: Ab,
      paragraph: tL
    }
  };
}
function eL() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: nL }
  };
}
function Ab(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function tL(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, o;
      for (; ++a < i.length; ) {
        const s = i[a];
        if (s.type === "paragraph") {
          o = s;
          break;
        }
      }
      o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function nL(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  a && s.move(o);
  let l = I_.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
function rL() {
  return [
    jM(),
    VM(),
    o2(),
    V2(),
    Q2()
  ];
}
function iL(e) {
  return {
    extensions: [
      NM(),
      ZM(),
      s2(),
      X2(e),
      eL()
    ]
  };
}
const aL = {
  tokenize: fL,
  partial: !0
}, A_ = {
  tokenize: dL,
  partial: !0
}, P_ = {
  tokenize: pL,
  partial: !0
}, j_ = {
  tokenize: hL,
  partial: !0
}, oL = {
  tokenize: mL,
  partial: !0
}, N_ = {
  name: "wwwAutolink",
  tokenize: cL,
  previous: M_
}, D_ = {
  name: "protocolAutolink",
  tokenize: uL,
  previous: L_
}, ni = {
  name: "emailAutolink",
  tokenize: lL,
  previous: F_
}, jr = {};
function sL() {
  return {
    text: jr
  };
}
let Ui = 48;
for (; Ui < 123; )
  jr[Ui] = ni, Ui++, Ui === 58 ? Ui = 65 : Ui === 91 && (Ui = 97);
jr[43] = ni;
jr[45] = ni;
jr[46] = ni;
jr[95] = ni;
jr[72] = [ni, D_];
jr[104] = [ni, D_];
jr[87] = [ni, N_];
jr[119] = [ni, N_];
function lL(e, t, n) {
  const r = this;
  let i, a;
  return o;
  function o(f) {
    return !_h(f) || !F_.call(r, r.previous) || mv(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(f));
  }
  function s(f) {
    return _h(f) ? (e.consume(f), s) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(oL, u, c)(f) : f === 45 || f === 95 || on(f) ? (a = !0, e.consume(f), l) : u(f);
  }
  function c(f) {
    return e.consume(f), i = !0, l;
  }
  function u(f) {
    return a && i && pn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function cL(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !M_.call(r, r.previous) || mv(r.events) ? n(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(aL, e.attempt(A_, e.attempt(P_, a), n), n)(o));
  }
  function a(o) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o);
  }
}
function uL(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return o;
  function o(f) {
    return (f === 72 || f === 104) && L_.call(r, r.previous) && !mv(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(f), e.consume(f), s) : n(f);
  }
  function s(f) {
    if (pn(f) && i.length < 5)
      return i += String.fromCodePoint(f), e.consume(f), s;
    if (f === 58) {
      const d = i.toLowerCase();
      if (d === "http" || d === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), a ? c : (a = !0, l)) : n(f);
  }
  function c(f) {
    return f === null || tu(f) || gt(f) || na(f) || Qu(f) ? n(f) : e.attempt(A_, e.attempt(P_, u), n)(f);
  }
  function u(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function fL(e, t, n) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, e.consume(o), i) : o === 46 && r === 3 ? (e.consume(o), a) : n(o);
  }
  function a(o) {
    return o === null ? n(o) : t(o);
  }
}
function dL(e, t, n) {
  let r, i, a;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? e.check(j_, l, s)(c) : c === null || gt(c) || na(c) || c !== 45 && Qu(c) ? l(c) : (a = !0, e.consume(c), o);
  }
  function s(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), e.consume(c), o;
  }
  function l(c) {
    return i || r || !a ? n(c) : t(c);
  }
}
function pL(e, t) {
  let n = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (n++, e.consume(o), i) : o === 41 && r < n ? a(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(j_, t, a)(o) : o === null || gt(o) || na(o) ? t(o) : (e.consume(o), i);
  }
  function a(o) {
    return o === 41 && r++, e.consume(o), i;
  }
}
function hL(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), a) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || gt(s) || na(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || gt(s) || na(s) ? t(s) : r(s);
  }
  function a(s) {
    return pn(s) ? o(s) : n(s);
  }
  function o(s) {
    return s === 59 ? (e.consume(s), r) : pn(s) ? (e.consume(s), o) : n(s);
  }
}
function mL(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return on(a) ? n(a) : t(a);
  }
}
function M_(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || gt(e);
}
function L_(e) {
  return !pn(e);
}
function F_(e) {
  return !(e === 47 || _h(e));
}
function _h(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || on(e);
}
function mv(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const vL = {
  tokenize: _L,
  partial: !0
};
function gL() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: wL,
        continuation: {
          tokenize: SL
        },
        exit: EL
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: xL
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: yL,
        resolveTo: bL
      }
    }
  };
}
function yL(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      o = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return s;
  function s(l) {
    if (!o || !o._balanced)
      return n(l);
    const c = or(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function bL(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function xL(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, o;
  return s;
  function s(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(f) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || gt(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const d = e.exit("gfmFootnoteCallString");
      return i.includes(or(r.sliceSerialize(d))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return gt(f) || (o = !0), a++, e.consume(f), f === 92 ? u : c;
  }
  function u(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), a++, c) : c(f);
  }
}
function wL(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, o = 0, s;
  return l;
  function l(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(h);
  }
  function u(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || gt(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteDefinitionLabelString");
      return a = or(r.sliceSerialize(m)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), d;
    }
    return gt(h) || (s = !0), o++, e.consume(h), h === 92 ? f : u;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, u) : u(h);
  }
  function d(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), i.includes(a) || i.push(a), tt(e, p, "gfmFootnoteDefinitionWhitespace")) : n(h);
  }
  function p(h) {
    return t(h);
  }
}
function SL(e, t, n) {
  return e.check(nl, t, e.attempt(vL, t, n));
}
function EL(e) {
  e.exit("gfmFootnoteDefinition");
}
function _L(e, t, n) {
  const r = this;
  return tt(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? t(a) : n(a);
  }
}
function kL(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, s) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[l][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[l][1].start)
            }, d = [["enter", u, s], ["enter", o[c][1], s], ["exit", o[c][1], s], ["enter", f, s]], p = s.parser.constructs.insideSpan.null;
            p && Wn(d, d.length, 0, ef(p, o.slice(c + 1, l), s)), Wn(d, d.length, 0, [["exit", f, s], ["enter", o[l][1], s], ["exit", o[l][1], s], ["exit", u, s]]), Wn(o, c - 1, l - c + 3, d), l = c + d.length - 2;
            break;
          }
      }
    for (l = -1; ++l < o.length; )
      o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function a(o, s, l) {
    const c = this.previous, u = this.events;
    let f = 0;
    return d;
    function d(h) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(h) : (o.enter("strikethroughSequenceTemporary"), p(h));
    }
    function p(h) {
      const m = nu(c);
      if (h === 126)
        return f > 1 ? l(h) : (o.consume(h), f++, p);
      if (f < 2 && !n) return l(h);
      const y = o.exit("strikethroughSequenceTemporary"), v = nu(h);
      return y._open = !v || v === 2 && !!m, y._close = !m || m === 2 && !!v, s(h);
    }
  }
}
class $L {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    OL(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, o) {
      return a[0] - o[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function OL(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function TL(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function CL() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: RL,
        resolveAll: IL
      }
    }
  };
}
function RL(e, t, n) {
  const r = this;
  let i = 0, a = 0, o;
  return s;
  function s(O) {
    let N = r.events.length - 1;
    for (; N > -1; ) {
      const z = r.events[N][1].type;
      if (z === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      z === "linePrefix") N--;
      else break;
    }
    const q = N > -1 ? r.events[N][1].type : null, M = q === "tableHead" || q === "tableRow" ? _ : l;
    return M === _ && r.parser.lazy[r.now().line] ? n(O) : M(O);
  }
  function l(O) {
    return e.enter("tableHead"), e.enter("tableRow"), c(O);
  }
  function c(O) {
    return O === 124 || (o = !0, a += 1), u(O);
  }
  function u(O) {
    return O === null ? n(O) : Re(O) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), p) : n(O) : Ve(O) ? tt(e, u, "whitespace")(O) : (a += 1, o && (o = !1, i += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), o = !0, u) : (e.enter("data"), f(O)));
  }
  function f(O) {
    return O === null || O === 124 || gt(O) ? (e.exit("data"), u(O)) : (e.consume(O), O === 92 ? d : f);
  }
  function d(O) {
    return O === 92 || O === 124 ? (e.consume(O), f) : f(O);
  }
  function p(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), o = !1, Ve(O) ? tt(e, h, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : h(O));
  }
  function h(O) {
    return O === 45 || O === 58 ? y(O) : O === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), m) : S(O);
  }
  function m(O) {
    return Ve(O) ? tt(e, y, "whitespace")(O) : y(O);
  }
  function y(O) {
    return O === 58 ? (a += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), v) : O === 45 ? (a += 1, v(O)) : O === null || Re(O) ? k(O) : S(O);
  }
  function v(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), g(O)) : S(O);
  }
  function g(O) {
    return O === 45 ? (e.consume(O), g) : O === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), b) : (e.exit("tableDelimiterFiller"), b(O));
  }
  function b(O) {
    return Ve(O) ? tt(e, k, "whitespace")(O) : k(O);
  }
  function k(O) {
    return O === 124 ? h(O) : O === null || Re(O) ? !o || i !== a ? S(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : S(O);
  }
  function S(O) {
    return n(O);
  }
  function _(O) {
    return e.enter("tableRow"), $(O);
  }
  function $(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), $) : O === null || Re(O) ? (e.exit("tableRow"), t(O)) : Ve(O) ? tt(e, $, "whitespace")(O) : (e.enter("data"), j(O));
  }
  function j(O) {
    return O === null || O === 124 || gt(O) ? (e.exit("data"), $(O)) : (e.consume(O), O === 92 ? B : j);
  }
  function B(O) {
    return O === 92 || O === 124 ? (e.consume(O), j) : j(O);
  }
}
function IL(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], o = [0, 0, 0, 0], s = !1, l = 0, c, u, f;
  const d = new $L();
  for (; ++n < e.length; ) {
    const p = e[n], h = p[1];
    p[0] === "enter" ? h.type === "tableHead" ? (s = !1, l !== 0 && (Pb(d, t, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, d.add(n, 0, [["enter", c, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, f = void 0, a = [0, 0, 0, 0], o = [0, n + 1, 0, 0], s && (s = !1, u = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, d.add(n, 0, [["enter", u, t]])), i = h.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (a[1] !== 0 && (o[0] = o[1], f = Ml(d, t, a, i, void 0, f), a = [0, 0, 0, 0]), o[2] = n)) : h.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (o[0] = o[1], f = Ml(d, t, a, i, void 0, f)), a = o, o = [a[1], n, 0, 0])) : h.type === "tableHead" ? (s = !0, l = n) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (o[0] = o[1], f = Ml(d, t, a, i, n, f)) : o[1] !== 0 && (f = Ml(d, t, o, i, n, f)), i = 0) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (o[3] = n);
  }
  for (l !== 0 && Pb(d, t, l, c, u), d.consume(t.events), n = -1; ++n < t.events.length; ) {
    const p = t.events[n];
    p[0] === "enter" && p[1].type === "table" && (p[1]._align = TL(t.events, n));
  }
  return e;
}
function Ml(e, t, n, r, i, a) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Aa(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = Aa(t.events, n[1]);
  if (a = {
    type: o,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = Aa(t.events, n[2]), u = Aa(t.events, n[3]), f = {
      type: s,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const d = t.events[n[2]], p = t.events[n[3]];
      if (d[1].end = Object.assign({}, p[1].end), d[1].type = "chunkText", d[1].contentType = "text", n[3] > n[2] + 1) {
        const h = n[2] + 1, m = n[3] - n[2] - 1;
        e.add(h, m, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Aa(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function Pb(e, t, n, r, i) {
  const a = [], o = Aa(t.events, n);
  i && (i.end = Object.assign({}, o), a.push(["exit", i, t])), r.end = Object.assign({}, o), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Aa(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const AL = {
  name: "tasklistCheck",
  tokenize: jL
};
function PL() {
  return {
    text: {
      91: AL
    }
  };
}
function jL(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return gt(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), o) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), o) : n(l);
  }
  function o(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(l);
  }
  function s(l) {
    return Re(l) ? t(l) : Ve(l) ? e.check({
      tokenize: NL
    }, t, n)(l) : n(l);
  }
}
function NL(e, t, n) {
  return tt(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function DL(e) {
  return GE([
    sL(),
    gL(),
    kL(e),
    CL(),
    PL()
  ]);
}
const ML = {};
function LL(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || ML, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(DL(n)), a.push(rL()), o.push(iL(n));
}
const xt = {
  container: {
    className: "bpReset bpContainer"
  },
  modal: {
    container: {
      className: "bpReset bpModalContainer"
    },
    overlay: {
      className: "bpModalOverlay"
    },
    dialog: {
      container: {
        className: "bpReset bpModalDialogContainer"
      },
      title: {
        container: {
          className: "bpReset bpModalDialogTitleContainer"
        },
        text: {
          className: "bpModalDialogTitleText"
        },
        closeIcon: {
          className: "bpModalDialogTitleCloseIcon"
        }
      },
      content: {
        className: "bpModalDialogContent"
      },
      newConversation: {
        button: {
          className: "bpModalDialogNewConversationButton"
        },
        text: {
          className: "bpModalDialogNewConversationText"
        }
      }
    }
  },
  fab: {
    container: {
      className: "bpReset bpFabContainer"
    },
    icon: {
      className: "bpFabIcon"
    }
  },
  notification: {
    container: {
      className: "bpReset bpNotificationContainer"
    },
    title: {
      className: "bpNotificationTitle"
    },
    description: {
      className: "bpNotificationDescription"
    },
    icon: {
      className: "bpNotificationIcon"
    },
    closeIcon: {
      className: "bpNotificationCloseIcon"
    }
  },
  header: {
    container: {
      className: "bpReset bpHeaderContainer"
    },
    content: {
      container: {
        className: "bpReset bpHeaderContentContainer"
      },
      title: {
        className: "bpHeaderContentTitle"
      },
      description: {
        className: "bpHeaderContentDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpHeaderContentAvatarContainer"
        },
        image: {
          className: "bpHeaderContentAvatarImage"
        },
        fallback: {
          className: "bpHeaderContentAvatarFallback"
        }
      },
      actions: {
        container: {
          className: "bpReset bpHeaderContentActionsContainer"
        },
        icons: {
          className: "bpHeaderContentActionsIcons"
        }
      }
    },
    expandedContent: {
      container: {
        className: "bpReset bpHeaderExpandedContentContainer"
      },
      descriptionItems: {
        container: {
          className: "bpReset bpHeaderExpandedContentDescriptionItemsContainer"
        },
        icon: {
          className: "bpHeaderExpandedContentDescriptionItemsIcon"
        },
        text: {
          className: "bpHeaderExpandedContentDescriptionItemsText"
        },
        link: {
          className: "bpHeaderExpandedContentDescriptionItemsLink"
        }
      },
      group: {
        className: "bpHeaderExpandedContentGroup"
      }
    },
    newConversationIcon: {
      className: "bpHeaderNewConversationIcon"
    }
  },
  composer: {
    container: {
      className: "bpReset bpComposerContainer"
    },
    poweredBy: {
      className: "bpComposerPoweredBy"
    },
    input: {
      className: "bpComposerInput"
    },
    button: {
      container: {
        className: "bpReset bpComposerButtonContainer"
      },
      icon: {
        className: "bpComposerButtonIcon"
      }
    },
    uploadButton: {
      icon: {
        className: "bpComposerUploadButtonIcon"
      },
      container: {
        className: "bpReset bpComposerUploadButtonContainer"
      }
    },
    voiceButton: {
      icon: {
        className: "bpComposerVoiceButtonIcon"
      },
      container: {
        className: "bpReset bpComposerVoiceButtonContainer"
      }
    }
  },
  messageList: {
    scrollDownButton: {
      container: {
        className: "bpReset bpMessageListScrollDownButtonContainer"
      },
      button: {
        className: "bpMessageListScrollDownButtonButton"
      },
      icon: {
        className: "bpMessageListScrollDownButtonIcon"
      }
    },
    container: {
      className: "bpReset bpMessageListContainer"
    },
    viewPort: {
      className: "bpMessageListViewport"
    },
    marquee: {
      container: {
        className: "bpReset bpMessageListMarqueeContainer"
      },
      content: {
        className: "bpMessageListMarqueeContent"
      },
      title: {
        className: "bpMessageListMarqueeTitle"
      },
      description: {
        className: "bpMessageListMarqueeDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpMessageListMarqueeAvatarContainer"
        },
        image: {
          className: "bpMessageListMarqueeAvatarImage"
        },
        fallback: {
          className: "bpMessageListMarqueeAvatarFallback"
        }
      }
    },
    headerMessage: {
      className: "bpMessageListHeaderMessage"
    }
  },
  message: {
    container: {
      className: "bpReset bpMessageContainer"
    },
    avatar: {
      container: {
        className: "bpReset bpMessageAvatarContainer"
      },
      image: {
        className: "bpMessageAvatarImage"
      },
      fallback: {
        className: "bpMessageAvatarFallback"
      }
    },
    blocks: {
      text: {
        heading1: {
          className: "bpMessageBlocksTextHeading1"
        },
        heading2: {
          className: "bpMessageBlocksTextHeading2"
        },
        heading3: {
          className: "bpMessageBlocksTextHeading3"
        },
        unorderedList: {
          className: "bpMessageBlocksTextUnorderedList"
        },
        orderedList: {
          className: "bpMessageBlocksTextOrderedList"
        },
        link: {
          className: "bpMessageBlocksTextLink"
        },
        italic: {
          className: "bpMessageBlocksTextItalic"
        },
        bold: {
          className: "bpMessageBlocksTextBold"
        },
        text: {
          className: "bpMessageBlocksTextText"
        },
        horizontalRule: {
          className: "bpMessageBlocksTextHorizontalRule"
        },
        listItem: {
          className: "bpMessageBlocksTextListItem"
        },
        lineBreak: {
          className: "bpMessageBlocksTextLineBreak"
        },
        pre: {
          className: "bpMessageBlocksTextPre"
        }
      },
      audio: {
        className: "bpMessageBlocksAudio"
      },
      image: {
        image: {
          className: "bpMessageBlocksImageImage"
        },
        placeholder: {
          className: "bpMessageBlocksImagePlaceholder"
        }
      },
      video: {
        className: "bpMessageBlocksVideo"
      },
      location: {
        container: {
          className: "bpMessageBlocksLocationContainer"
        },
        title: {
          className: "bpMessageBlocksLocationTitle"
        },
        icon: {
          className: "bpMessageBlocksLocationIcon"
        }
      },
      file: {
        container: {
          className: "bpMessageBlocksFileContainer"
        },
        title: {
          className: "bpMessageBlocksFileTitle"
        },
        icon: {
          className: "bpMessageBlocksFileIcon"
        }
      },
      row: {
        className: "bpMessageBlocksRow"
      },
      column: {
        className: "bpMessageBlocksColumn"
      },
      bubble: {
        className: "bpMessageBlocksBubble"
      },
      carousel: {
        container: {
          className: "bpMessageBlocksCarouselContainer"
        },
        slidesContainer: {
          className: "bpMessageBlocksCarouselSlidesContainer"
        },
        backButton: {
          className: "bpMessageBlocksCarouselBackButton"
        },
        nextButton: {
          className: "bpMessageBlocksCarouselNextButton"
        }
      },
      dropdown: {
        button: {
          container: {
            className: "bpMessageBlocksDropdownButtonContainer"
          },
          text: {
            className: "bpMessageBlocksDropdownButtonText"
          },
          icon: {
            className: "bpMessageBlocksDropdownButtonIcon"
          }
        },
        content: {
          container: {
            className: "bpMessageBlocksDropdownContentContainer"
          },
          item: {
            className: "bpMessageBlocksDropdownContentItem"
          }
        }
      },
      button: {
        className: "bpMessageBlocksButton"
      }
    }
  },
  typingIndicator: {
    container: {
      className: "bpTypingIndicatorContainer"
    },
    loader: {
      className: "bpTypingIndicatorLoader"
    }
  }
}, FL = ({ text: e }) => {
  const {
    message: {
      blocks: { text: t }
    }
  } = xt, n = {
    h1: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("h1", { ...i, ...t == null ? void 0 : t.heading1 }),
    h2: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("h2", { ...i, ...t == null ? void 0 : t.heading2 }),
    h3: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("h3", { ...i, ...t == null ? void 0 : t.heading3 }),
    h4: "h3",
    h5: "h3",
    h6: "h3",
    em: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("em", { ...i, ...t == null ? void 0 : t.italic }),
    strong: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("strong", { ...i, ...t == null ? void 0 : t.bold }),
    p: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("p", { ...i, ...t == null ? void 0 : t.text }),
    hr: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("hr", { ...i, ...t == null ? void 0 : t.horizontalRule }),
    a: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("a", { ...i, ...t == null ? void 0 : t.link, target: "_blank" }),
    ol: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("ol", { ...i, ...t == null ? void 0 : t.orderedList }),
    ul: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("ul", { ...i, ...t == null ? void 0 : t.unorderedList }),
    li: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("li", { ...i, ...t == null ? void 0 : t.listItem }),
    br: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("br", { ...i, ...t == null ? void 0 : t.lineBreak }),
    pre: ({ node: r, ...i }) => /* @__PURE__ */ C.jsx("pre", { ...i, ...t == null ? void 0 : t.pre })
  };
  return /* @__PURE__ */ C.jsx(kM, { components: n, remarkPlugins: [LL, PM], children: e });
};
function B_(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: z_ } = Object.prototype, { getPrototypeOf: vv } = Object, gv = /* @__PURE__ */ ((e) => (t) => {
  const n = z_.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ri = (e) => (e = e.toLowerCase(), (t) => gv(t) === e), af = (e) => (t) => typeof t === e, { isArray: yo } = Array, ks = af("undefined");
function BL(e) {
  return e !== null && !ks(e) && e.constructor !== null && !ks(e.constructor) && ra(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const U_ = ri("ArrayBuffer");
function zL(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && U_(e.buffer), t;
}
const UL = af("string"), ra = af("function"), q_ = af("number"), yv = (e) => e !== null && typeof e == "object", qL = (e) => e === !0 || e === !1, vc = (e) => {
  if (gv(e) !== "object")
    return !1;
  const t = vv(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, WL = ri("Date"), HL = ri("File"), VL = ri("Blob"), ZL = ri("FileList"), KL = (e) => yv(e) && ra(e.pipe), GL = (e) => {
  const t = "[object FormData]";
  return e && (typeof FormData == "function" && e instanceof FormData || z_.call(e) === t || ra(e.toString) && e.toString() === t);
}, YL = ri("URLSearchParams"), JL = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function il(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), yo(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length;
    let s;
    for (r = 0; r < o; r++)
      s = a[r], t.call(null, e[s], s, e);
  }
}
function W_(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const H_ = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, V_ = (e) => !ks(e) && e !== H_;
function kh() {
  const { caseless: e } = V_(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && W_(t, i) || i;
    vc(t[a]) && vc(r) ? t[a] = kh(t[a], r) : vc(r) ? t[a] = kh({}, r) : yo(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && il(arguments[r], n);
  return t;
}
const XL = (e, t, n, { allOwnKeys: r } = {}) => (il(t, (i, a) => {
  n && ra(i) ? e[a] = B_(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), QL = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), eF = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, tF = (e, t, n, r) => {
  let i, a, o;
  const s = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      o = i[a], (!r || r(o, e, t)) && !s[o] && (t[o] = e[o], s[o] = !0);
    e = n !== !1 && vv(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, nF = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, rF = (e) => {
  if (!e) return null;
  if (yo(e)) return e;
  let t = e.length;
  if (!q_(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, iF = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && vv(Uint8Array)), aF = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, oF = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, sF = ri("HTMLFormElement"), lF = (e) => e.toLowerCase().replace(
  /[_-\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), jb = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), cF = ri("RegExp"), Z_ = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  il(n, (i, a) => {
    t(i, a, e) !== !1 && (r[a] = i);
  }), Object.defineProperties(e, r);
}, uF = (e) => {
  Z_(e, (t, n) => {
    if (ra(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (ra(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, fF = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return yo(e) ? r(e) : r(String(e).split(t)), n;
}, dF = () => {
}, pF = (e, t) => (e = +e, Number.isFinite(e) ? e : t), hF = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (yv(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = yo(r) ? [] : {};
        return il(r, (o, s) => {
          const l = n(o, i + 1);
          !ks(l) && (a[s] = l);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, K = {
  isArray: yo,
  isArrayBuffer: U_,
  isBuffer: BL,
  isFormData: GL,
  isArrayBufferView: zL,
  isString: UL,
  isNumber: q_,
  isBoolean: qL,
  isObject: yv,
  isPlainObject: vc,
  isUndefined: ks,
  isDate: WL,
  isFile: HL,
  isBlob: VL,
  isRegExp: cF,
  isFunction: ra,
  isStream: KL,
  isURLSearchParams: YL,
  isTypedArray: iF,
  isFileList: ZL,
  forEach: il,
  merge: kh,
  extend: XL,
  trim: JL,
  stripBOM: QL,
  inherits: eF,
  toFlatObject: tF,
  kindOf: gv,
  kindOfTest: ri,
  endsWith: nF,
  toArray: rF,
  forEachEntry: aF,
  matchAll: oF,
  isHTMLForm: sF,
  hasOwnProperty: jb,
  hasOwnProp: jb,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Z_,
  freezeMethods: uF,
  toObjectSet: fF,
  toCamelCase: lF,
  noop: dF,
  toFiniteNumber: pF,
  findKey: W_,
  global: H_,
  isContextDefined: V_,
  toJSONObject: hF
};
function rt(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
K.inherits(rt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: K.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const K_ = rt.prototype, G_ = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  G_[e] = { value: e };
});
Object.defineProperties(rt, G_);
Object.defineProperty(K_, "isAxiosError", { value: !0 });
rt.from = (e, t, n, r, i, a) => {
  const o = Object.create(K_);
  return K.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (s) => s !== "isAxiosError"), rt.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, a && Object.assign(o, a), o;
};
var mF = typeof self == "object" ? self.FormData : window.FormData;
const vF = /* @__PURE__ */ Ze(mF);
function $h(e) {
  return K.isPlainObject(e) || K.isArray(e);
}
function Y_(e) {
  return K.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Nb(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = Y_(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function gF(e) {
  return K.isArray(e) && !e.some($h);
}
const yF = K.toFlatObject(K, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function bF(e) {
  return e && K.isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator];
}
function of(e, t, n) {
  if (!K.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (vF || FormData)(), n = K.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !K.isUndefined(y[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, a = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && bF(t);
  if (!K.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null) return "";
    if (K.isDate(h))
      return h.toISOString();
    if (!l && K.isBlob(h))
      throw new rt("Blob is not supported. Use a Buffer instead.");
    return K.isArrayBuffer(h) || K.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, m, y) {
    let v = h;
    if (h && !y && typeof h == "object") {
      if (K.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), h = JSON.stringify(h);
      else if (K.isArray(h) && gF(h) || K.isFileList(h) || K.endsWith(m, "[]") && (v = K.toArray(h)))
        return m = Y_(m), v.forEach(function(b, k) {
          !(K.isUndefined(b) || b === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Nb([m], k, a) : o === null ? m : m + "[]",
            c(b)
          );
        }), !1;
    }
    return $h(h) ? !0 : (t.append(Nb(y, m, a), c(h)), !1);
  }
  const f = [], d = Object.assign(yF, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: $h
  });
  function p(h, m) {
    if (!K.isUndefined(h)) {
      if (f.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      f.push(h), K.forEach(h, function(v, g) {
        (!(K.isUndefined(v) || v === null) && i.call(
          t,
          v,
          K.isString(g) ? g.trim() : g,
          m,
          d
        )) === !0 && p(v, m ? m.concat(g) : [g]);
      }), f.pop();
    }
  }
  if (!K.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function Db(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function bv(e, t) {
  this._pairs = [], e && of(e, this, t);
}
const J_ = bv.prototype;
J_.append = function(t, n) {
  this._pairs.push([t, n]);
};
J_.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, Db);
  } : Db;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function xF(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function X_(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || xF, i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = K.isURLSearchParams(t) ? t.toString() : new bv(t, n).toString(r), a) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class Mb {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    K.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const Q_ = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, wF = typeof URLSearchParams < "u" ? URLSearchParams : bv, SF = FormData, EF = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), _F = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Or = {
  isBrowser: !0,
  classes: {
    URLSearchParams: wF,
    FormData: SF,
    Blob
  },
  isStandardBrowserEnv: EF,
  isStandardBrowserWebWorkerEnv: _F,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function kF(e, t) {
  return of(e, new Or.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return Or.isNode && K.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function $F(e) {
  return K.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function OF(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function ek(e) {
  function t(n, r, i, a) {
    let o = n[a++];
    const s = Number.isFinite(+o), l = a >= n.length;
    return o = !o && K.isArray(i) ? i.length : o, l ? (K.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !s) : ((!i[o] || !K.isObject(i[o])) && (i[o] = []), t(n, r, i[o], a) && K.isArray(i[o]) && (i[o] = OF(i[o])), !s);
  }
  if (K.isFormData(e) && K.isFunction(e.entries)) {
    const n = {};
    return K.forEachEntry(e, (r, i) => {
      t($F(r), i, n, 0);
    }), n;
  }
  return null;
}
const TF = {
  "Content-Type": void 0
};
function CF(e, t, n) {
  if (K.isString(e))
    try {
      return (t || JSON.parse)(e), K.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const bo = {
  transitional: Q_,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = K.isObject(t);
    if (a && K.isHTMLForm(t) && (t = new FormData(t)), K.isFormData(t))
      return i && i ? JSON.stringify(ek(t)) : t;
    if (K.isArrayBuffer(t) || K.isBuffer(t) || K.isStream(t) || K.isFile(t) || K.isBlob(t))
      return t;
    if (K.isArrayBufferView(t))
      return t.buffer;
    if (K.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return kF(t, this.formSerializer).toString();
      if ((s = K.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return of(
          s ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), CF(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || bo.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && K.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (o)
          throw s.name === "SyntaxError" ? rt.from(s, rt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Or.classes.FormData,
    Blob: Or.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
K.forEach(["delete", "get", "head"], function(t) {
  bo.headers[t] = {};
});
K.forEach(["post", "put", "patch"], function(t) {
  bo.headers[t] = K.merge(TF);
});
const RF = K.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), IF = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && RF[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, Lb = Symbol("internals");
function Do(e) {
  return e && String(e).trim().toLowerCase();
}
function gc(e) {
  return e === !1 || e == null ? e : K.isArray(e) ? e.map(gc) : String(e);
}
function AF(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
function PF(e) {
  return /^[-_a-zA-Z]+$/.test(e.trim());
}
function Fb(e, t, n, r) {
  if (K.isFunction(r))
    return r.call(this, t, n);
  if (K.isString(t)) {
    if (K.isString(r))
      return t.indexOf(r) !== -1;
    if (K.isRegExp(r))
      return r.test(t);
  }
}
function jF(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function NF(e, t) {
  const n = K.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, o) {
        return this[r].call(this, t, i, a, o);
      },
      configurable: !0
    });
  });
}
class Hn {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(s, l, c) {
      const u = Do(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const f = K.findKey(i, u);
      (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = gc(s));
    }
    const o = (s, l) => K.forEach(s, (c, u) => a(c, u, l));
    return K.isPlainObject(t) || t instanceof this.constructor ? o(t, n) : K.isString(t) && (t = t.trim()) && !PF(t) ? o(IF(t), n) : t != null && a(n, t, r), this;
  }
  get(t, n) {
    if (t = Do(t), t) {
      const r = K.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return AF(i);
        if (K.isFunction(n))
          return n.call(this, i, r);
        if (K.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Do(t), t) {
      const r = K.findKey(this, t);
      return !!(r && (!n || Fb(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(o) {
      if (o = Do(o), o) {
        const s = K.findKey(r, o);
        s && (!n || Fb(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return K.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(t) {
    const n = this, r = {};
    return K.forEach(this, (i, a) => {
      const o = K.findKey(r, a);
      if (o) {
        n[o] = gc(i), delete n[a];
        return;
      }
      const s = t ? jF(a) : String(a).trim();
      s !== a && delete n[a], n[s] = gc(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return K.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && K.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[Lb] = this[Lb] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(o) {
      const s = Do(o);
      r[s] || (NF(i, o), r[s] = !0);
    }
    return K.isArray(t) ? t.forEach(a) : a(t), this;
  }
}
Hn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
K.freezeMethods(Hn.prototype);
K.freezeMethods(Hn);
function dd(e, t) {
  const n = this || bo, r = t || n, i = Hn.from(r.headers);
  let a = r.data;
  return K.forEach(e, function(s) {
    a = s.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function tk(e) {
  return !!(e && e.__CANCEL__);
}
function al(e, t, n) {
  rt.call(this, e ?? "canceled", rt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
K.inherits(al, rt, {
  __CANCEL__: !0
});
const DF = null;
function MF(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new rt(
    "Request failed with status code " + n.status,
    [rt.ERR_BAD_REQUEST, rt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const LF = Or.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  /* @__PURE__ */ function() {
    return {
      write: function(n, r, i, a, o, s) {
        const l = [];
        l.push(n + "=" + encodeURIComponent(r)), K.isNumber(i) && l.push("expires=" + new Date(i).toGMTString()), K.isString(a) && l.push("path=" + a), K.isString(o) && l.push("domain=" + o), s === !0 && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(n) {
        const r = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return r ? decodeURIComponent(r[3]) : null;
      },
      remove: function(n) {
        this.write(n, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function FF(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function BF(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function nk(e, t) {
  return e && !FF(t) ? BF(e, t) : t;
}
const zF = Or.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(a) {
      let o = a;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(o) {
      const s = K.isString(o) ? i(o) : o;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function UF(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function qF(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[a];
    o || (o = c), n[i] = l, r[i] = c;
    let f = a, d = 0;
    for (; f !== i; )
      d += n[f++], f = f % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), c - o < t)
      return;
    const p = u && c - u;
    return p ? Math.round(d * 1e3 / p) : void 0;
  };
}
function Bb(e, t) {
  let n = 0;
  const r = qF(50, 250);
  return (i) => {
    const a = i.loaded, o = i.lengthComputable ? i.total : void 0, s = a - n, l = r(s), c = a <= o;
    n = a;
    const u = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: s,
      rate: l || void 0,
      estimated: l && o && c ? (o - a) / l : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const WF = typeof XMLHttpRequest < "u", HF = WF && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const a = Hn.from(e.headers).normalize(), o = e.responseType;
    let s;
    function l() {
      e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s);
    }
    K.isFormData(i) && (Or.isStandardBrowserEnv || Or.isStandardBrowserWebWorkerEnv) && a.setContentType(!1);
    let c = new XMLHttpRequest();
    if (e.auth) {
      const p = e.auth.username || "", h = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      a.set("Authorization", "Basic " + btoa(p + ":" + h));
    }
    const u = nk(e.baseURL, e.url);
    c.open(e.method.toUpperCase(), X_(u, e.params, e.paramsSerializer), !0), c.timeout = e.timeout;
    function f() {
      if (!c)
        return;
      const p = Hn.from(
        "getAllResponseHeaders" in c && c.getAllResponseHeaders()
      ), m = {
        data: !o || o === "text" || o === "json" ? c.responseText : c.response,
        status: c.status,
        statusText: c.statusText,
        headers: p,
        config: e,
        request: c
      };
      MF(function(v) {
        n(v), l();
      }, function(v) {
        r(v), l();
      }, m), c = null;
    }
    if ("onloadend" in c ? c.onloadend = f : c.onreadystatechange = function() {
      !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(f);
    }, c.onabort = function() {
      c && (r(new rt("Request aborted", rt.ECONNABORTED, e, c)), c = null);
    }, c.onerror = function() {
      r(new rt("Network Error", rt.ERR_NETWORK, e, c)), c = null;
    }, c.ontimeout = function() {
      let h = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const m = e.transitional || Q_;
      e.timeoutErrorMessage && (h = e.timeoutErrorMessage), r(new rt(
        h,
        m.clarifyTimeoutError ? rt.ETIMEDOUT : rt.ECONNABORTED,
        e,
        c
      )), c = null;
    }, Or.isStandardBrowserEnv) {
      const p = (e.withCredentials || zF(u)) && e.xsrfCookieName && LF.read(e.xsrfCookieName);
      p && a.set(e.xsrfHeaderName, p);
    }
    i === void 0 && a.setContentType(null), "setRequestHeader" in c && K.forEach(a.toJSON(), function(h, m) {
      c.setRequestHeader(m, h);
    }), K.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), o && o !== "json" && (c.responseType = e.responseType), typeof e.onDownloadProgress == "function" && c.addEventListener("progress", Bb(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", Bb(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = (p) => {
      c && (r(!p || p.type ? new al(null, e, c) : p), c.abort(), c = null);
    }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
    const d = UF(u);
    if (d && Or.protocols.indexOf(d) === -1) {
      r(new rt("Unsupported protocol " + d + ":", rt.ERR_BAD_REQUEST, e));
      return;
    }
    c.send(i || null);
  });
}, yc = {
  http: DF,
  xhr: HF
};
K.forEach(yc, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const VF = {
  getAdapter: (e) => {
    e = K.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    for (let i = 0; i < t && (n = e[i], !(r = K.isString(n) ? yc[n.toLowerCase()] : n)); i++)
      ;
    if (!r)
      throw r === !1 ? new rt(
        `Adapter ${n} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        K.hasOwnProp(yc, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`
      );
    if (!K.isFunction(r))
      throw new TypeError("adapter is not a function");
    return r;
  },
  adapters: yc
};
function pd(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new al(null, e);
}
function zb(e) {
  return pd(e), e.headers = Hn.from(e.headers), e.data = dd.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), VF.getAdapter(e.adapter || bo.adapter)(e).then(function(r) {
    return pd(e), r.data = dd.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Hn.from(r.headers), r;
  }, function(r) {
    return tk(r) || (pd(e), r && r.response && (r.response.data = dd.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Hn.from(r.response.headers))), Promise.reject(r);
  });
}
const Ub = (e) => e instanceof Hn ? e.toJSON() : e;
function Ja(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, f) {
    return K.isPlainObject(c) && K.isPlainObject(u) ? K.merge.call({ caseless: f }, c, u) : K.isPlainObject(u) ? K.merge({}, u) : K.isArray(u) ? u.slice() : u;
  }
  function i(c, u, f) {
    if (K.isUndefined(u)) {
      if (!K.isUndefined(c))
        return r(void 0, c, f);
    } else return r(c, u, f);
  }
  function a(c, u) {
    if (!K.isUndefined(u))
      return r(void 0, u);
  }
  function o(c, u) {
    if (K.isUndefined(u)) {
      if (!K.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, u);
  }
  function s(c, u, f) {
    if (f in t)
      return r(c, u);
    if (f in e)
      return r(void 0, c);
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: s,
    headers: (c, u) => i(Ub(c), Ub(u), !0)
  };
  return K.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const f = l[u] || i, d = f(e[u], t[u], u);
    K.isUndefined(d) && f !== s || (n[u] = d);
  }), n;
}
const rk = "1.2.5", xv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  xv[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const qb = {};
xv.transitional = function(t, n, r) {
  function i(a, o) {
    return "[Axios v" + rk + "] Transitional option '" + a + "'" + o + (r ? ". " + r : "");
  }
  return (a, o, s) => {
    if (t === !1)
      throw new rt(
        i(o, " has been removed" + (n ? " in " + n : "")),
        rt.ERR_DEPRECATED
      );
    return n && !qb[o] && (qb[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, o, s) : !0;
  };
};
function ZF(e, t, n) {
  if (typeof e != "object")
    throw new rt("options must be an object", rt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], o = t[a];
    if (o) {
      const s = e[a], l = s === void 0 || o(s, a, e);
      if (l !== !0)
        throw new rt("option " + a + " must be " + l, rt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new rt("Unknown option " + a, rt.ERR_BAD_OPTION);
  }
}
const Oh = {
  assertOptions: ZF,
  validators: xv
}, ci = Oh.validators;
class Ki {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Mb(),
      response: new Mb()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Ja(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && Oh.assertOptions(r, {
      silentJSONParsing: ci.transitional(ci.boolean),
      forcedJSONParsing: ci.transitional(ci.boolean),
      clarifyTimeoutError: ci.transitional(ci.boolean)
    }, !1), i !== void 0 && Oh.assertOptions(i, {
      encode: ci.function,
      serialize: ci.function
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o;
    o = a && K.merge(
      a.common,
      a[n.method]
    ), o && K.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete a[h];
      }
    ), n.headers = Hn.concat(o, a);
    const s = [];
    let l = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (l = l && m.synchronous, s.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u, f = 0, d;
    if (!l) {
      const h = [zb.bind(this), void 0];
      for (h.unshift.apply(h, s), h.push.apply(h, c), d = h.length, u = Promise.resolve(n); f < d; )
        u = u.then(h[f++], h[f++]);
      return u;
    }
    d = s.length;
    let p = n;
    for (f = 0; f < d; ) {
      const h = s[f++], m = s[f++];
      try {
        p = h(p);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = zb.call(this, p);
    } catch (h) {
      return Promise.reject(h);
    }
    for (f = 0, d = c.length; f < d; )
      u = u.then(c[f++], c[f++]);
    return u;
  }
  getUri(t) {
    t = Ja(this.defaults, t);
    const n = nk(t.baseURL, t.url);
    return X_(n, t.params, t.paramsSerializer);
  }
}
K.forEach(["delete", "get", "head", "options"], function(t) {
  Ki.prototype[t] = function(n, r) {
    return this.request(Ja(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
K.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, o, s) {
      return this.request(Ja(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  Ki.prototype[t] = n(), Ki.prototype[t + "Form"] = n(!0);
});
class wv {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const o = new Promise((s) => {
        r.subscribe(s), a = s;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(a);
      }, o;
    }, t(function(a, o, s) {
      r.reason || (r.reason = new al(a, o, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new wv(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
function KF(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function GF(e) {
  return K.isObject(e) && e.isAxiosError === !0;
}
const Th = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Th).forEach(([e, t]) => {
  Th[t] = e;
});
function ik(e) {
  const t = new Ki(e), n = B_(Ki.prototype.request, t);
  return K.extend(n, Ki.prototype, t, { allOwnKeys: !0 }), K.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return ik(Ja(e, i));
  }, n;
}
const Ft = ik(bo);
Ft.Axios = Ki;
Ft.CanceledError = al;
Ft.CancelToken = wv;
Ft.isCancel = tk;
Ft.VERSION = rk;
Ft.toFormData = of;
Ft.AxiosError = rt;
Ft.Cancel = Ft.CanceledError;
Ft.all = function(t) {
  return Promise.all(t);
};
Ft.spread = KF;
Ft.isAxiosError = GF;
Ft.mergeConfig = Ja;
Ft.AxiosHeaders = Hn;
Ft.formToJSON = (e) => ek(K.isHTMLForm(e) ? new FormData(e) : e);
Ft.HttpStatusCode = Th;
Ft.default = Ft;
const ak = {}, YF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ak
}, Symbol.toStringTag, { value: "Module" }));
var JF = Error, XF = EvalError, QF = RangeError, e5 = ReferenceError, ok = SyntaxError, Di = TypeError, t5 = URIError, sf = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[n] = i;
  for (n in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var a = Object.getOwnPropertySymbols(t);
  if (a.length !== 1 || a[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(t, n);
    if (o.value !== i || o.enumerable !== !0)
      return !1;
  }
  return !0;
}, Wb = typeof Symbol < "u" && Symbol, n5 = sf, Sv = function() {
  return typeof Wb != "function" || typeof Symbol != "function" || typeof Wb("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : n5();
}, hd = {
  __proto__: null,
  foo: {}
}, r5 = Object, i5 = function() {
  return { __proto__: hd }.foo === hd.foo && !(hd instanceof r5);
}, a5 = "Function.prototype.bind called on incompatible ", o5 = Object.prototype.toString, s5 = Math.max, l5 = "[object Function]", Hb = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var a = 0; a < n.length; a += 1)
    r[a + t.length] = n[a];
  return r;
}, c5 = function(t, n) {
  for (var r = [], i = n, a = 0; i < t.length; i += 1, a += 1)
    r[a] = t[i];
  return r;
}, u5 = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, f5 = function(t) {
  var n = this;
  if (typeof n != "function" || o5.apply(n) !== l5)
    throw new TypeError(a5 + n);
  for (var r = c5(arguments, 1), i, a = function() {
    if (this instanceof i) {
      var u = n.apply(
        this,
        Hb(r, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return n.apply(
      t,
      Hb(r, arguments)
    );
  }, o = s5(0, n.length - r.length), s = [], l = 0; l < o; l++)
    s[l] = "$" + l;
  if (i = Function("binder", "return function (" + u5(s, ",") + "){ return binder.apply(this,arguments); }")(a), n.prototype) {
    var c = function() {
    };
    c.prototype = n.prototype, i.prototype = new c(), c.prototype = null;
  }
  return i;
}, d5 = f5, Ev = Function.prototype.bind || d5, p5 = Function.prototype.call, h5 = Object.prototype.hasOwnProperty, m5 = Ev, sk = m5.call(p5, h5), Ge, v5 = JF, g5 = XF, y5 = QF, b5 = e5, Xa = ok, za = Di, x5 = t5, lk = Function, md = function(e) {
  try {
    return lk('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Gi = Object.getOwnPropertyDescriptor;
if (Gi)
  try {
    Gi({}, "");
  } catch {
    Gi = null;
  }
var vd = function() {
  throw new za();
}, w5 = Gi ? function() {
  try {
    return arguments.callee, vd;
  } catch {
    try {
      return Gi(arguments, "callee").get;
    } catch {
      return vd;
    }
  }
}() : vd, xa = Sv(), S5 = i5(), Gt = Object.getPrototypeOf || (S5 ? function(e) {
  return e.__proto__;
} : null), Pa = {}, E5 = typeof Uint8Array > "u" || !Gt ? Ge : Gt(Uint8Array), Yi = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Ge : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ge : ArrayBuffer,
  "%ArrayIteratorPrototype%": xa && Gt ? Gt([][Symbol.iterator]()) : Ge,
  "%AsyncFromSyncIteratorPrototype%": Ge,
  "%AsyncFunction%": Pa,
  "%AsyncGenerator%": Pa,
  "%AsyncGeneratorFunction%": Pa,
  "%AsyncIteratorPrototype%": Pa,
  "%Atomics%": typeof Atomics > "u" ? Ge : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Ge : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Ge : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Ge : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Ge : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": v5,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": g5,
  "%Float32Array%": typeof Float32Array > "u" ? Ge : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Ge : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ge : FinalizationRegistry,
  "%Function%": lk,
  "%GeneratorFunction%": Pa,
  "%Int8Array%": typeof Int8Array > "u" ? Ge : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Ge : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Ge : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": xa && Gt ? Gt(Gt([][Symbol.iterator]())) : Ge,
  "%JSON%": typeof JSON == "object" ? JSON : Ge,
  "%Map%": typeof Map > "u" ? Ge : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !xa || !Gt ? Ge : Gt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Ge : Promise,
  "%Proxy%": typeof Proxy > "u" ? Ge : Proxy,
  "%RangeError%": y5,
  "%ReferenceError%": b5,
  "%Reflect%": typeof Reflect > "u" ? Ge : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Ge : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !xa || !Gt ? Ge : Gt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ge : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": xa && Gt ? Gt(""[Symbol.iterator]()) : Ge,
  "%Symbol%": xa ? Symbol : Ge,
  "%SyntaxError%": Xa,
  "%ThrowTypeError%": w5,
  "%TypedArray%": E5,
  "%TypeError%": za,
  "%Uint8Array%": typeof Uint8Array > "u" ? Ge : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ge : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Ge : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Ge : Uint32Array,
  "%URIError%": x5,
  "%WeakMap%": typeof WeakMap > "u" ? Ge : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Ge : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Ge : WeakSet
};
if (Gt)
  try {
    null.error;
  } catch (e) {
    var _5 = Gt(Gt(e));
    Yi["%Error.prototype%"] = _5;
  }
var k5 = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = md("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = md("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = md("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && Gt && (n = Gt(i.prototype));
  }
  return Yi[t] = n, n;
}, Vb = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, ol = Ev, ou = sk, $5 = ol.call(Function.call, Array.prototype.concat), O5 = ol.call(Function.apply, Array.prototype.splice), Zb = ol.call(Function.call, String.prototype.replace), su = ol.call(Function.call, String.prototype.slice), T5 = ol.call(Function.call, RegExp.prototype.exec), C5 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, R5 = /\\(\\)?/g, I5 = function(t) {
  var n = su(t, 0, 1), r = su(t, -1);
  if (n === "%" && r !== "%")
    throw new Xa("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new Xa("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return Zb(t, C5, function(a, o, s, l) {
    i[i.length] = s ? Zb(l, R5, "$1") : o || a;
  }), i;
}, A5 = function(t, n) {
  var r = t, i;
  if (ou(Vb, r) && (i = Vb[r], r = "%" + i[0] + "%"), ou(Yi, r)) {
    var a = Yi[r];
    if (a === Pa && (a = k5(r)), typeof a > "u" && !n)
      throw new za("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: a
    };
  }
  throw new Xa("intrinsic " + t + " does not exist!");
}, Nr = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new za("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new za('"allowMissing" argument must be a boolean');
  if (T5(/^%?[^%]*%?$/, t) === null)
    throw new Xa("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = I5(t), i = r.length > 0 ? r[0] : "", a = A5("%" + i + "%", n), o = a.name, s = a.value, l = !1, c = a.alias;
  c && (i = c[0], O5(r, $5([0, 1], c)));
  for (var u = 1, f = !0; u < r.length; u += 1) {
    var d = r[u], p = su(d, 0, 1), h = su(d, -1);
    if ((p === '"' || p === "'" || p === "`" || h === '"' || h === "'" || h === "`") && p !== h)
      throw new Xa("property names with quotes must have matching quotes");
    if ((d === "constructor" || !f) && (l = !0), i += "." + d, o = "%" + i + "%", ou(Yi, o))
      s = Yi[o];
    else if (s != null) {
      if (!(d in s)) {
        if (!n)
          throw new za("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Gi && u + 1 >= r.length) {
        var m = Gi(s, d);
        f = !!m, f && "get" in m && !("originalValue" in m.get) ? s = m.get : s = s[d];
      } else
        f = ou(s, d), s = s[d];
      f && !l && (Yi[o] = s);
    }
  }
  return s;
}, ck = { exports: {} }, gd, Kb;
function _v() {
  if (Kb) return gd;
  Kb = 1;
  var e = Nr, t = e("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return gd = t, gd;
}
var P5 = Nr, bc = P5("%Object.getOwnPropertyDescriptor%", !0);
if (bc)
  try {
    bc([], "length");
  } catch {
    bc = null;
  }
var kv = bc, Gb = _v(), j5 = ok, wa = Di, Yb = kv, $v = function(t, n, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new wa("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new wa("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new wa("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new wa("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new wa("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new wa("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, a = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : !1, l = !!Yb && Yb(t, n);
  if (Gb)
    Gb(t, n, {
      configurable: o === null && l ? l.configurable : !o,
      enumerable: i === null && l ? l.enumerable : !i,
      value: r,
      writable: a === null && l ? l.writable : !a
    });
  else if (s || !i && !a && !o)
    t[n] = r;
  else
    throw new j5("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Ch = _v(), uk = function() {
  return !!Ch;
};
uk.hasArrayLengthDefineBug = function() {
  if (!Ch)
    return null;
  try {
    return Ch([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var Ov = uk, N5 = Nr, Jb = $v, D5 = Ov(), Xb = kv, Qb = Di, M5 = N5("%Math.floor%"), L5 = function(t, n) {
  if (typeof t != "function")
    throw new Qb("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || M5(n) !== n)
    throw new Qb("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, a = !0;
  if ("length" in t && Xb) {
    var o = Xb(t, "length");
    o && !o.configurable && (i = !1), o && !o.writable && (a = !1);
  }
  return (i || a || !r) && (D5 ? Jb(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n,
    !0,
    !0
  ) : Jb(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n
  )), t;
};
(function(e) {
  var t = Ev, n = Nr, r = L5, i = Di, a = n("%Function.prototype.apply%"), o = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || t.call(o, a), l = _v(), c = n("%Math.max%");
  e.exports = function(d) {
    if (typeof d != "function")
      throw new i("a function is required");
    var p = s(t, o, arguments);
    return r(
      p,
      1 + c(0, d.length - (arguments.length - 1)),
      !0
    );
  };
  var u = function() {
    return s(t, a, arguments);
  };
  l ? l(e.exports, "apply", { value: u }) : e.exports.apply = u;
})(ck);
var xo = ck.exports, fk = Nr, dk = xo, F5 = dk(fk("String.prototype.indexOf")), Kn = function(t, n) {
  var r = fk(t, !!n);
  return typeof r == "function" && F5(t, ".prototype.") > -1 ? dk(r) : r;
};
const B5 = /* @__PURE__ */ oI(YF);
var Tv = typeof Map == "function" && Map.prototype, yd = Object.getOwnPropertyDescriptor && Tv ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, lu = Tv && yd && typeof yd.get == "function" ? yd.get : null, ex = Tv && Map.prototype.forEach, Cv = typeof Set == "function" && Set.prototype, bd = Object.getOwnPropertyDescriptor && Cv ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, cu = Cv && bd && typeof bd.get == "function" ? bd.get : null, tx = Cv && Set.prototype.forEach, z5 = typeof WeakMap == "function" && WeakMap.prototype, ns = z5 ? WeakMap.prototype.has : null, U5 = typeof WeakSet == "function" && WeakSet.prototype, rs = U5 ? WeakSet.prototype.has : null, q5 = typeof WeakRef == "function" && WeakRef.prototype, nx = q5 ? WeakRef.prototype.deref : null, W5 = Boolean.prototype.valueOf, H5 = Object.prototype.toString, V5 = Function.prototype.toString, Z5 = String.prototype.match, Rv = String.prototype.slice, gi = String.prototype.replace, K5 = String.prototype.toUpperCase, rx = String.prototype.toLowerCase, pk = RegExp.prototype.test, ix = Array.prototype.concat, kr = Array.prototype.join, G5 = Array.prototype.slice, ax = Math.floor, Rh = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, xd = Object.getOwnPropertySymbols, Ih = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Qa = typeof Symbol == "function" && typeof Symbol.iterator == "object", sn = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Qa || !0) ? Symbol.toStringTag : null, hk = Object.prototype.propertyIsEnumerable, ox = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
  return e.__proto__;
} : null);
function sx(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || pk.call(/e/, t))
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -ax(-e) : ax(e);
    if (r !== e) {
      var i = String(r), a = Rv.call(t, i.length + 1);
      return gi.call(i, n, "$&_") + "." + gi.call(gi.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return gi.call(t, n, "$&_");
}
var Ah = B5, lx = Ah.custom, cx = vk(lx) ? lx : null, Y5 = function e(t, n, r, i) {
  var a = n || {};
  if (di(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (di(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var o = di(a, "customInspect") ? a.customInspect : !0;
  if (typeof o != "boolean" && o !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (di(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (di(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = a.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return yk(t, a);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var l = String(t);
    return s ? sx(t, l) : l;
  }
  if (typeof t == "bigint") {
    var c = String(t) + "n";
    return s ? sx(t, c) : c;
  }
  var u = typeof a.depth > "u" ? 5 : a.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof t == "object")
    return Ph(t) ? "[Array]" : "[Object]";
  var f = h3(a, r);
  if (typeof i > "u")
    i = [];
  else if (gk(i, t) >= 0)
    return "[Circular]";
  function d(M, z, D) {
    if (z && (i = G5.call(i), i.push(z)), D) {
      var R = {
        depth: a.depth
      };
      return di(a, "quoteStyle") && (R.quoteStyle = a.quoteStyle), e(M, R, r + 1, i);
    }
    return e(M, a, r + 1, i);
  }
  if (typeof t == "function" && !ux(t)) {
    var p = a3(t), h = Ll(t, d);
    return "[Function" + (p ? ": " + p : " (anonymous)") + "]" + (h.length > 0 ? " { " + kr.call(h, ", ") + " }" : "");
  }
  if (vk(t)) {
    var m = Qa ? gi.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Ih.call(t);
    return typeof t == "object" && !Qa ? Mo(m) : m;
  }
  if (f3(t)) {
    for (var y = "<" + rx.call(String(t.nodeName)), v = t.attributes || [], g = 0; g < v.length; g++)
      y += " " + v[g].name + "=" + mk(J5(v[g].value), "double", a);
    return y += ">", t.childNodes && t.childNodes.length && (y += "..."), y += "</" + rx.call(String(t.nodeName)) + ">", y;
  }
  if (Ph(t)) {
    if (t.length === 0)
      return "[]";
    var b = Ll(t, d);
    return f && !p3(b) ? "[" + jh(b, f) + "]" : "[ " + kr.call(b, ", ") + " ]";
  }
  if (Q5(t)) {
    var k = Ll(t, d);
    return !("cause" in Error.prototype) && "cause" in t && !hk.call(t, "cause") ? "{ [" + String(t) + "] " + kr.call(ix.call("[cause]: " + d(t.cause), k), ", ") + " }" : k.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + kr.call(k, ", ") + " }";
  }
  if (typeof t == "object" && o) {
    if (cx && typeof t[cx] == "function" && Ah)
      return Ah(t, { depth: u - r });
    if (o !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (o3(t)) {
    var S = [];
    return ex && ex.call(t, function(M, z) {
      S.push(d(z, t, !0) + " => " + d(M, t));
    }), fx("Map", lu.call(t), S, f);
  }
  if (c3(t)) {
    var _ = [];
    return tx && tx.call(t, function(M) {
      _.push(d(M, t));
    }), fx("Set", cu.call(t), _, f);
  }
  if (s3(t))
    return wd("WeakMap");
  if (u3(t))
    return wd("WeakSet");
  if (l3(t))
    return wd("WeakRef");
  if (t3(t))
    return Mo(d(Number(t)));
  if (r3(t))
    return Mo(d(Rh.call(t)));
  if (n3(t))
    return Mo(W5.call(t));
  if (e3(t))
    return Mo(d(String(t)));
  if (typeof window < "u" && t === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && t === globalThis || typeof ft < "u" && t === ft)
    return "{ [object globalThis] }";
  if (!X5(t) && !ux(t)) {
    var $ = Ll(t, d), j = ox ? ox(t) === Object.prototype : t instanceof Object || t.constructor === Object, B = t instanceof Object ? "" : "null prototype", O = !j && sn && Object(t) === t && sn in t ? Rv.call(Mi(t), 8, -1) : B ? "Object" : "", N = j || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", q = N + (O || B ? "[" + kr.call(ix.call([], O || [], B || []), ": ") + "] " : "");
    return $.length === 0 ? q + "{}" : f ? q + "{" + jh($, f) + "}" : q + "{ " + kr.call($, ", ") + " }";
  }
  return String(t);
};
function mk(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function J5(e) {
  return gi.call(String(e), /"/g, "&quot;");
}
function Ph(e) {
  return Mi(e) === "[object Array]" && (!sn || !(typeof e == "object" && sn in e));
}
function X5(e) {
  return Mi(e) === "[object Date]" && (!sn || !(typeof e == "object" && sn in e));
}
function ux(e) {
  return Mi(e) === "[object RegExp]" && (!sn || !(typeof e == "object" && sn in e));
}
function Q5(e) {
  return Mi(e) === "[object Error]" && (!sn || !(typeof e == "object" && sn in e));
}
function e3(e) {
  return Mi(e) === "[object String]" && (!sn || !(typeof e == "object" && sn in e));
}
function t3(e) {
  return Mi(e) === "[object Number]" && (!sn || !(typeof e == "object" && sn in e));
}
function n3(e) {
  return Mi(e) === "[object Boolean]" && (!sn || !(typeof e == "object" && sn in e));
}
function vk(e) {
  if (Qa)
    return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol")
    return !0;
  if (!e || typeof e != "object" || !Ih)
    return !1;
  try {
    return Ih.call(e), !0;
  } catch {
  }
  return !1;
}
function r3(e) {
  if (!e || typeof e != "object" || !Rh)
    return !1;
  try {
    return Rh.call(e), !0;
  } catch {
  }
  return !1;
}
var i3 = Object.prototype.hasOwnProperty || function(e) {
  return e in this;
};
function di(e, t) {
  return i3.call(e, t);
}
function Mi(e) {
  return H5.call(e);
}
function a3(e) {
  if (e.name)
    return e.name;
  var t = Z5.call(V5.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function gk(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++)
    if (e[n] === t)
      return n;
  return -1;
}
function o3(e) {
  if (!lu || !e || typeof e != "object")
    return !1;
  try {
    lu.call(e);
    try {
      cu.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {
  }
  return !1;
}
function s3(e) {
  if (!ns || !e || typeof e != "object")
    return !1;
  try {
    ns.call(e, ns);
    try {
      rs.call(e, rs);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {
  }
  return !1;
}
function l3(e) {
  if (!nx || !e || typeof e != "object")
    return !1;
  try {
    return nx.call(e), !0;
  } catch {
  }
  return !1;
}
function c3(e) {
  if (!cu || !e || typeof e != "object")
    return !1;
  try {
    cu.call(e);
    try {
      lu.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {
  }
  return !1;
}
function u3(e) {
  if (!rs || !e || typeof e != "object")
    return !1;
  try {
    rs.call(e, rs);
    try {
      ns.call(e, ns);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {
  }
  return !1;
}
function f3(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function yk(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return yk(Rv.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = gi.call(gi.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, d3);
  return mk(i, "single", t);
}
function d3(e) {
  var t = e.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + K5.call(t.toString(16));
}
function Mo(e) {
  return "Object(" + e + ")";
}
function wd(e) {
  return e + " { ? }";
}
function fx(e, t, n, r) {
  var i = r ? jh(n, r) : kr.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function p3(e) {
  for (var t = 0; t < e.length; t++)
    if (gk(e[t], `
`) >= 0)
      return !1;
  return !0;
}
function h3(e, t) {
  var n;
  if (e.indent === "	")
    n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = kr.call(Array(e.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: kr.call(Array(t + 1), n)
  };
}
function jh(e, t) {
  if (e.length === 0)
    return "";
  var n = `
` + t.prev + t.base;
  return n + kr.call(e, "," + n) + `
` + t.prev;
}
function Ll(e, t) {
  var n = Ph(e), r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++)
      r[i] = di(e, i) ? t(e[i], e) : "";
  }
  var a = typeof xd == "function" ? xd(e) : [], o;
  if (Qa) {
    o = {};
    for (var s = 0; s < a.length; s++)
      o["$" + a[s]] = a[s];
  }
  for (var l in e)
    di(e, l) && (n && String(Number(l)) === l && l < e.length || Qa && o["$" + l] instanceof Symbol || (pk.call(/[^\w$]/, l) ? r.push(t(l, e) + ": " + t(e[l], e)) : r.push(l + ": " + t(e[l], e))));
  if (typeof xd == "function")
    for (var c = 0; c < a.length; c++)
      hk.call(e, a[c]) && r.push("[" + t(a[c]) + "]: " + t(e[a[c]], e));
  return r;
}
var bk = Nr, wo = Kn, m3 = Y5, v3 = Di, Fl = bk("%WeakMap%", !0), Bl = bk("%Map%", !0), g3 = wo("WeakMap.prototype.get", !0), y3 = wo("WeakMap.prototype.set", !0), b3 = wo("WeakMap.prototype.has", !0), x3 = wo("Map.prototype.get", !0), w3 = wo("Map.prototype.set", !0), S3 = wo("Map.prototype.has", !0), Iv = function(e, t) {
  for (var n = e, r; (r = n.next) !== null; n = r)
    if (r.key === t)
      return n.next = r.next, r.next = /** @type {NonNullable<typeof list.next>} */
      e.next, e.next = r, r;
}, E3 = function(e, t) {
  var n = Iv(e, t);
  return n && n.value;
}, _3 = function(e, t, n) {
  var r = Iv(e, t);
  r ? r.value = n : e.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: t,
    next: e.next,
    value: n
  };
}, k3 = function(e, t) {
  return !!Iv(e, t);
}, Av = function() {
  var t, n, r, i = {
    assert: function(a) {
      if (!i.has(a))
        throw new v3("Side channel does not contain " + m3(a));
    },
    get: function(a) {
      if (Fl && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return g3(t, a);
      } else if (Bl) {
        if (n)
          return x3(n, a);
      } else if (r)
        return E3(r, a);
    },
    has: function(a) {
      if (Fl && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return b3(t, a);
      } else if (Bl) {
        if (n)
          return S3(n, a);
      } else if (r)
        return k3(r, a);
      return !1;
    },
    set: function(a, o) {
      Fl && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new Fl()), y3(t, a, o)) : Bl ? (n || (n = new Bl()), w3(n, a, o)) : (r || (r = { key: {}, next: null }), _3(r, a, o));
    }
  };
  return i;
}, $3 = String.prototype.replace, O3 = /%20/g, Sd = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, Pv = {
  default: Sd.RFC3986,
  formatters: {
    RFC1738: function(e) {
      return $3.call(e, O3, "+");
    },
    RFC3986: function(e) {
      return String(e);
    }
  },
  RFC1738: Sd.RFC1738,
  RFC3986: Sd.RFC3986
}, T3 = Pv, Ed = Object.prototype.hasOwnProperty, Vi = Array.isArray, vr = function() {
  for (var e = [], t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
}(), C3 = function(t) {
  for (; t.length > 1; ) {
    var n = t.pop(), r = n.obj[n.prop];
    if (Vi(r)) {
      for (var i = [], a = 0; a < r.length; ++a)
        typeof r[a] < "u" && i.push(r[a]);
      n.obj[n.prop] = i;
    }
  }
}, xk = function(t, n) {
  for (var r = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < t.length; ++i)
    typeof t[i] < "u" && (r[i] = t[i]);
  return r;
}, R3 = function e(t, n, r) {
  if (!n)
    return t;
  if (typeof n != "object") {
    if (Vi(t))
      t.push(n);
    else if (t && typeof t == "object")
      (r && (r.plainObjects || r.allowPrototypes) || !Ed.call(Object.prototype, n)) && (t[n] = !0);
    else
      return [t, n];
    return t;
  }
  if (!t || typeof t != "object")
    return [t].concat(n);
  var i = t;
  return Vi(t) && !Vi(n) && (i = xk(t, r)), Vi(t) && Vi(n) ? (n.forEach(function(a, o) {
    if (Ed.call(t, o)) {
      var s = t[o];
      s && typeof s == "object" && a && typeof a == "object" ? t[o] = e(s, a, r) : t.push(a);
    } else
      t[o] = a;
  }), t) : Object.keys(n).reduce(function(a, o) {
    var s = n[o];
    return Ed.call(a, o) ? a[o] = e(a[o], s, r) : a[o] = s, a;
  }, i);
}, I3 = function(t, n) {
  return Object.keys(n).reduce(function(r, i) {
    return r[i] = n[i], r;
  }, t);
}, A3 = function(e, t, n) {
  var r = e.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return r.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(r);
  } catch {
    return r;
  }
}, _d = 1024, P3 = function(t, n, r, i, a) {
  if (t.length === 0)
    return t;
  var o = t;
  if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)), r === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(p) {
      return "%26%23" + parseInt(p.slice(2), 16) + "%3B";
    });
  for (var s = "", l = 0; l < o.length; l += _d) {
    for (var c = o.length >= _d ? o.slice(l, l + _d) : o, u = [], f = 0; f < c.length; ++f) {
      var d = c.charCodeAt(f);
      if (d === 45 || d === 46 || d === 95 || d === 126 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || a === T3.RFC1738 && (d === 40 || d === 41)) {
        u[u.length] = c.charAt(f);
        continue;
      }
      if (d < 128) {
        u[u.length] = vr[d];
        continue;
      }
      if (d < 2048) {
        u[u.length] = vr[192 | d >> 6] + vr[128 | d & 63];
        continue;
      }
      if (d < 55296 || d >= 57344) {
        u[u.length] = vr[224 | d >> 12] + vr[128 | d >> 6 & 63] + vr[128 | d & 63];
        continue;
      }
      f += 1, d = 65536 + ((d & 1023) << 10 | c.charCodeAt(f) & 1023), u[u.length] = vr[240 | d >> 18] + vr[128 | d >> 12 & 63] + vr[128 | d >> 6 & 63] + vr[128 | d & 63];
    }
    s += u.join("");
  }
  return s;
}, j3 = function(t) {
  for (var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0; i < n.length; ++i)
    for (var a = n[i], o = a.obj[a.prop], s = Object.keys(o), l = 0; l < s.length; ++l) {
      var c = s[l], u = o[c];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({ obj: o, prop: c }), r.push(u));
    }
  return C3(n), t;
}, N3 = function(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}, D3 = function(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, M3 = function(t, n) {
  return [].concat(t, n);
}, L3 = function(t, n) {
  if (Vi(t)) {
    for (var r = [], i = 0; i < t.length; i += 1)
      r.push(n(t[i]));
    return r;
  }
  return n(t);
}, wk = {
  arrayToObject: xk,
  assign: I3,
  combine: M3,
  compact: j3,
  decode: A3,
  encode: P3,
  isBuffer: D3,
  isRegExp: N3,
  maybeMap: L3,
  merge: R3
}, Sk = Av, xc = wk, is = Pv, F3 = Object.prototype.hasOwnProperty, Ek = {
  brackets: function(t) {
    return t + "[]";
  },
  comma: "comma",
  indices: function(t, n) {
    return t + "[" + n + "]";
  },
  repeat: function(t) {
    return t;
  }
}, Er = Array.isArray, B3 = Array.prototype.push, _k = function(e, t) {
  B3.apply(e, Er(t) ? t : [t]);
}, z3 = Date.prototype.toISOString, dx = is.default, Wt = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: xc.encode,
  encodeValuesOnly: !1,
  format: dx,
  formatter: is.formatters[dx],
  // deprecated
  indices: !1,
  serializeDate: function(t) {
    return z3.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, U3 = function(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, kd = {}, q3 = function e(t, n, r, i, a, o, s, l, c, u, f, d, p, h, m, y, v, g) {
  for (var b = t, k = g, S = 0, _ = !1; (k = k.get(kd)) !== void 0 && !_; ) {
    var $ = k.get(t);
    if (S += 1, typeof $ < "u") {
      if ($ === S)
        throw new RangeError("Cyclic object value");
      _ = !0;
    }
    typeof k.get(kd) > "u" && (S = 0);
  }
  if (typeof u == "function" ? b = u(n, b) : b instanceof Date ? b = p(b) : r === "comma" && Er(b) && (b = xc.maybeMap(b, function(x) {
    return x instanceof Date ? p(x) : x;
  })), b === null) {
    if (o)
      return c && !y ? c(n, Wt.encoder, v, "key", h) : n;
    b = "";
  }
  if (U3(b) || xc.isBuffer(b)) {
    if (c) {
      var j = y ? n : c(n, Wt.encoder, v, "key", h);
      return [m(j) + "=" + m(c(b, Wt.encoder, v, "value", h))];
    }
    return [m(n) + "=" + m(String(b))];
  }
  var B = [];
  if (typeof b > "u")
    return B;
  var O;
  if (r === "comma" && Er(b))
    y && c && (b = xc.maybeMap(b, c)), O = [{ value: b.length > 0 ? b.join(",") || null : void 0 }];
  else if (Er(u))
    O = u;
  else {
    var N = Object.keys(b);
    O = f ? N.sort(f) : N;
  }
  var q = l ? n.replace(/\./g, "%2E") : n, M = i && Er(b) && b.length === 1 ? q + "[]" : q;
  if (a && Er(b) && b.length === 0)
    return M + "[]";
  for (var z = 0; z < O.length; ++z) {
    var D = O[z], R = typeof D == "object" && typeof D.value < "u" ? D.value : b[D];
    if (!(s && R === null)) {
      var W = d && l ? D.replace(/\./g, "%2E") : D, F = Er(b) ? typeof r == "function" ? r(M, W) : M : M + (d ? "." + W : "[" + W + "]");
      g.set(t, S);
      var A = Sk();
      A.set(kd, g), _k(B, e(
        R,
        F,
        r,
        i,
        a,
        o,
        s,
        l,
        r === "comma" && y && Er(b) ? null : c,
        u,
        f,
        d,
        p,
        h,
        m,
        y,
        v,
        A
      ));
    }
  }
  return B;
}, W3 = function(t) {
  if (!t)
    return Wt;
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = t.charset || Wt.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = is.default;
  if (typeof t.format < "u") {
    if (!F3.call(is.formatters, t.format))
      throw new TypeError("Unknown format option provided.");
    r = t.format;
  }
  var i = is.formatters[r], a = Wt.filter;
  (typeof t.filter == "function" || Er(t.filter)) && (a = t.filter);
  var o;
  if (t.arrayFormat in Ek ? o = t.arrayFormat : "indices" in t ? o = t.indices ? "indices" : "repeat" : o = Wt.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var s = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : Wt.allowDots : !!t.allowDots;
  return {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Wt.addQueryPrefix,
    allowDots: s,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Wt.allowEmptyArrays,
    arrayFormat: o,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Wt.charsetSentinel,
    commaRoundTrip: t.commaRoundTrip,
    delimiter: typeof t.delimiter > "u" ? Wt.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : Wt.encode,
    encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Wt.encodeDotInKeys,
    encoder: typeof t.encoder == "function" ? t.encoder : Wt.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Wt.encodeValuesOnly,
    filter: a,
    format: r,
    formatter: i,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Wt.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Wt.skipNulls,
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Wt.strictNullHandling
  };
}, H3 = function(e, t) {
  var n = e, r = W3(t), i, a;
  typeof r.filter == "function" ? (a = r.filter, n = a("", n)) : Er(r.filter) && (a = r.filter, i = a);
  var o = [];
  if (typeof n != "object" || n === null)
    return "";
  var s = Ek[r.arrayFormat], l = s === "comma" && r.commaRoundTrip;
  i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
  for (var c = Sk(), u = 0; u < i.length; ++u) {
    var f = i[u];
    r.skipNulls && n[f] === null || _k(o, q3(
      n[f],
      f,
      s,
      l,
      r.allowEmptyArrays,
      r.strictNullHandling,
      r.skipNulls,
      r.encodeDotInKeys,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      c
    ));
  }
  var d = o.join(r.delimiter), p = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), d.length > 0 ? p + d : "";
}, eo = wk, Nh = Object.prototype.hasOwnProperty, V3 = Array.isArray, Tt = {
  allowDots: !1,
  allowEmptyArrays: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decodeDotInKeys: !1,
  decoder: eo.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictDepth: !1,
  strictNullHandling: !1
}, Z3 = function(e) {
  return e.replace(/&#(\d+);/g, function(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, kk = function(e, t) {
  return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e;
}, K3 = "utf8=%26%2310003%3B", G3 = "utf8=%E2%9C%93", Y3 = function(t, n) {
  var r = { __proto__: null }, i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
  i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  var a = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, o = i.split(n.delimiter, a), s = -1, l, c = n.charset;
  if (n.charsetSentinel)
    for (l = 0; l < o.length; ++l)
      o[l].indexOf("utf8=") === 0 && (o[l] === G3 ? c = "utf-8" : o[l] === K3 && (c = "iso-8859-1"), s = l, l = o.length);
  for (l = 0; l < o.length; ++l)
    if (l !== s) {
      var u = o[l], f = u.indexOf("]="), d = f === -1 ? u.indexOf("=") : f + 1, p, h;
      d === -1 ? (p = n.decoder(u, Tt.decoder, c, "key"), h = n.strictNullHandling ? null : "") : (p = n.decoder(u.slice(0, d), Tt.decoder, c, "key"), h = eo.maybeMap(
        kk(u.slice(d + 1), n),
        function(y) {
          return n.decoder(y, Tt.decoder, c, "value");
        }
      )), h && n.interpretNumericEntities && c === "iso-8859-1" && (h = Z3(h)), u.indexOf("[]=") > -1 && (h = V3(h) ? [h] : h);
      var m = Nh.call(r, p);
      m && n.duplicates === "combine" ? r[p] = eo.combine(r[p], h) : (!m || n.duplicates === "last") && (r[p] = h);
    }
  return r;
}, J3 = function(e, t, n, r) {
  for (var i = r ? t : kk(t, n), a = e.length - 1; a >= 0; --a) {
    var o, s = e[a];
    if (s === "[]" && n.parseArrays)
      o = n.allowEmptyArrays && (i === "" || n.strictNullHandling && i === null) ? [] : [].concat(i);
    else {
      o = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var l = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, c = n.decodeDotInKeys ? l.replace(/%2E/g, ".") : l, u = parseInt(c, 10);
      !n.parseArrays && c === "" ? o = { 0: i } : !isNaN(u) && s !== c && String(u) === c && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [], o[u] = i) : c !== "__proto__" && (o[c] = i);
    }
    i = o;
  }
  return i;
}, X3 = function(t, n, r, i) {
  if (t) {
    var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, l = r.depth > 0 && o.exec(a), c = l ? a.slice(0, l.index) : a, u = [];
    if (c) {
      if (!r.plainObjects && Nh.call(Object.prototype, c) && !r.allowPrototypes)
        return;
      u.push(c);
    }
    for (var f = 0; r.depth > 0 && (l = s.exec(a)) !== null && f < r.depth; ) {
      if (f += 1, !r.plainObjects && Nh.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes)
        return;
      u.push(l[1]);
    }
    if (l) {
      if (r.strictDepth === !0)
        throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
      u.push("[" + a.slice(l.index) + "]");
    }
    return J3(u, n, r, i);
  }
}, Q3 = function(t) {
  if (!t)
    return Tt;
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean")
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof t.charset > "u" ? Tt.charset : t.charset, r = typeof t.duplicates > "u" ? Tt.duplicates : t.duplicates;
  if (r !== "combine" && r !== "first" && r !== "last")
    throw new TypeError("The duplicates option must be either combine, first, or last");
  var i = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Tt.allowDots : !!t.allowDots;
  return {
    allowDots: i,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Tt.allowEmptyArrays,
    allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Tt.allowPrototypes,
    allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Tt.allowSparse,
    arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Tt.arrayLimit,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Tt.charsetSentinel,
    comma: typeof t.comma == "boolean" ? t.comma : Tt.comma,
    decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Tt.decodeDotInKeys,
    decoder: typeof t.decoder == "function" ? t.decoder : Tt.decoder,
    delimiter: typeof t.delimiter == "string" || eo.isRegExp(t.delimiter) ? t.delimiter : Tt.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Tt.depth,
    duplicates: r,
    ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Tt.interpretNumericEntities,
    parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Tt.parameterLimit,
    parseArrays: t.parseArrays !== !1,
    plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Tt.plainObjects,
    strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Tt.strictDepth,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Tt.strictNullHandling
  };
}, eB = function(e, t) {
  var n = Q3(t);
  if (e === "" || e === null || typeof e > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var r = typeof e == "string" ? Y3(e, n) : e, i = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, a = Object.keys(r), o = 0; o < a.length; ++o) {
    var s = a[o], l = X3(s, r[s], n, typeof e == "string");
    i = eo.merge(i, l, n);
  }
  return n.allowSparse === !0 ? i : eo.compact(i);
}, tB = H3, nB = eB, rB = Pv, iB = {
  formats: rB,
  parse: nB,
  stringify: tB
};
const aB = /* @__PURE__ */ Ze(iB);
var Dh = { exports: {} };
/** @license
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */
(function(e, t) {
  (function(n) {
    var r = n.setTimeout, i = n.clearTimeout, a = n.XMLHttpRequest, o = n.XDomainRequest, s = n.ActiveXObject, l = n.EventSource, c = n.document, u = n.Promise, f = n.fetch, d = n.Response, p = n.TextDecoder, h = n.TextEncoder, m = n.AbortController;
    if (typeof window < "u" && typeof c < "u" && !("readyState" in c) && c.body == null && (c.readyState = "loading", window.addEventListener("load", function(I) {
      c.readyState = "complete";
    }, !1)), a == null && s != null && (a = function() {
      return new s("Microsoft.XMLHTTP");
    }), Object.create == null && (Object.create = function(I) {
      function G() {
      }
      return G.prototype = I, new G();
    }), Date.now || (Date.now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    }), m == null) {
      var y = f;
      f = function(I, G) {
        var re = G.signal;
        return y(I, { headers: G.headers, credentials: G.credentials, cache: G.cache }).then(function(Q) {
          var _e = Q.body.getReader();
          return re._reader = _e, re._aborted && re._reader.cancel(), {
            status: Q.status,
            statusText: Q.statusText,
            headers: Q.headers,
            body: {
              getReader: function() {
                return _e;
              }
            }
          };
        });
      }, m = function() {
        this.signal = {
          _reader: null,
          _aborted: !1
        }, this.abort = function() {
          this.signal._reader != null && this.signal._reader.cancel(), this.signal._aborted = !0;
        };
      };
    }
    function v() {
      this.bitsNeeded = 0, this.codePoint = 0;
    }
    v.prototype.decode = function(I) {
      function G(Me, L, P) {
        if (P === 1)
          return Me >= 128 >> L && Me << L <= 2047;
        if (P === 2)
          return Me >= 2048 >> L && Me << L <= 55295 || Me >= 57344 >> L && Me << L <= 65535;
        if (P === 3)
          return Me >= 65536 >> L && Me << L <= 1114111;
        throw new Error();
      }
      function re(Me, L) {
        if (Me === 6 * 1)
          return L >> 6 > 15 ? 3 : L > 31 ? 2 : 1;
        if (Me === 6 * 2)
          return L > 15 ? 3 : 2;
        if (Me === 6 * 3)
          return 3;
        throw new Error();
      }
      for (var Q = 65533, _e = "", xe = this.bitsNeeded, Ce = this.codePoint, We = 0; We < I.length; We += 1) {
        var Ie = I[We];
        xe !== 0 && (Ie < 128 || Ie > 191 || !G(Ce << 6 | Ie & 63, xe - 6, re(xe, Ce))) && (xe = 0, Ce = Q, _e += String.fromCharCode(Ce)), xe === 0 ? (Ie >= 0 && Ie <= 127 ? (xe = 0, Ce = Ie) : Ie >= 192 && Ie <= 223 ? (xe = 6 * 1, Ce = Ie & 31) : Ie >= 224 && Ie <= 239 ? (xe = 6 * 2, Ce = Ie & 15) : Ie >= 240 && Ie <= 247 ? (xe = 6 * 3, Ce = Ie & 7) : (xe = 0, Ce = Q), xe !== 0 && !G(Ce, xe, re(xe, Ce)) && (xe = 0, Ce = Q)) : (xe -= 6, Ce = Ce << 6 | Ie & 63), xe === 0 && (Ce <= 65535 ? _e += String.fromCharCode(Ce) : (_e += String.fromCharCode(55296 + (Ce - 65535 - 1 >> 10)), _e += String.fromCharCode(56320 + (Ce - 65535 - 1 & 1023))));
      }
      return this.bitsNeeded = xe, this.codePoint = Ce, _e;
    };
    var g = function() {
      try {
        return new p().decode(new h().encode("test"), { stream: !0 }) === "test";
      } catch (I) {
        console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + I);
      }
      return !1;
    };
    (p == null || h == null || !g()) && (p = v);
    var b = function() {
    };
    function k(I) {
      this.withCredentials = !1, this.readyState = 0, this.status = 0, this.statusText = "", this.responseText = "", this.onprogress = b, this.onload = b, this.onerror = b, this.onreadystatechange = b, this._contentType = "", this._xhr = I, this._sendTimeout = 0, this._abort = b;
    }
    k.prototype.open = function(I, G) {
      this._abort(!0);
      var re = this, Q = this._xhr, _e = 1, xe = 0;
      this._abort = function(P) {
        re._sendTimeout !== 0 && (i(re._sendTimeout), re._sendTimeout = 0), (_e === 1 || _e === 2 || _e === 3) && (_e = 4, Q.onload = b, Q.onerror = b, Q.onabort = b, Q.onprogress = b, Q.onreadystatechange = b, Q.abort(), xe !== 0 && (i(xe), xe = 0), P || (re.readyState = 4, re.onabort(null), re.onreadystatechange())), _e = 0;
      };
      var Ce = function() {
        if (_e === 1) {
          var P = 0, Y = "", ce = void 0;
          if ("contentType" in Q)
            P = 200, Y = "OK", ce = Q.contentType;
          else
            try {
              P = Q.status, Y = Q.statusText, ce = Q.getResponseHeader("Content-Type");
            } catch {
              P = 0, Y = "", ce = void 0;
            }
          P !== 0 && (_e = 2, re.readyState = 2, re.status = P, re.statusText = Y, re._contentType = ce, re.onreadystatechange());
        }
      }, We = function() {
        if (Ce(), _e === 2 || _e === 3) {
          _e = 3;
          var P = "";
          try {
            P = Q.responseText;
          } catch {
          }
          re.readyState = 3, re.responseText = P, re.onprogress();
        }
      }, Ie = function(P, Y) {
        if ((Y == null || Y.preventDefault == null) && (Y = {
          preventDefault: b
        }), We(), _e === 1 || _e === 2 || _e === 3) {
          if (_e = 4, xe !== 0 && (i(xe), xe = 0), re.readyState = 4, P === "load")
            re.onload(Y);
          else if (P === "error")
            re.onerror(Y);
          else if (P === "abort")
            re.onabort(Y);
          else
            throw new TypeError();
          re.onreadystatechange();
        }
      }, Me = function(P) {
        Q != null && (Q.readyState === 4 ? (!("onload" in Q) || !("onerror" in Q) || !("onabort" in Q)) && Ie(Q.responseText === "" ? "error" : "load", P) : Q.readyState === 3 ? "onprogress" in Q || We() : Q.readyState === 2 && Ce());
      }, L = function() {
        xe = r(function() {
          L();
        }, 500), Q.readyState === 3 && We();
      };
      "onload" in Q && (Q.onload = function(P) {
        Ie("load", P);
      }), "onerror" in Q && (Q.onerror = function(P) {
        Ie("error", P);
      }), "onabort" in Q && (Q.onabort = function(P) {
        Ie("abort", P);
      }), "onprogress" in Q && (Q.onprogress = We), "onreadystatechange" in Q && (Q.onreadystatechange = function(P) {
        Me(P);
      }), ("contentType" in Q || !("ontimeout" in a.prototype)) && (G += (G.indexOf("?") === -1 ? "?" : "&") + "padding=true"), Q.open(I, G, !0), "readyState" in Q && (xe = r(function() {
        L();
      }, 0));
    }, k.prototype.abort = function() {
      this._abort(!1);
    }, k.prototype.getResponseHeader = function(I) {
      return this._contentType;
    }, k.prototype.setRequestHeader = function(I, G) {
      var re = this._xhr;
      "setRequestHeader" in re && re.setRequestHeader(I, G);
    }, k.prototype.getAllResponseHeaders = function() {
      return this._xhr.getAllResponseHeaders != null && this._xhr.getAllResponseHeaders() || "";
    }, k.prototype.send = function() {
      if ((!("ontimeout" in a.prototype) || !("sendAsBinary" in a.prototype) && !("mozAnon" in a.prototype)) && c != null && c.readyState != null && c.readyState !== "complete") {
        var I = this;
        I._sendTimeout = r(function() {
          I._sendTimeout = 0, I.send();
        }, 4);
        return;
      }
      var G = this._xhr;
      "withCredentials" in G && (G.withCredentials = this.withCredentials);
      try {
        G.send(void 0);
      } catch (re) {
        throw re;
      }
    };
    function S(I) {
      return I.replace(/[A-Z]/g, function(G) {
        return String.fromCharCode(G.charCodeAt(0) + 32);
      });
    }
    function _(I) {
      for (var G = /* @__PURE__ */ Object.create(null), re = I.split(`\r
`), Q = 0; Q < re.length; Q += 1) {
        var _e = re[Q], xe = _e.split(": "), Ce = xe.shift(), We = xe.join(": ");
        G[S(Ce)] = We;
      }
      this._map = G;
    }
    _.prototype.get = function(I) {
      return this._map[S(I)];
    }, a != null && a.HEADERS_RECEIVED == null && (a.HEADERS_RECEIVED = 2);
    function $() {
    }
    $.prototype.open = function(I, G, re, Q, _e, xe, Ce) {
      I.open("GET", _e);
      var We = 0;
      I.onprogress = function() {
        var Me = I.responseText, L = Me.slice(We);
        We += L.length, re(L);
      }, I.onerror = function(Me) {
        Me.preventDefault(), Q(new Error("NetworkError"));
      }, I.onload = function() {
        Q(null);
      }, I.onabort = function() {
        Q(null);
      }, I.onreadystatechange = function() {
        if (I.readyState === a.HEADERS_RECEIVED) {
          var Me = I.status, L = I.statusText, P = I.getResponseHeader("Content-Type"), Y = I.getAllResponseHeaders();
          G(Me, L, P, new _(Y));
        }
      }, I.withCredentials = xe;
      for (var Ie in Ce)
        Object.prototype.hasOwnProperty.call(Ce, Ie) && I.setRequestHeader(Ie, Ce[Ie]);
      return I.send(), I;
    };
    function j(I) {
      this._headers = I;
    }
    j.prototype.get = function(I) {
      return this._headers.get(I);
    };
    function B() {
    }
    B.prototype.open = function(I, G, re, Q, _e, xe, Ce) {
      var We = null, Ie = new m(), Me = Ie.signal, L = new p();
      return f(_e, {
        headers: Ce,
        credentials: xe ? "include" : "same-origin",
        signal: Me,
        cache: "no-store"
      }).then(function(P) {
        return We = P.body.getReader(), G(P.status, P.statusText, P.headers.get("Content-Type"), new j(P.headers)), new u(function(Y, ce) {
          var Ee = function() {
            We.read().then(function($e) {
              if ($e.done)
                Y(void 0);
              else {
                var Ye = L.decode($e.value, { stream: !0 });
                re(Ye), Ee();
              }
            }).catch(function($e) {
              ce($e);
            });
          };
          Ee();
        });
      }).catch(function(P) {
        if (P.name !== "AbortError")
          return P;
      }).then(function(P) {
        Q(P);
      }), {
        abort: function() {
          We != null && We.cancel(), Ie.abort();
        }
      };
    };
    function O() {
      this._listeners = /* @__PURE__ */ Object.create(null);
    }
    function N(I) {
      r(function() {
        throw I;
      }, 0);
    }
    O.prototype.dispatchEvent = function(I) {
      I.target = this;
      var G = this._listeners[I.type];
      if (G != null)
        for (var re = G.length, Q = 0; Q < re; Q += 1) {
          var _e = G[Q];
          try {
            typeof _e.handleEvent == "function" ? _e.handleEvent(I) : _e.call(this, I);
          } catch (xe) {
            N(xe);
          }
        }
    }, O.prototype.addEventListener = function(I, G) {
      I = String(I);
      var re = this._listeners, Q = re[I];
      Q == null && (Q = [], re[I] = Q);
      for (var _e = !1, xe = 0; xe < Q.length; xe += 1)
        Q[xe] === G && (_e = !0);
      _e || Q.push(G);
    }, O.prototype.removeEventListener = function(I, G) {
      I = String(I);
      var re = this._listeners, Q = re[I];
      if (Q != null) {
        for (var _e = [], xe = 0; xe < Q.length; xe += 1)
          Q[xe] !== G && _e.push(Q[xe]);
        _e.length === 0 ? delete re[I] : re[I] = _e;
      }
    };
    function q(I) {
      this.type = I, this.target = void 0;
    }
    function M(I, G) {
      q.call(this, I), this.data = G.data, this.lastEventId = G.lastEventId;
    }
    M.prototype = Object.create(q.prototype);
    function z(I, G) {
      q.call(this, I), this.status = G.status, this.statusText = G.statusText, this.headers = G.headers;
    }
    z.prototype = Object.create(q.prototype);
    function D(I, G) {
      q.call(this, I), this.error = G.error;
    }
    D.prototype = Object.create(q.prototype);
    var R = -1, W = 0, F = 1, A = 2, x = -1, U = 0, Z = 1, E = 2, X = 3, ae = /^text\/event\-stream(;.*)?$/i, te = 1e3, se = 18e6, de = function(I, G) {
      var re = I == null ? G : parseInt(I, 10);
      return re !== re && (re = G), pe(re);
    }, pe = function(I) {
      return Math.min(Math.max(I, te), se);
    }, le = function(I, G, re) {
      try {
        typeof G == "function" && G.call(I, re);
      } catch (Q) {
        N(Q);
      }
    };
    function J(I, G) {
      O.call(this), G = G || {}, this.onopen = void 0, this.onmessage = void 0, this.onerror = void 0, this.url = void 0, this.readyState = void 0, this.withCredentials = void 0, this.headers = void 0, this._close = void 0, me(this, I, G);
    }
    function V() {
      return a != null && "withCredentials" in a.prototype || o == null ? new a() : new o();
    }
    var fe = f != null && d != null && "body" in d.prototype;
    function me(I, G, re) {
      G = String(G);
      var Q = !!re.withCredentials, _e = re.lastEventIdQueryParameterName || "lastEventId", xe = pe(1e3), Ce = de(re.heartbeatTimeout, 45e3), We = "", Ie = xe, Me = !1, L = 0, P = re.headers || {}, Y = re.Transport, ce = fe && Y == null ? void 0 : new k(Y != null ? new Y() : V()), Ee = Y != null && typeof Y != "string" ? new Y() : ce == null ? new B() : new $(), $e = void 0, Ye = 0, at = R, Bt = "", Rt = "", He = "", It = "", Je = U, vn = 0, On = 0, Yn = function(dt, St, zt, Ut) {
        if (at === W)
          if (dt === 200 && zt != null && ae.test(zt)) {
            at = F, Me = Date.now(), Ie = xe, I.readyState = F;
            var Xt = new z("open", {
              status: dt,
              statusText: St,
              headers: Ut
            });
            I.dispatchEvent(Xt), le(I, I.onopen, Xt);
          } else {
            var qt = "";
            dt !== 200 ? (St && (St = St.replace(/\s+/g, " ")), qt = "EventSource's response has a status " + dt + " " + St + " that is not 200. Aborting the connection.") : qt = "EventSource's response has a Content-Type specifying an unsupported type: " + (zt == null ? "-" : zt.replace(/\s+/g, " ")) + ". Aborting the connection.", Jn();
            var Xt = new z("error", {
              status: dt,
              statusText: St,
              headers: Ut
            });
            I.dispatchEvent(Xt), le(I, I.onerror, Xt), console.error(qt);
          }
      }, Ur = function(dt) {
        if (at === F) {
          for (var St = -1, zt = 0; zt < dt.length; zt += 1) {
            var Ut = dt.charCodeAt(zt);
            (Ut === 10 || Ut === 13) && (St = zt);
          }
          var Xt = (St !== -1 ? It : "") + dt.slice(0, St + 1);
          It = (St === -1 ? It : "") + dt.slice(St + 1), dt !== "" && (Me = Date.now(), L += dt.length);
          for (var qt = 0; qt < Xt.length; qt += 1) {
            var Ut = Xt.charCodeAt(qt);
            if (Je === x && Ut === 10)
              Je = U;
            else if (Je === x && (Je = U), Ut === 13 || Ut === 10) {
              if (Je !== U) {
                Je === Z && (On = qt + 1);
                var Dn = Xt.slice(vn, On - 1), Mn = Xt.slice(On + (On < qt && Xt.charCodeAt(On) === 32 ? 1 : 0), qt);
                Dn === "data" ? (Bt += `
`, Bt += Mn) : Dn === "id" ? Rt = Mn : Dn === "event" ? He = Mn : Dn === "retry" ? (xe = de(Mn, xe), Ie = xe) : Dn === "heartbeatTimeout" && (Ce = de(Mn, Ce), Ye !== 0 && (i(Ye), Ye = r(function() {
                  qr();
                }, Ce)));
              }
              if (Je === U) {
                if (Bt !== "") {
                  We = Rt, He === "" && (He = "message");
                  var si = new M(He, {
                    data: Bt.slice(1),
                    lastEventId: Rt
                  });
                  if (I.dispatchEvent(si), He === "open" ? le(I, I.onopen, si) : He === "message" ? le(I, I.onmessage, si) : He === "error" && le(I, I.onerror, si), at === A)
                    return;
                }
                Bt = "", He = "";
              }
              Je = Ut === 13 ? x : U;
            } else
              Je === U && (vn = qt, Je = Z), Je === Z ? Ut === 58 && (On = qt + 1, Je = E) : Je === E && (Je = X);
          }
        }
      }, mr = function(dt) {
        if (at === F || at === W) {
          at = R, Ye !== 0 && (i(Ye), Ye = 0), Ye = r(function() {
            qr();
          }, Ie), Ie = pe(Math.min(xe * 16, Ie * 2)), I.readyState = W;
          var St = new D("error", { error: dt });
          I.dispatchEvent(St), le(I, I.onerror, St), dt != null && console.error(dt);
        }
      }, Jn = function() {
        at = A, $e != null && ($e.abort(), $e = void 0), Ye !== 0 && (i(Ye), Ye = 0), I.readyState = A;
      }, qr = function() {
        if (Ye = 0, at !== R) {
          if (!Me && $e != null)
            mr(new Error("No activity within " + Ce + " milliseconds. " + (at === W ? "No response received." : L + " chars received.") + " Reconnecting.")), $e != null && ($e.abort(), $e = void 0);
          else {
            var dt = Math.max((Me || Date.now()) + Ce - Date.now(), 1);
            Me = !1, Ye = r(function() {
              qr();
            }, dt);
          }
          return;
        }
        Me = !1, L = 0, Ye = r(function() {
          qr();
        }, Ce), at = W, Bt = "", He = "", Rt = We, It = "", vn = 0, On = 0, Je = U;
        var St = G;
        if (G.slice(0, 5) !== "data:" && G.slice(0, 5) !== "blob:" && We !== "") {
          var zt = G.indexOf("?");
          St = zt === -1 ? G : G.slice(0, zt + 1) + G.slice(zt + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(Mn, si) {
            return si === _e ? "" : Mn;
          }), St += (G.indexOf("?") === -1 ? "?" : "&") + _e + "=" + encodeURIComponent(We);
        }
        var Ut = I.withCredentials, Xt = {};
        Xt.Accept = "text/event-stream";
        var qt = I.headers;
        if (qt != null)
          for (var Dn in qt)
            Object.prototype.hasOwnProperty.call(qt, Dn) && (Xt[Dn] = qt[Dn]);
        try {
          $e = Ee.open(ce, Yn, Ur, mr, St, Ut, Xt);
        } catch (Mn) {
          throw Jn(), Mn;
        }
      };
      I.url = G, I.readyState = W, I.withCredentials = Q, I.headers = P, I._close = Jn, qr();
    }
    J.prototype = Object.create(O.prototype), J.prototype.CONNECTING = W, J.prototype.OPEN = F, J.prototype.CLOSED = A, J.prototype.close = function() {
      this._close();
    }, J.CONNECTING = W, J.OPEN = F, J.CLOSED = A, J.prototype.withCredentials = void 0;
    var Oe = l;
    a != null && (l == null || !("withCredentials" in l.prototype)) && (Oe = J), function(I) {
      {
        var G = I(t);
        G !== void 0 && (e.exports = G);
      }
    }(function(I) {
      I.EventSourcePolyfill = J, I.NativeEventSource = l, I.EventSource = Oe;
    });
  })(typeof globalThis > "u" ? typeof window < "u" ? window : typeof self < "u" ? self : ft : globalThis);
})(Dh, Dh.exports);
var oB = Dh.exports;
const sB = /* @__PURE__ */ Ze(oB);
var et;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(et || (et = {}));
var Mh;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(Mh || (Mh = {}));
const ye = et.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), hi = (e) => {
  switch (typeof e) {
    case "undefined":
      return ye.undefined;
    case "string":
      return ye.string;
    case "number":
      return isNaN(e) ? ye.nan : ye.number;
    case "boolean":
      return ye.boolean;
    case "function":
      return ye.function;
    case "bigint":
      return ye.bigint;
    case "symbol":
      return ye.symbol;
    case "object":
      return Array.isArray(e) ? ye.array : e === null ? ye.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ye.promise : typeof Map < "u" && e instanceof Map ? ye.map : typeof Set < "u" && e instanceof Set ? ye.set : typeof Date < "u" && e instanceof Date ? ye.date : ye.object;
    default:
      return ye.unknown;
  }
}, ne = et.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), lB = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class In extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(n(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], l++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof In))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, et.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
In.create = (e) => new In(e);
const to = (e, t) => {
  let n;
  switch (e.code) {
    case ne.invalid_type:
      e.received === ye.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ne.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, et.jsonStringifyReplacer)}`;
      break;
    case ne.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${et.joinValues(e.keys, ", ")}`;
      break;
    case ne.invalid_union:
      n = "Invalid input";
      break;
    case ne.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${et.joinValues(e.options)}`;
      break;
    case ne.invalid_enum_value:
      n = `Invalid enum value. Expected ${et.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ne.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ne.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ne.invalid_date:
      n = "Invalid date";
      break;
    case ne.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : et.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case ne.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case ne.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case ne.custom:
      n = "Invalid input";
      break;
    case ne.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ne.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ne.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, et.assertNever(e);
  }
  return { message: n };
};
let $k = to;
function cB(e) {
  $k = e;
}
function uu() {
  return $k;
}
const fu = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], o = {
    ...i,
    path: a
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: a,
      message: i.message
    };
  let s = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    s = c(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: s
  };
}, uB = [];
function he(e, t) {
  const n = uu(), r = fu({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      n,
      n === to ? void 0 : to
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(r);
}
class ln {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return je;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n) {
      const a = await i.key, o = await i.value;
      r.push({
        key: a,
        value: o
      });
    }
    return ln.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return je;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
}
const je = Object.freeze({
  status: "aborted"
}), Da = (e) => ({ status: "dirty", value: e }), mn = (e) => ({ status: "valid", value: e }), Lh = (e) => e.status === "aborted", Fh = (e) => e.status === "dirty", $s = (e) => e.status === "valid", Os = (e) => typeof Promise < "u" && e instanceof Promise;
function du(e, t, n, r) {
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function Ok(e, t, n, r, i) {
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
var ke;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(ke || (ke = {}));
var Go, Yo;
class Ir {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const px = (e, t) => {
  if ($s(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new In(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function ze(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => {
    var l, c;
    const { message: u } = e;
    return o.code === "invalid_enum_value" ? { message: u ?? s.defaultError } : typeof s.data > "u" ? { message: (l = u ?? r) !== null && l !== void 0 ? l : s.defaultError } : o.code !== "invalid_type" ? { message: s.defaultError } : { message: (c = u ?? n) !== null && c !== void 0 ? c : s.defaultError };
  }, description: i };
}
class qe {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return hi(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: hi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ln(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: hi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Os(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: hi(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return px(i, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: hi(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (Os(i) ? i : Promise.resolve(i));
    return px(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: ne.custom,
        ...r(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new ur({
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Tr.create(this, this._def);
  }
  nullable() {
    return Ci.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return sr.create(this, this._def);
  }
  promise() {
    return ro.create(this, this._def);
  }
  or(t) {
    return Is.create([this, t], this._def);
  }
  and(t) {
    return As.create(this, t, this._def);
  }
  transform(t) {
    return new ur({
      ...ze(this._def),
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ms({
      ...ze(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Pe.ZodDefault
    });
  }
  brand() {
    return new jv({
      typeName: Pe.ZodBranded,
      type: this,
      ...ze(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ls({
      ...ze(this._def),
      innerType: this,
      catchValue: n,
      typeName: Pe.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return sl.create(this, t);
  }
  readonly() {
    return Fs.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const fB = /^c[^\s-]{8,}$/i, dB = /^[0-9a-z]+$/, pB = /^[0-9A-HJKMNP-TV-Z]{26}$/, hB = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, mB = /^[a-z0-9_-]{21}$/i, vB = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, gB = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, yB = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let $d;
const bB = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, xB = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, wB = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Tk = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", SB = new RegExp(`^${Tk}$`);
function Ck(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function EB(e) {
  return new RegExp(`^${Ck(e)}$`);
}
function Rk(e) {
  let t = `${Tk}T${Ck(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function _B(e, t) {
  return !!((t === "v4" || !t) && bB.test(e) || (t === "v6" || !t) && xB.test(e));
}
class rr extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ye.string) {
      const a = this._getOrReturnCtx(t);
      return he(a, {
        code: ne.invalid_type,
        expected: ye.string,
        received: a.parsedType
      }), je;
    }
    const r = new ln();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), he(i, {
          code: ne.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), he(i, {
          code: ne.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? he(i, {
          code: ne.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && he(i, {
          code: ne.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        gB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "email",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        $d || ($d = new RegExp(yB, "u")), $d.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "emoji",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        hB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "uuid",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "nanoid")
        mB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "nanoid",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        fB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "cuid",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        dB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "cuid2",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        pB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
          validation: "ulid",
          code: ne.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), he(i, {
            validation: "url",
            code: ne.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        validation: "regex",
        code: ne.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? Rk(a).test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "date" ? SB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: "date",
        message: a.message
      }), r.dirty()) : a.kind === "time" ? EB(a).test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.invalid_string,
        validation: "time",
        message: a.message
      }), r.dirty()) : a.kind === "duration" ? vB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        validation: "duration",
        code: ne.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? _B(t.data, a.version) || (i = this._getOrReturnCtx(t, i), he(i, {
        validation: "ip",
        code: ne.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "base64" ? wB.test(t.data) || (i = this._getOrReturnCtx(t, i), he(i, {
        validation: "base64",
        code: ne.invalid_string,
        message: a.message
      }), r.dirty()) : et.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: ne.invalid_string,
      ...ke.errToObj(r)
    });
  }
  _addCheck(t) {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...ke.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...ke.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...ke.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...ke.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...ke.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...ke.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...ke.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...ke.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...ke.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...ke.errToObj(t) });
  }
  datetime(t) {
    var n, r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      local: (r = t == null ? void 0 : t.local) !== null && r !== void 0 ? r : !1,
      ...ke.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...ke.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...ke.errToObj(t) });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...ke.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...ke.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...ke.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...ke.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...ke.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...ke.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...ke.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, ke.errToObj(t));
  }
  trim() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
rr.create = (e) => {
  var t;
  return new rr({
    checks: [],
    typeName: Pe.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ze(e)
  });
};
function kB(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
class $i extends qe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ye.number) {
      const a = this._getOrReturnCtx(t);
      return he(a, {
        code: ne.invalid_type,
        expected: ye.number,
        received: a.parsedType
      }), je;
    }
    let r;
    const i = new ln();
    for (const a of this._def.checks)
      a.kind === "int" ? et.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? kB(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.not_finite,
        message: a.message
      }), i.dirty()) : et.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, ke.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, ke.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, ke.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, ke.toString(n));
  }
  setLimit(t, n, r, i) {
    return new $i({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: ke.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new $i({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: ke.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ke.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ke.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ke.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ke.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: ke.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: ke.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ke.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ke.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && et.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
$i.create = (e) => new $i({
  checks: [],
  typeName: Pe.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ze(e)
});
class Oi extends qe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ye.bigint) {
      const a = this._getOrReturnCtx(t);
      return he(a, {
        code: ne.invalid_type,
        expected: ye.bigint,
        received: a.parsedType
      }), je;
    }
    let r;
    const i = new ln();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), he(r, {
        code: ne.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : et.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, ke.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, ke.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, ke.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, ke.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Oi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: ke.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Oi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ke.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ke.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ke.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ke.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: ke.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Oi.create = (e) => {
  var t;
  return new Oi({
    checks: [],
    typeName: Pe.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ze(e)
  });
};
class Ts extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ye.boolean) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.boolean,
        received: r.parsedType
      }), je;
    }
    return mn(t.data);
  }
}
Ts.create = (e) => new Ts({
  typeName: Pe.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ze(e)
});
class ia extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ye.date) {
      const a = this._getOrReturnCtx(t);
      return he(a, {
        code: ne.invalid_type,
        expected: ye.date,
        received: a.parsedType
      }), je;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return he(a, {
        code: ne.invalid_date
      }), je;
    }
    const r = new ln();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), he(i, {
        code: ne.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : et.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new ia({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: ke.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: ke.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
ia.create = (e) => new ia({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Pe.ZodDate,
  ...ze(e)
});
class pu extends qe {
  _parse(t) {
    if (this._getType(t) !== ye.symbol) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.symbol,
        received: r.parsedType
      }), je;
    }
    return mn(t.data);
  }
}
pu.create = (e) => new pu({
  typeName: Pe.ZodSymbol,
  ...ze(e)
});
class Cs extends qe {
  _parse(t) {
    if (this._getType(t) !== ye.undefined) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.undefined,
        received: r.parsedType
      }), je;
    }
    return mn(t.data);
  }
}
Cs.create = (e) => new Cs({
  typeName: Pe.ZodUndefined,
  ...ze(e)
});
class Rs extends qe {
  _parse(t) {
    if (this._getType(t) !== ye.null) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.null,
        received: r.parsedType
      }), je;
    }
    return mn(t.data);
  }
}
Rs.create = (e) => new Rs({
  typeName: Pe.ZodNull,
  ...ze(e)
});
class no extends qe {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return mn(t.data);
  }
}
no.create = (e) => new no({
  typeName: Pe.ZodAny,
  ...ze(e)
});
class Ji extends qe {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return mn(t.data);
  }
}
Ji.create = (e) => new Ji({
  typeName: Pe.ZodUnknown,
  ...ze(e)
});
class Qr extends qe {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return he(n, {
      code: ne.invalid_type,
      expected: ye.never,
      received: n.parsedType
    }), je;
  }
}
Qr.create = (e) => new Qr({
  typeName: Pe.ZodNever,
  ...ze(e)
});
class hu extends qe {
  _parse(t) {
    if (this._getType(t) !== ye.undefined) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.void,
        received: r.parsedType
      }), je;
    }
    return mn(t.data);
  }
}
hu.create = (e) => new hu({
  typeName: Pe.ZodVoid,
  ...ze(e)
});
class sr extends qe {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== ye.array)
      return he(n, {
        code: ne.invalid_type,
        expected: ye.array,
        received: n.parsedType
      }), je;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (he(n, {
        code: o ? ne.too_big : ne.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (he(n, {
      code: ne.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (he(n, {
      code: ne.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, s) => i.type._parseAsync(new Ir(n, o, n.path, s)))).then((o) => ln.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new Ir(n, o, n.path, s)));
    return ln.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new sr({
      ...this._def,
      minLength: { value: t, message: ke.toString(n) }
    });
  }
  max(t, n) {
    return new sr({
      ...this._def,
      maxLength: { value: t, message: ke.toString(n) }
    });
  }
  length(t, n) {
    return new sr({
      ...this._def,
      exactLength: { value: t, message: ke.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
sr.create = (e, t) => new sr({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Pe.ZodArray,
  ...ze(t)
});
function ja(e) {
  if (e instanceof kt) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Tr.create(ja(r));
    }
    return new kt({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof sr ? new sr({
    ...e._def,
    type: ja(e.element)
  }) : e instanceof Tr ? Tr.create(ja(e.unwrap())) : e instanceof Ci ? Ci.create(ja(e.unwrap())) : e instanceof Ar ? Ar.create(e.items.map((t) => ja(t))) : e;
}
class kt extends qe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = et.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== ye.object) {
      const c = this._getOrReturnCtx(t);
      return he(c, {
        code: ne.invalid_type,
        expected: ye.object,
        received: c.parsedType
      }), je;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Qr && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        o.includes(c) || s.push(c);
    const l = [];
    for (const c of o) {
      const u = a[c], f = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Ir(i, f, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof Qr) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (he(i, {
          code: ne.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const f = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new Ir(i, f, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const f = await u.key, d = await u.value;
        c.push({
          key: f,
          value: d,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => ln.mergeObjectSync(r, c)) : ln.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return ke.errToObj, new kt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, o, s;
          const l = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = ke.errToObj(t).message) !== null && s !== void 0 ? s : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new kt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new kt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new kt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new kt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Pe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new kt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return et.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new kt({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return et.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new kt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ja(this);
  }
  partial(t) {
    const n = {};
    return et.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new kt({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return et.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Tr; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new kt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Ik(et.objectKeys(this.shape));
  }
}
kt.create = (e, t) => new kt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Qr.create(),
  typeName: Pe.ZodObject,
  ...ze(t)
});
kt.strictCreate = (e, t) => new kt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Qr.create(),
  typeName: Pe.ZodObject,
  ...ze(t)
});
kt.lazycreate = (e, t) => new kt({
  shape: e,
  unknownKeys: "strip",
  catchall: Qr.create(),
  typeName: Pe.ZodObject,
  ...ze(t)
});
class Is extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new In(s.ctx.common.issues));
      return he(n, {
        code: ne.invalid_union,
        unionErrors: o
      }), je;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const l of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((l) => new In(l));
      return he(n, {
        code: ne.invalid_union,
        unionErrors: s
      }), je;
    }
  }
  get options() {
    return this._def.options;
  }
}
Is.create = (e, t) => new Is({
  options: e,
  typeName: Pe.ZodUnion,
  ...ze(t)
});
const Vr = (e) => e instanceof js ? Vr(e.schema) : e instanceof ur ? Vr(e.innerType()) : e instanceof Ns ? [e.value] : e instanceof Ti ? e.options : e instanceof Ds ? et.objectValues(e.enum) : e instanceof Ms ? Vr(e._def.innerType) : e instanceof Cs ? [void 0] : e instanceof Rs ? [null] : e instanceof Tr ? [void 0, ...Vr(e.unwrap())] : e instanceof Ci ? [null, ...Vr(e.unwrap())] : e instanceof jv || e instanceof Fs ? Vr(e.unwrap()) : e instanceof Ls ? Vr(e._def.innerType) : [];
class lf extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ye.object)
      return he(n, {
        code: ne.invalid_type,
        expected: ye.object,
        received: n.parsedType
      }), je;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (he(n, {
      code: ne.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), je);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = Vr(a.shape[t]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new lf({
      typeName: Pe.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...ze(r)
    });
  }
}
function Bh(e, t) {
  const n = hi(e), r = hi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === ye.object && r === ye.object) {
    const i = et.objectKeys(t), a = et.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const l = Bh(e[s], t[s]);
      if (!l.valid)
        return { valid: !1 };
      o[s] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === ye.array && r === ye.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], l = Bh(o, s);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else return n === ye.date && r === ye.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class As extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, o) => {
      if (Lh(a) || Lh(o))
        return je;
      const s = Bh(a.value, o.value);
      return s.valid ? ((Fh(a) || Fh(o)) && n.dirty(), { status: n.value, value: s.data }) : (he(r, {
        code: ne.invalid_intersection_types
      }), je);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
As.create = (e, t, n) => new As({
  left: e,
  right: t,
  typeName: Pe.ZodIntersection,
  ...ze(n)
});
class Ar extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ye.array)
      return he(r, {
        code: ne.invalid_type,
        expected: ye.array,
        received: r.parsedType
      }), je;
    if (r.data.length < this._def.items.length)
      return he(r, {
        code: ne.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), je;
    !this._def.rest && r.data.length > this._def.items.length && (he(r, {
      code: ne.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const l = this._def.items[s] || this._def.rest;
      return l ? l._parse(new Ir(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => ln.mergeArray(n, o)) : ln.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Ar({
      ...this._def,
      rest: t
    });
  }
}
Ar.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Ar({
    items: e,
    typeName: Pe.ZodTuple,
    rest: null,
    ...ze(t)
  });
};
class Ps extends qe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ye.object)
      return he(r, {
        code: ne.invalid_type,
        expected: ye.object,
        received: r.parsedType
      }), je;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new Ir(r, s, r.path, s)),
        value: o._parse(new Ir(r, r.data[s], r.path, s)),
        alwaysSet: s in r.data
      });
    return r.common.async ? ln.mergeObjectAsync(n, i) : ln.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof qe ? new Ps({
      keyType: t,
      valueType: n,
      typeName: Pe.ZodRecord,
      ...ze(r)
    }) : new Ps({
      keyType: rr.create(),
      valueType: t,
      typeName: Pe.ZodRecord,
      ...ze(n)
    });
  }
}
class mu extends qe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ye.map)
      return he(r, {
        code: ne.invalid_type,
        expected: ye.map,
        received: r.parsedType
      }), je;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, l], c) => ({
      key: i._parse(new Ir(r, s, r.path, [c, "key"])),
      value: a._parse(new Ir(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return je;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return je;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
}
mu.create = (e, t, n) => new mu({
  valueType: t,
  keyType: e,
  typeName: Pe.ZodMap,
  ...ze(n)
});
class aa extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ye.set)
      return he(r, {
        code: ne.invalid_type,
        expected: ye.set,
        received: r.parsedType
      }), je;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (he(r, {
      code: ne.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (he(r, {
      code: ne.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return je;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const s = [...r.data.values()].map((l, c) => a._parse(new Ir(r, l, r.path, c)));
    return r.common.async ? Promise.all(s).then((l) => o(l)) : o(s);
  }
  min(t, n) {
    return new aa({
      ...this._def,
      minSize: { value: t, message: ke.toString(n) }
    });
  }
  max(t, n) {
    return new aa({
      ...this._def,
      maxSize: { value: t, message: ke.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
aa.create = (e, t) => new aa({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Pe.ZodSet,
  ...ze(t)
});
class Ua extends qe {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ye.function)
      return he(n, {
        code: ne.invalid_type,
        expected: ye.function,
        received: n.parsedType
      }), je;
    function r(s, l) {
      return fu({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          uu(),
          to
        ].filter((c) => !!c),
        issueData: {
          code: ne.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(s, l) {
      return fu({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          uu(),
          to
        ].filter((c) => !!c),
        issueData: {
          code: ne.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof ro) {
      const s = this;
      return mn(async function(...l) {
        const c = new In([]), u = await s._def.args.parseAsync(l, a).catch((p) => {
          throw c.addIssue(r(l, p)), c;
        }), f = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(f, a).catch((p) => {
          throw c.addIssue(i(f, p)), c;
        });
      });
    } else {
      const s = this;
      return mn(function(...l) {
        const c = s._def.args.safeParse(l, a);
        if (!c.success)
          throw new In([r(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), f = s._def.returns.safeParse(u, a);
        if (!f.success)
          throw new In([i(u, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ua({
      ...this._def,
      args: Ar.create(t).rest(Ji.create())
    });
  }
  returns(t) {
    return new Ua({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Ua({
      args: t || Ar.create([]).rest(Ji.create()),
      returns: n || Ji.create(),
      typeName: Pe.ZodFunction,
      ...ze(r)
    });
  }
}
class js extends qe {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
js.create = (e, t) => new js({
  getter: e,
  typeName: Pe.ZodLazy,
  ...ze(t)
});
class Ns extends qe {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return he(n, {
        received: n.data,
        code: ne.invalid_literal,
        expected: this._def.value
      }), je;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Ns.create = (e, t) => new Ns({
  value: e,
  typeName: Pe.ZodLiteral,
  ...ze(t)
});
function Ik(e, t) {
  return new Ti({
    values: e,
    typeName: Pe.ZodEnum,
    ...ze(t)
  });
}
class Ti extends qe {
  constructor() {
    super(...arguments), Go.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return he(n, {
        expected: et.joinValues(r),
        received: n.parsedType,
        code: ne.invalid_type
      }), je;
    }
    if (du(this, Go) || Ok(this, Go, new Set(this._def.values)), !du(this, Go).has(t.data)) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return he(n, {
        received: n.data,
        code: ne.invalid_enum_value,
        options: r
      }), je;
    }
    return mn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return Ti.create(t, {
      ...this._def,
      ...n
    });
  }
  exclude(t, n = this._def) {
    return Ti.create(this.options.filter((r) => !t.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
Go = /* @__PURE__ */ new WeakMap();
Ti.create = Ik;
class Ds extends qe {
  constructor() {
    super(...arguments), Yo.set(this, void 0);
  }
  _parse(t) {
    const n = et.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== ye.string && r.parsedType !== ye.number) {
      const i = et.objectValues(n);
      return he(r, {
        expected: et.joinValues(i),
        received: r.parsedType,
        code: ne.invalid_type
      }), je;
    }
    if (du(this, Yo) || Ok(this, Yo, new Set(et.getValidEnumValues(this._def.values))), !du(this, Yo).has(t.data)) {
      const i = et.objectValues(n);
      return he(r, {
        received: r.data,
        code: ne.invalid_enum_value,
        options: i
      }), je;
    }
    return mn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Yo = /* @__PURE__ */ new WeakMap();
Ds.create = (e, t) => new Ds({
  values: e,
  typeName: Pe.ZodNativeEnum,
  ...ze(t)
});
class ro extends qe {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ye.promise && n.common.async === !1)
      return he(n, {
        code: ne.invalid_type,
        expected: ye.promise,
        received: n.parsedType
      }), je;
    const r = n.parsedType === ye.promise ? n.data : Promise.resolve(n.data);
    return mn(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
ro.create = (e, t) => new ro({
  type: e,
  typeName: Pe.ZodPromise,
  ...ze(t)
});
class ur extends qe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Pe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        he(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      if (r.common.async)
        return Promise.resolve(o).then(async (s) => {
          if (n.value === "aborted")
            return je;
          const l = await this._def.schema._parseAsync({
            data: s,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? je : l.status === "dirty" || n.value === "dirty" ? Da(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return je;
        const s = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? je : s.status === "dirty" || n.value === "dirty" ? Da(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const l = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? je : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? je : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!$s(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => $s(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: n.value, value: s })) : o);
    et.assertNever(i);
  }
}
ur.create = (e, t, n) => new ur({
  schema: e,
  typeName: Pe.ZodEffects,
  effect: t,
  ...ze(n)
});
ur.createWithPreprocess = (e, t, n) => new ur({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Pe.ZodEffects,
  ...ze(n)
});
class Tr extends qe {
  _parse(t) {
    return this._getType(t) === ye.undefined ? mn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Tr.create = (e, t) => new Tr({
  innerType: e,
  typeName: Pe.ZodOptional,
  ...ze(t)
});
class Ci extends qe {
  _parse(t) {
    return this._getType(t) === ye.null ? mn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ci.create = (e, t) => new Ci({
  innerType: e,
  typeName: Pe.ZodNullable,
  ...ze(t)
});
class Ms extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === ye.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ms.create = (e, t) => new Ms({
  innerType: e,
  typeName: Pe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ze(t)
});
class Ls extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Os(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new In(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new In(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Ls.create = (e, t) => new Ls({
  innerType: e,
  typeName: Pe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ze(t)
});
class vu extends qe {
  _parse(t) {
    if (this._getType(t) !== ye.nan) {
      const r = this._getOrReturnCtx(t);
      return he(r, {
        code: ne.invalid_type,
        expected: ye.nan,
        received: r.parsedType
      }), je;
    }
    return { status: "valid", value: t.data };
  }
}
vu.create = (e) => new vu({
  typeName: Pe.ZodNaN,
  ...ze(e)
});
const $B = Symbol("zod_brand");
class jv extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class sl extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? je : a.status === "dirty" ? (n.dirty(), Da(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? je : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new sl({
      in: t,
      out: n,
      typeName: Pe.ZodPipeline
    });
  }
}
class Fs extends qe {
  _parse(t) {
    const n = this._def.innerType._parse(t), r = (i) => ($s(i) && (i.value = Object.freeze(i.value)), i);
    return Os(n) ? n.then((i) => r(i)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Fs.create = (e, t) => new Fs({
  innerType: e,
  typeName: Pe.ZodReadonly,
  ...ze(t)
});
function Ak(e, t = {}, n) {
  return e ? no.create().superRefine((r, i) => {
    var a, o;
    if (!e(r)) {
      const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, l = (o = (a = s.fatal) !== null && a !== void 0 ? a : n) !== null && o !== void 0 ? o : !0, c = typeof s == "string" ? { message: s } : s;
      i.addIssue({ code: "custom", ...c, fatal: l });
    }
  }) : no.create();
}
const OB = {
  object: kt.lazycreate
};
var Pe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Pe || (Pe = {}));
const TB = (e, t = {
  message: `Input not instance of ${e.name}`
}) => Ak((n) => n instanceof e, t), Pk = rr.create, jk = $i.create, CB = vu.create, RB = Oi.create, Nk = Ts.create, IB = ia.create, AB = pu.create, PB = Cs.create, jB = Rs.create, NB = no.create, DB = Ji.create, MB = Qr.create, LB = hu.create, FB = sr.create, BB = kt.create, zB = kt.strictCreate, UB = Is.create, qB = lf.create, WB = As.create, HB = Ar.create, VB = Ps.create, ZB = mu.create, KB = aa.create, GB = Ua.create, YB = js.create, JB = Ns.create, XB = Ti.create, QB = Ds.create, e4 = ro.create, hx = ur.create, t4 = Tr.create, n4 = Ci.create, r4 = ur.createWithPreprocess, i4 = sl.create, a4 = () => Pk().optional(), o4 = () => jk().optional(), s4 = () => Nk().optional(), l4 = {
  string: (e) => rr.create({ ...e, coerce: !0 }),
  number: (e) => $i.create({ ...e, coerce: !0 }),
  boolean: (e) => Ts.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Oi.create({ ...e, coerce: !0 }),
  date: (e) => ia.create({ ...e, coerce: !0 })
}, c4 = je;
var H = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: to,
  setErrorMap: cB,
  getErrorMap: uu,
  makeIssue: fu,
  EMPTY_PATH: uB,
  addIssueToContext: he,
  ParseStatus: ln,
  INVALID: je,
  DIRTY: Da,
  OK: mn,
  isAborted: Lh,
  isDirty: Fh,
  isValid: $s,
  isAsync: Os,
  get util() {
    return et;
  },
  get objectUtil() {
    return Mh;
  },
  ZodParsedType: ye,
  getParsedType: hi,
  ZodType: qe,
  datetimeRegex: Rk,
  ZodString: rr,
  ZodNumber: $i,
  ZodBigInt: Oi,
  ZodBoolean: Ts,
  ZodDate: ia,
  ZodSymbol: pu,
  ZodUndefined: Cs,
  ZodNull: Rs,
  ZodAny: no,
  ZodUnknown: Ji,
  ZodNever: Qr,
  ZodVoid: hu,
  ZodArray: sr,
  ZodObject: kt,
  ZodUnion: Is,
  ZodDiscriminatedUnion: lf,
  ZodIntersection: As,
  ZodTuple: Ar,
  ZodRecord: Ps,
  ZodMap: mu,
  ZodSet: aa,
  ZodFunction: Ua,
  ZodLazy: js,
  ZodLiteral: Ns,
  ZodEnum: Ti,
  ZodNativeEnum: Ds,
  ZodPromise: ro,
  ZodEffects: ur,
  ZodTransformer: ur,
  ZodOptional: Tr,
  ZodNullable: Ci,
  ZodDefault: Ms,
  ZodCatch: Ls,
  ZodNaN: vu,
  BRAND: $B,
  ZodBranded: jv,
  ZodPipeline: sl,
  ZodReadonly: Fs,
  custom: Ak,
  Schema: qe,
  ZodSchema: qe,
  late: OB,
  get ZodFirstPartyTypeKind() {
    return Pe;
  },
  coerce: l4,
  any: NB,
  array: FB,
  bigint: RB,
  boolean: Nk,
  date: IB,
  discriminatedUnion: qB,
  effect: hx,
  enum: XB,
  function: GB,
  instanceof: TB,
  intersection: WB,
  lazy: YB,
  literal: JB,
  map: ZB,
  nan: CB,
  nativeEnum: QB,
  never: MB,
  null: jB,
  nullable: n4,
  number: jk,
  object: BB,
  oboolean: s4,
  onumber: o4,
  optional: t4,
  ostring: a4,
  pipeline: i4,
  preprocess: r4,
  promise: e4,
  record: VB,
  set: KB,
  strictObject: zB,
  string: Pk,
  symbol: AB,
  transformer: hx,
  tuple: HB,
  undefined: PB,
  union: UB,
  unknown: DB,
  void: LB,
  NEVER: c4,
  ZodIssueCode: ne,
  quotelessJson: lB,
  ZodError: In
}), u4 = Object.defineProperty, f4 = (e, t, n) => t in e ? u4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, d4 = (e, t, n) => (f4(e, t + "", n), n), p4 = {
  getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256)))
}, zh = typeof window < "u" && typeof window.document < "u" ? window.crypto : ak;
zh.getRandomValues || (zh = p4);
var wt = class extends Error {
  constructor(t, n, r, i, a, o) {
    super(i);
    Se(this, "isApiError", !0);
    this.code = t, this.description = n, this.type = r, this.message = i, this.error = a, this.id = o, this.id || (this.id = wt.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const t = this.getPrefix(), n = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], r = 4, i = Array.from(zh.getRandomValues(new Uint8Array(r))).map((a) => a.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${t}_${n}x${i}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}, h4 = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, Uh = (e) => e instanceof wt || h4(e) && e.isApiError === !0, Bs = class extends wt {
  constructor(e, t, n) {
    super(500, "An unknown error occurred", "Unknown", e, t, n);
  }
}, m4 = class extends wt {
  constructor(e, t, n) {
    super(500, "An internal error occurred", "Internal", e, t, n);
  }
}, v4 = class extends wt {
  constructor(e, t, n) {
    super(401, "The request requires to be authenticated.", "Unauthorized", e, t, n);
  }
}, g4 = class extends wt {
  constructor(e, t, n) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", e, t, n);
  }
}, y4 = class extends wt {
  constructor(e, t, n) {
    super(413, "The request payload is too large.", "PayloadTooLarge", e, t, n);
  }
}, b4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The request payload is invalid.", "InvalidPayload", e, t, n);
  }
}, x4 = class extends wt {
  constructor(e, t, n) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", e, t, n);
  }
}, w4 = class extends wt {
  constructor(e, t, n) {
    super(405, "The requested method does not exist.", "MethodNotFound", e, t, n);
  }
}, S4 = class extends wt {
  constructor(e, t, n) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", e, t, n);
  }
}, E4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", e, t, n);
  }
}, _4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", e, t, n);
  }
}, k4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", e, t, n);
  }
}, $4 = class extends wt {
  constructor(e, t, n) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", e, t, n);
  }
}, O4 = class extends wt {
  constructor(e, t, n) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", e, t, n);
  }
}, T4 = class extends wt {
  constructor(e, t, n) {
    super(409, "The resource is current locked and cannot be operated on until the lock is released.", "ResourceLockedConflict", e, t, n);
  }
}, C4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", e, t, n);
  }
}, R4 = class extends wt {
  constructor(e, t, n) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", e, t, n);
  }
}, I4 = class extends wt {
  constructor(e, t, n) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", e, t, n);
  }
}, A4 = class extends wt {
  constructor(e, t, n) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", e, t, n);
  }
}, P4 = class extends wt {
  constructor(e, t, n) {
    super(429, "The request has been rate limited.", "RateLimited", e, t, n);
  }
}, j4 = class extends wt {
  constructor(e, t, n) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", e, t, n);
  }
}, N4 = class extends wt {
  constructor(e, t, n) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", e, t, n);
  }
}, D4 = class extends wt {
  constructor(e, t, n) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", e, t, n);
  }
}, M4 = class extends wt {
  constructor(e, t, n) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", e, t, n);
  }
}, L4 = {
  Unknown: Bs,
  Internal: m4,
  Unauthorized: v4,
  Forbidden: g4,
  PayloadTooLarge: y4,
  InvalidPayload: b4,
  UnsupportedMediaType: x4,
  MethodNotFound: w4,
  ResourceNotFound: S4,
  InvalidJsonSchema: E4,
  InvalidDataFormat: _4,
  InvalidIdentifier: k4,
  RelationConflict: $4,
  ReferenceConstraint: O4,
  ResourceLockedConflict: T4,
  ReferenceNotFound: C4,
  InvalidQuery: R4,
  Runtime: I4,
  AlreadyExists: A4,
  RateLimited: P4,
  PaymentRequired: j4,
  QuotaExceeded: N4,
  LimitExceeded: D4,
  BreakingChanges: M4
}, mx = (e) => Uh(e) ? e : e instanceof Error ? new Bs(e.message, e) : typeof e == "string" ? new Bs(e) : F4(e);
function F4(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    const t = L4[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN") : new Bs(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new Bs("An invalid error occurred: " + JSON.stringify(e));
}
var B4 = (e) => e[1] !== void 0, Nt = (e) => {
  const { method: t, path: n, query: r, headers: i, body: a } = e, o = Object.entries(i).filter(B4), s = Object.fromEntries(o), l = aB.stringify(r, { encode: !0, arrayFormat: "repeat", allowDots: !0 }), c = l ? [n, l].join("?") : n;
  return {
    method: t,
    url: c,
    headers: s,
    data: a
  };
}, z4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), U4 = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { _: e._ }
}), q4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), W4 = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: {},
  body: {}
}), H4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/listen`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), V4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/messages`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), Z4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: { userId: e.userId }
}), K4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), G4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), Y4 = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), J4 = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), X4 = (e) => ({
  path: "/messages",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId, metadata: e.metadata }
}), Q4 = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), ez = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), tz = (e) => ({
  path: "/users",
  headers: {},
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), nz = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), rz = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), iz = (e) => ({
  path: `/events/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), az = (e) => ({
  path: "/events",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId, bindConversation: e.bindConversation, bindUser: e.bindUser }
}), oz = (e) => ({
  path: "/files",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { key: e.key, size: e.size, accessPolicies: e.accessPolicies, index: e.index, contentType: e.contentType, tags: e.tags }
}), sz = class {
  constructor(e, t = {}) {
    Se(this, "getConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = z4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "createConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = U4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "deleteConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = q4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "listConversations", async (e) => {
      const { path: t, headers: n, query: r, body: i } = W4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "listenConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = H4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "listConversationMessages", async (e) => {
      const { path: t, headers: n, query: r, body: i } = V4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "addParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Z4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "removeParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = K4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "getParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = G4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "listParticipants", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Y4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "getMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = J4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "createMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = X4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "deleteMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Q4(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "getUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = ez(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "createUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = tz(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "updateUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = nz(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "put",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "deleteUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = rz(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "getEvent", async (e) => {
      const { path: t, headers: n, query: r, body: i } = iz(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "createEvent", async (e) => {
      const { path: t, headers: n, query: r, body: i } = az(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    Se(this, "createFile", async (e) => {
      const { path: t, headers: n, query: r, body: i } = oz(e), o = (this.props.toAxiosRequest ?? Nt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Dt(s);
      });
    });
    this.axiosInstance = e, this.props = t;
  }
};
function Dt(e) {
  var t;
  return Ft.isAxiosError(e) && ((t = e.response) != null && t.data) ? mx(e.response.data) : mx(e);
}
var Dk = class {
  constructor() {
    Se(this, "listeners", {});
  }
  emit(e, t) {
    const n = this.listeners[e];
    if (n)
      for (const r of [...n])
        r(t);
  }
  onceOrMore(e, t) {
    const n = (r) => {
      t(r) === "stop-listening" && this.off(e, n);
    };
    this.on(e, n);
  }
  once(e, t) {
    const n = (r) => {
      this.off(e, n), t(r);
    };
    this.on(e, n);
  }
  on(e, t) {
    this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t);
  }
  off(e, t) {
    const n = this.listeners[e];
    if (!n)
      return;
    const r = n.indexOf(t);
    r !== -1 && n.splice(r, 1);
  }
  cleanup() {
    this.listeners = {};
  }
}, lz = (e, t) => {
  const n = new sB.EventSourcePolyfill(e, {
    headers: t.headers,
    heartbeatTimeout: t.timeout
  }), r = new Dk();
  return n.onopen = (i) => r.emit("open", i), n.onmessage = (i) => r.emit("message", i), n.onerror = (i) => r.emit("error", i), {
    emitter: r,
    source: n
  };
}, cz = async (e, t = {}) => {
  const { emitter: n, source: r } = lz(e, t);
  return await new Promise((i, a) => {
    n.on("open", () => {
      i();
    }), n.on("error", (o) => {
      a(o);
    });
  }).finally(() => n.cleanup()), {
    on: n.on.bind(n),
    close: () => {
      n.cleanup(), r.close();
    }
  };
}, uz = H.object({
  type: H.literal("message_created"),
  data: H.object({
    id: H.string().describe("Id of the [Message](#schema_message)"),
    createdAt: H.string().datetime().describe(
      "Creation date of the [Message](#schema_message) in ISO 8601 format"
    ),
    payload: H.union([
      H.object({ audioUrl: H.string().min(1), type: H.literal("audio") }),
      H.object({
        title: H.string().min(1),
        subtitle: H.string().min(1).optional(),
        imageUrl: H.string().min(1).optional(),
        actions: H.array(
          H.object({
            action: H.enum(["postback", "url", "say"]),
            label: H.string().min(1),
            value: H.string().min(1)
          })
        ),
        type: H.literal("card")
      }),
      H.object({
        items: H.array(
          H.object({
            title: H.string().min(1),
            subtitle: H.string().min(1).optional(),
            imageUrl: H.string().min(1).optional(),
            actions: H.array(
              H.object({
                action: H.enum(["postback", "url", "say"]),
                label: H.string().min(1),
                value: H.string().min(1)
              })
            )
          })
        ),
        type: H.literal("carousel")
      }),
      H.object({
        text: H.string().min(1),
        options: H.array(
          H.object({ label: H.string().min(1), value: H.string().min(1) })
        ),
        type: H.literal("choice"),
        disableFreeText: H.boolean().optional()
      }),
      H.object({
        text: H.string().min(1),
        options: H.array(
          H.object({ label: H.string().min(1), value: H.string().min(1) })
        ),
        type: H.literal("dropdown")
      }),
      H.object({
        fileUrl: H.string().min(1),
        title: H.string().min(1).optional(),
        type: H.literal("file")
      }),
      H.object({ imageUrl: H.string().min(1), type: H.literal("image") }),
      H.object({
        latitude: H.number(),
        longitude: H.number(),
        address: H.string().optional(),
        title: H.string().optional(),
        type: H.literal("location")
      }),
      H.object({
        text: H.string().min(1),
        type: H.literal("text"),
        value: H.string().optional()
      }),
      H.object({ videoUrl: H.string().min(1), type: H.literal("video") }),
      H.object({
        items: H.array(
          H.union([
            H.object({
              type: H.literal("text"),
              payload: H.object({ text: H.string().min(1) })
            }),
            H.object({
              type: H.literal("markdown"),
              payload: H.object({ markdown: H.string().min(1) })
            }),
            H.object({
              type: H.literal("image"),
              payload: H.object({ imageUrl: H.string().min(1) })
            }),
            H.object({
              type: H.literal("audio"),
              payload: H.object({ audioUrl: H.string().min(1) })
            }),
            H.object({
              type: H.literal("video"),
              payload: H.object({ videoUrl: H.string().min(1) })
            }),
            H.object({
              type: H.literal("file"),
              payload: H.object({
                fileUrl: H.string().min(1),
                title: H.string().min(1).optional()
              })
            }),
            H.object({
              type: H.literal("location"),
              payload: H.object({
                latitude: H.number(),
                longitude: H.number(),
                address: H.string().optional(),
                title: H.string().optional()
              })
            })
          ])
        ),
        type: H.literal("bloc")
      }),
      H.object({
        markdown: H.string().min(1),
        type: H.literal("markdown")
      })
    ]).describe("Payload is the content type of the message."),
    userId: H.string().describe("ID of the [User](#schema_user)"),
    conversationId: H.string().describe("ID of the [Conversation](#schema_conversation)"),
    metadata: H.record(H.union([H.any(), H.null()])).describe("Metadata of the message").optional()
  }).describe(
    "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user)."
  )
}), fz = H.object({
  type: H.literal("webchat_visibility"),
  data: H.object({
    visibility: H.union([
      H.literal("show"),
      H.literal("hide"),
      H.literal("toggle")
    ])
  })
}), dz = H.object({
  type: H.literal("webchat_config"),
  data: H.object({ config: H.record(H.union([H.any(), H.null()])) })
}), pz = H.object({
  type: H.literal("custom"),
  data: H.object({ event: H.record(H.union([H.any(), H.null()])) })
}), hz = H.object({
  type: H.literal("typing_started"),
  data: H.object({ timeout: H.number().optional() })
}), mz = H.object({ type: H.literal("typing_stopped"), data: H.record(H.never()) }), vz = {
  messageCreated: uz,
  webchatVisibility: fz,
  webchatConfig: dz,
  custom: pz,
  typingStarted: hz,
  typingStopped: mz
}, vx = "unknown error", Mk = class extends Dk {
  constructor(t) {
    super();
    Se(this, "_state", { status: "disconnected" });
    Se(this, "connect", async () => {
      if (this._state.status === "connected")
        return;
      if (this._state.status === "connecting") {
        await this._state.connectionPromise;
        return;
      }
      const t = this._connect();
      this._state = { status: "connecting", connectionPromise: t }, await t;
    });
    Se(this, "disconnect", async () => {
      if (this._state.status === "disconnected")
        return;
      let t;
      this._state.status === "connecting" ? t = await this._state.connectionPromise : t = this._state.source, this._disconnectSync(t);
    });
    Se(this, "_connect", async () => {
      const t = await cz(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
        headers: { "x-user-key": this._props.userKey },
        timeout: this._props.timeout
      });
      return t.on("message", this._handleMessage), t.on("error", this._handleError(t)), this._state = { status: "connected", source: t }, t;
    });
    Se(this, "_disconnectSync", (t) => {
      t.close(), this._state = { status: "disconnected" };
    });
    Se(this, "_handleMessage", (t) => {
      const n = this._parseSignal(t.data);
      this.emit(n.type, n.data);
    });
    Se(this, "_handleError", (t) => (n) => {
      this._disconnectSync(t);
      const r = this._toError(n);
      this.emit("error", r);
    });
    Se(this, "_parseSignal", (t) => {
      for (const n of Object.values(vz)) {
        const r = this._safeJsonParse(t), i = n.safeParse(r);
        if (i.success)
          return i.data;
      }
      return {
        type: "unknown",
        data: t
      };
    });
    Se(this, "_safeJsonParse", (t) => {
      try {
        return JSON.parse(t);
      } catch {
        return t;
      }
    });
    Se(this, "_toError", (t) => {
      if (t instanceof Error)
        return t;
      if (typeof t == "string")
        return new Error(t);
      if (t === null)
        return new Error(vx);
      if (typeof t == "object" && "message" in t)
        return this._toError(t.message);
      try {
        const n = JSON.stringify(t);
        return new Error(n);
      } catch {
        return new Error(vx);
      }
    });
    this._props = t;
  }
  get status() {
    return this._state.status;
  }
}, Lk = Mk;
d4(Lk, "listen", async (e) => {
  const t = new Mk(e);
  return await t.connect(), t;
});
var Fk = 100 * 1024 * 1024, gz = Fk, yz = Fk, bz = 6e4, xz = class {
  constructor(e) {
    Se(this, "_auto");
    Se(this, "createConversation", (e) => this._auto.createConversation(e));
    Se(this, "getConversation", (e) => this._auto.getConversation(e));
    Se(this, "deleteConversation", (e) => this._auto.deleteConversation(e));
    Se(this, "listConversations", (e) => this._auto.listConversations(e));
    Se(this, "listConversationMessages", (e) => this._auto.listConversationMessages(e));
    Se(this, "addParticipant", (e) => this._auto.addParticipant(e));
    Se(this, "removeParticipant", (e) => this._auto.removeParticipant(e));
    Se(this, "getParticipant", (e) => this._auto.getParticipant(e));
    Se(this, "listParticipants", (e) => this._auto.listParticipants(e));
    Se(this, "createMessage", (e) => this._auto.createMessage(e));
    Se(this, "getMessage", (e) => this._auto.getMessage(e));
    Se(this, "deleteMessage", (e) => this._auto.deleteMessage(e));
    Se(this, "createFile", (e) => this._auto.createFile(e));
    Se(this, "createUser", (e) => this._auto.createUser(e));
    Se(this, "getUser", (e) => this._auto.getUser(e));
    Se(this, "updateUser", (e) => this._auto.updateUser(e));
    Se(this, "deleteUser", (e) => this._auto.deleteUser(e));
    Se(this, "createEvent", (e) => this._auto.createEvent(e));
    Se(this, "getEvent", (e) => this._auto.getEvent(e));
    Se(this, "listenConversation", async ({
      id: e,
      "x-user-key": t
    }) => await Lk.listen({
      url: this.props.apiUrl,
      conversationId: e,
      userKey: t,
      timeout: this.props.sseTimeout
    }));
    this.props = e;
    const { apiUrl: t } = e, n = {
      ...e.headers
    }, r = this.props.timeout ?? bz, i = Ft.create({
      baseURL: t,
      headers: n,
      withCredentials: !0,
      timeout: r,
      maxBodyLength: gz,
      maxContentLength: yz
    });
    this._auto = new sz(i);
  }
};
const gu = {
  disconnected: 0,
  user_creating: 1,
  user_created: 2,
  conversation_creating: 3,
  conversation_created: 4
}, yn = (e, t) => e.status === t, gr = (e, t) => gu[e.status] < gu[t], gx = (e, t) => gu[e.status] >= gu[t];
class yr extends Error {
  constructor(t) {
    super(`Unexpected state: ${t.status}`), this.state = t;
  }
}
const wz = ["audio", "file", "image", "video"], Sz = (e) => wz.includes(e), Bk = { "application/prs.cww": ["cww"], "application/prs.xsf+xml": ["xsf"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["*xfdf"], "application/vnd.age": ["age"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["*fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["*mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.pwg-xhtml-print+xml": ["xhtm"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml", "uo"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["*prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["*sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["*aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif", "btf"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.cld": ["cld"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.pytha.pyox": ["pyo", "pyox"], "model/vnd.sap.vds": ["vds"], "model/vnd.usda": ["usda"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.familysearch.gedcom": ["ged"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
Object.freeze(Bk);
const zk = { "application/andrew-inset": ["ez"], "application/appinstaller": ["appinstaller"], "application/applixware": ["aw"], "application/appx": ["appx"], "application/appxbundle": ["appxbundle"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/automationml-aml+xml": ["aml"], "application/automationml-amlx+zip": ["amlx"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cpl+xml": ["cpl"], "application/cu-seeme": ["cu"], "application/cwl": ["cwl"], "application/dash+xml": ["mpd"], "application/dash-patch+xml": ["mpp"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdf": ["fdf"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["*js"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/media-policy-dataset+xml": ["mpf"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"], "application/msix": ["msix"], "application/msixbundle": ["msixbundle"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-keys": ["asc"], "application/pgp-signature": ["sig", "*asc"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/sql": ["sql"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/watcherinfo+xml": ["wif"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xfdf": ["xfdf"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/aac": ["adts", "aac"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avci": ["avci"], "image/avcs": ["avcs"], "image/avif": ["avif"], "image/bmp": ["bmp", "dib"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/dpx": ["dpx"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm", "jpgm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/jt": ["jt"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/prc": ["prc"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/u3d": ["u3d"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/javascript": ["js", "mjs"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["md", "markdown"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/wgsl": ["wgsl"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "*jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
Object.freeze(zk);
var Fn = function(e, t, n, r) {
  if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
}, Na, Jo, Wi;
class Ez {
  constructor(...t) {
    Na.set(this, /* @__PURE__ */ new Map()), Jo.set(this, /* @__PURE__ */ new Map()), Wi.set(this, /* @__PURE__ */ new Map());
    for (const n of t)
      this.define(n);
  }
  define(t, n = !1) {
    for (let [r, i] of Object.entries(t)) {
      r = r.toLowerCase(), i = i.map((s) => s.toLowerCase()), Fn(this, Wi, "f").has(r) || Fn(this, Wi, "f").set(r, /* @__PURE__ */ new Set());
      const a = Fn(this, Wi, "f").get(r);
      let o = !0;
      for (let s of i) {
        const l = s.startsWith("*");
        if (s = l ? s.slice(1) : s, a == null || a.add(s), o && Fn(this, Jo, "f").set(r, s), o = !1, l)
          continue;
        const c = Fn(this, Na, "f").get(s);
        if (c && c != r && !n)
          throw new Error(`"${r} -> ${s}" conflicts with "${c} -> ${s}". Pass \`force=true\` to override this definition.`);
        Fn(this, Na, "f").set(s, r);
      }
    }
    return this;
  }
  getType(t) {
    if (typeof t != "string")
      return null;
    const n = t.replace(/^.*[/\\]/, "").toLowerCase(), r = n.replace(/^.*\./, "").toLowerCase(), i = n.length < t.length;
    return !(r.length < n.length - 1) && i ? null : Fn(this, Na, "f").get(r) ?? null;
  }
  getExtension(t) {
    var n;
    return typeof t != "string" ? null : (t = (n = t == null ? void 0 : t.split) == null ? void 0 : n.call(t, ";")[0], (t && Fn(this, Jo, "f").get(t.trim().toLowerCase())) ?? null);
  }
  getAllExtensions(t) {
    return typeof t != "string" ? null : Fn(this, Wi, "f").get(t.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
    }, Object.freeze(this);
    for (const t of Fn(this, Wi, "f").values())
      Object.freeze(t);
    return this;
  }
  _getTestState() {
    return {
      types: Fn(this, Na, "f"),
      extensions: Fn(this, Jo, "f")
    };
  }
}
Na = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap();
const _z = new Ez(zk, Bk)._freeze(), kz = 6e4;
class $z extends uE {
  constructor(n) {
    super();
    Se(this, "_client");
    Se(this, "_webhookId");
    Se(this, "_apiUrl");
    Se(this, "_state", { status: "disconnected" });
    Se(this, "mode", "pushpin");
    Se(this, "_initialConnect", async ({ data: n, name: r, pictureUrl: i }) => {
      if (gx(this._state, "user_created"))
        throw new Error("Client is already connected. Please disconnect first.");
      if (yn(this._state, "user_creating"))
        return;
      this._state = {
        status: "user_creating"
      };
      const {
        user: { id: a },
        key: o
      } = await this._client.createUser({
        name: r,
        pictureUrl: i,
        userData: n
      });
      return this._state = {
        status: "user_created",
        userId: a,
        userKey: o
      }, {
        userId: a,
        userToken: o
      };
    });
    Se(this, "_reConnect", async (n, { data: r, name: i, pictureUrl: a }) => {
      if (gx(this._state, "user_created")) {
        if (this._state.userId !== n.userId)
          throw new Error("Client is already connected. Please disconnect first.");
        return n;
      }
      return yn(this._state, "user_creating") || (this._state = {
        status: "user_created",
        userId: n.userId,
        userKey: n.userToken
      }, await this._client.updateUser({
        "x-user-key": n.userToken,
        name: i,
        pictureUrl: a,
        userData: r
      })), n;
    });
    Se(this, "_mapMessage", (n) => {
      const { metadata: r } = n, { payload: i, disableInput: a } = cs(n.payload);
      return {
        id: n.id,
        conversationId: n.conversationId,
        authorId: n.userId,
        sentOn: new Date(n.createdAt),
        payload: i,
        disableInput: a,
        metadata: r
      };
    });
    const r = `${n.apiUrl}/${n.clientId}`;
    this._webhookId = n.clientId, this._apiUrl = r, this._client = new xz({
      apiUrl: r,
      sseTimeout: kz
    });
  }
  get apiUrl() {
    return this._apiUrl;
  }
  get clientId() {
    return this._webhookId;
  }
  get userId() {
    if (!gr(this._state, "user_created"))
      return this._state.userId;
  }
  async getUser() {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    const { user: n } = await this._client.getUser({ "x-user-key": this._state.userKey });
    return { data: n.data };
  }
  async updateUser(n) {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    const { user: r } = await this._client.updateUser({
      "x-user-key": this._state.userKey,
      name: n.name,
      pictureUrl: n.pictureUrl,
      userData: n.data
    });
    return r;
  }
  get conversationId() {
    if (!gr(this._state, "conversation_created"))
      return this._state.conversationId;
  }
  async connect(n, r, i = {}) {
    const a = { data: r, ...i };
    return n ? await this.userExists(n) ? this._reConnect(n, a) : this._initialConnect(a) : this._initialConnect(a);
  }
  async disconnect() {
    yn(this._state, "conversation_created") ? this._state.signalEmitter.cleanup() : yn(this._state, "conversation_creating") && console.warn("zombie conversation..."), this._state = { status: "disconnected" };
  }
  async sendFile(n) {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    if (yn(this._state, "conversation_creating"))
      throw new yr(this._state);
    let r;
    yn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state));
    const { size: i, name: a } = n, o = _z.getType(n.name) ?? "application/octet-stream", l = await ((h) => new Promise((m, y) => {
      const v = new FileReader();
      v.onload = (g) => {
        var b;
        return m((b = g.target) == null ? void 0 : b.result);
      }, v.onerror = (g) => {
        var b;
        return y((b = g.target) == null ? void 0 : b.error);
      }, v.readAsArrayBuffer(h);
    }))(n), {
      file: { uploadUrl: c, url: u }
    } = await this._client.createFile({
      "x-user-key": r.userKey,
      size: i,
      key: a,
      contentType: o,
      accessPolicies: ["public_content"],
      index: !1,
      tags: { source: "integration", integrationName: "webchat" }
    });
    await fetch(c, {
      method: "PUT",
      headers: {
        "x-amz-tagging": "public=true"
      },
      body: l
    });
    const f = o.split("/").shift() ?? "", d = Sz(f) ? f : "file", p = d === "image" ? { type: d, imageUrl: u } : d === "audio" ? { type: d, audioUrl: u } : d === "video" ? { type: d, videoUrl: u } : { type: d, fileUrl: u };
    return await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: p
    }), { fileUrl: u, name: a, type: d };
  }
  async sendMessage(n) {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    if (yn(this._state, "conversation_creating"))
      throw new yr(this._state);
    let r;
    yn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: n
    }), this.emit("messageSent", n);
  }
  async sendEvent(n) {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    if (yn(this._state, "conversation_creating"))
      throw new yr(this._state);
    let r;
    yn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createEvent({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "custom",
        data: n
      }
    });
  }
  async switchConversation(n) {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    yn(this._state, "conversation_created") && this._state.conversationId === n || yn(this._state, "conversation_creating") || (this._state = {
      status: "conversation_creating",
      userId: this._state.userId,
      userKey: this._state.userKey
    }, await this._connectConversation(this._state, n));
  }
  async conversationExists(n) {
    if (gr(this._state, "user_created"))
      return !1;
    try {
      return await this._client.getConversation({
        "x-user-key": this._state.userKey,
        id: n
      }), !0;
    } catch (r) {
      if (Uh(r) && r.code === 404)
        return !1;
      throw r;
    }
  }
  async userExists({ userToken: n }) {
    try {
      return await this._client.getUser({
        "x-user-key": n
      }), !0;
    } catch (r) {
      const i = (a) => a.code === 404 || a.code === 401;
      if (Uh(r) && i(r))
        return !1;
      throw r;
    }
  }
  async newConversation() {
    if (gr(this._state, "user_created"))
      throw new yr(this._state);
    yn(this._state, "conversation_creating") || (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, await this._createNewConversation(this._state));
  }
  async _createNewConversation(n) {
    const {
      conversation: { id: r }
    } = await this._client.createConversation({ "x-user-key": n.userKey }), i = await this._connectConversation(n, r);
    return await this._client.createEvent({
      "x-user-key": n.userKey,
      conversationId: r,
      payload: { type: "conversation_started", data: {} }
    }), i;
  }
  async listMessages() {
    if (!yn(this._state, "conversation_created"))
      return [];
    const { conversationId: n, userKey: r } = this._state, i = [];
    let a;
    do {
      const o = await this._client.listConversationMessages({ id: n, "x-user-key": r, nextToken: a });
      i.push(...o.messages), a = o.meta.nextToken;
    } while (a);
    return i.map(this._mapMessage);
  }
  async _connectConversation(n, r) {
    const i = await this._client.listenConversation({ id: r, "x-user-key": n.userKey });
    return i.on("unknown", (a) => {
      typeof a == "string" && a === "ping" || console.debug("unknown event", a);
    }), i.on("message_created", (a) => {
      a.userId !== n.userId && this.emit("message", this._mapMessage(a));
    }), i.on("error", (a) => {
      this._state = { status: "user_created", userId: n.userId, userKey: n.userKey }, this.emit("error", new Error(`Connection to conversation lost: ${a.message}`));
    }), i.on("webchat_visibility", (a) => {
      this.emit("webchatVisibility", a.visibility);
    }), i.on("webchat_config", (a) => {
      this.emit("webchatConfig", a.config);
    }), i.on("typing_started", (a) => {
      this.emit("isTyping", { isTyping: !0, timeout: a.timeout ?? 5e3 });
    }), i.on("typing_stopped", () => {
      this.emit("isTyping", { isTyping: !1, timeout: 0 });
    }), i.on("custom", (a) => {
      this.emit("customEvent", a.event);
    }), this.emit("conversation", r), this._state = {
      status: "conversation_created",
      userId: n.userId,
      userKey: n.userKey,
      conversationId: r,
      signalEmitter: i
    }, this._state;
  }
}
const Oz = ({ clientId: e, apiUrl: t = "https://webchat.botpress.cloud" }) => new $z({
  apiUrl: t,
  clientId: e
}), che = ({ clientId: e, apiUrl: t = "https://webchat.botpress.cloud" }) => {
  const [n] = ht(Oz({ clientId: e, apiUrl: t }));
  return n;
}, Tz = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const a = new Image();
  a.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: a.naturalWidth, height: a.naturalHeight });
  }), a.addEventListener("error", (o) => {
    i && clearTimeout(i), r(`${o.type}: ${o.message}`);
  }), a.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
});
let Cz = { data: "" }, Rz = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Cz, Iz = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Az = /\/\*[^]*?\*\/|  +/g, yx = /\n+/g, mi = (e, t) => {
  let n = "", r = "", i = "";
  for (let a in e) {
    let o = e[a];
    a[0] == "@" ? a[1] == "i" ? n = a + " " + o + ";" : r += a[1] == "f" ? mi(o, a) : a + "{" + mi(o, a[1] == "k" ? "" : t) + "}" : typeof o == "object" ? r += mi(o, t ? t.replace(/([^,])+/g, (s) => a.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : a) : o != null && (a = /^--/.test(a) ? a : a.replace(/[A-Z]/g, "-$&").toLowerCase(), i += mi.p ? mi.p(a, o) : a + ":" + o + ";");
  }
  return n + (t && i ? t + "{" + i + "}" : i) + r;
}, Wr = {}, Uk = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Uk(e[n]);
    return t;
  }
  return e;
}, Pz = (e, t, n, r, i) => {
  let a = Uk(e), o = Wr[a] || (Wr[a] = ((l) => {
    let c = 0, u = 11;
    for (; c < l.length; ) u = 101 * u + l.charCodeAt(c++) >>> 0;
    return "go" + u;
  })(a));
  if (!Wr[o]) {
    let l = a !== e ? e : ((c) => {
      let u, f, d = [{}];
      for (; u = Iz.exec(c.replace(Az, "")); ) u[4] ? d.shift() : u[3] ? (f = u[3].replace(yx, " ").trim(), d.unshift(d[0][f] = d[0][f] || {})) : d[0][u[1]] = u[2].replace(yx, " ").trim();
      return d[0];
    })(e);
    Wr[o] = mi(i ? { ["@keyframes " + o]: l } : l, n ? "" : "." + o);
  }
  let s = n && Wr.g ? Wr.g : null;
  return n && (Wr.g = Wr[o]), ((l, c, u, f) => {
    f ? c.data = c.data.replace(f, l) : c.data.indexOf(l) === -1 && (c.data = u ? l + c.data : c.data + l);
  })(Wr[o], t, r, s), o;
}, jz = (e, t, n) => e.reduce((r, i, a) => {
  let o = t[a];
  if (o && o.call) {
    let s = o(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    o = l ? "." + l : s && typeof s == "object" ? s.props ? "" : mi(s, "") : s === !1 ? "" : s;
  }
  return r + i + (o ?? "");
}, "");
function cf(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Pz(n.unshift ? n.raw ? jz(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(t.p) : i), {}) : n, Rz(t.target), t.g, t.o, t.k);
}
let qk, qh, Wh;
cf.bind({ g: 1 });
let ei = cf.bind({ k: 1 });
function Nz(e, t, n, r) {
  mi.p = t, qk = e, qh = n, Wh = r;
}
function Li(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function i(a, o) {
      let s = Object.assign({}, a), l = s.className || i.className;
      n.p = Object.assign({ theme: qh && qh() }, s), n.o = / *go\d+/.test(l), s.className = cf.apply(n, r) + (l ? " " + l : "");
      let c = e;
      return e[0] && (c = s.as || e, delete s.as), Wh && c[0] && Wh(s), qk(c, s);
    }
    return i;
  };
}
var Dz = (e) => typeof e == "function", yu = (e, t) => Dz(e) ? e(t) : e, Mz = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), Wk = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Lz = 20, wc = /* @__PURE__ */ new Map(), Fz = 1e3, bx = (e) => {
  if (wc.has(e)) return;
  let t = setTimeout(() => {
    wc.delete(e), ua({ type: 4, toastId: e });
  }, Fz);
  wc.set(e, t);
}, Bz = (e) => {
  let t = wc.get(e);
  t && clearTimeout(t);
}, Hh = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Lz) };
    case 1:
      return t.toast.id && Bz(t.toast.id), { ...e, toasts: e.toasts.map((a) => a.id === t.toast.id ? { ...a, ...t.toast } : a) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((a) => a.id === n.id) ? Hh(e, { type: 1, toast: n }) : Hh(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? bx(r) : e.toasts.forEach((a) => {
        bx(a.id);
      }), { ...e, toasts: e.toasts.map((a) => a.id === r || r === void 0 ? { ...a, visible: !1 } : a) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((a) => a.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let i = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((a) => ({ ...a, pauseDuration: a.pauseDuration + i })) };
  }
}, Sc = [], Ec = { toasts: [], pausedAt: void 0 }, ua = (e) => {
  Ec = Hh(Ec, e), Sc.forEach((t) => {
    t(Ec);
  });
}, zz = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Uz = (e = {}) => {
  let [t, n] = ht(Ec);
  $t(() => (Sc.push(n), () => {
    let i = Sc.indexOf(n);
    i > -1 && Sc.splice(i, 1);
  }), [t]);
  let r = t.toasts.map((i) => {
    var a, o;
    return { ...e, ...e[i.type], ...i, duration: i.duration || ((a = e[i.type]) == null ? void 0 : a.duration) || (e == null ? void 0 : e.duration) || zz[i.type], style: { ...e.style, ...(o = e[i.type]) == null ? void 0 : o.style, ...i.style } };
  });
  return { ...t, toasts: r };
}, qz = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Mz() }), ll = (e) => (t, n) => {
  let r = qz(t, e, n);
  return ua({ type: 2, toast: r }), r.id;
}, qn = (e, t) => ll("blank")(e, t);
qn.error = ll("error");
qn.success = ll("success");
qn.loading = ll("loading");
qn.custom = ll("custom");
qn.dismiss = (e) => {
  ua({ type: 3, toastId: e });
};
qn.remove = (e) => ua({ type: 4, toastId: e });
qn.promise = (e, t, n) => {
  let r = qn.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((i) => (qn.success(yu(t.success, i), { id: r, ...n, ...n == null ? void 0 : n.success }), i)).catch((i) => {
    qn.error(yu(t.error, i), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var Wz = (e, t) => {
  ua({ type: 1, toast: { id: e, height: t } });
}, Hz = () => {
  ua({ type: 5, time: Date.now() });
}, Vz = (e) => {
  let { toasts: t, pausedAt: n } = Uz(e);
  $t(() => {
    if (n) return;
    let a = Date.now(), o = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (a - s.createdAt);
      if (l < 0) {
        s.visible && qn.dismiss(s.id);
        return;
      }
      return setTimeout(() => qn.dismiss(s.id), l);
    });
    return () => {
      o.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = Et(() => {
    n && ua({ type: 6, time: Date.now() });
  }, [n]), i = Et((a, o) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: c } = o || {}, u = t.filter((p) => (p.position || c) === (a.position || c) && p.height), f = u.findIndex((p) => p.id === a.id), d = u.filter((p, h) => h < f && p.visible).length;
    return u.filter((p) => p.visible).slice(...s ? [d + 1] : [0, d]).reduce((p, h) => p + (h.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: Wz, startPause: Hz, endPause: r, calculateOffset: i } };
}, Zz = ei`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Kz = ei`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Gz = ei`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Yz = Li("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Zz} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Kz} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Gz} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Jz = ei`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Xz = Li("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Jz} 1s linear infinite;
`, Qz = ei`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, e6 = ei`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, t6 = Li("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Qz} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${e6} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, n6 = Li("div")`
  position: absolute;
`, r6 = Li("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, i6 = ei`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, a6 = Li("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${i6} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, o6 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? w.createElement(a6, null, t) : t : n === "blank" ? null : w.createElement(r6, null, w.createElement(Xz, { ...r }), n !== "loading" && w.createElement(n6, null, n === "error" ? w.createElement(Yz, { ...r }) : w.createElement(t6, { ...r })));
}, s6 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, l6 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, c6 = "0%{opacity:0;} 100%{opacity:1;}", u6 = "0%{opacity:1;} 100%{opacity:0;}", f6 = Li("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, d6 = Li("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, p6 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, i] = Wk() ? [c6, u6] : [s6(n), l6(n)];
  return { animation: t ? `${ei(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ei(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, h6 = w.memo(({ toast: e, position: t, style: n, children: r }) => {
  let i = e.height ? p6(e.position || t || "top-center", e.visible) : { opacity: 0 }, a = w.createElement(o6, { toast: e }), o = w.createElement(d6, { ...e.ariaProps }, yu(e.message, e));
  return w.createElement(f6, { className: e.className, style: { ...i, ...n, ...e.style } }, typeof r == "function" ? r({ icon: a, message: o }) : w.createElement(w.Fragment, null, a, o));
});
Nz(w.createElement);
var m6 = ({ id: e, className: t, style: n, onHeightUpdate: r, children: i }) => {
  let a = w.useCallback((o) => {
    if (o) {
      let s = () => {
        let l = o.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(o, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return w.createElement("div", { ref: a, className: t, style: n }, i);
}, v6 = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Wk() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...i };
}, g6 = cf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, zl = 16, y6 = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: i, containerStyle: a, containerClassName: o }) => {
  let { toasts: s, handlers: l } = Vz(n);
  return w.createElement("div", { style: { position: "fixed", zIndex: 9999, top: zl, left: zl, right: zl, bottom: zl, pointerEvents: "none", ...a }, className: o, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((c) => {
    let u = c.position || t, f = l.calculateOffset(c, { reverseOrder: e, gutter: r, defaultPosition: t }), d = v6(u, f);
    return w.createElement(m6, { id: c.id, key: c.id, onHeightUpdate: l.updateHeight, className: c.visible ? g6 : "", style: d }, c.type === "custom" ? yu(c.message, c) : i ? i(c) : w.createElement(h6, { toast: c, position: u }));
  }));
};
function Hk(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = Hk(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Nv() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = Hk(e)) && (r && (r += " "), r += t);
  return r;
}
function uf() {
  return typeof window < "u";
}
function So(e) {
  return Vk(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function An(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Dr(e) {
  var t;
  return (t = (Vk(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Vk(e) {
  return uf() ? e instanceof Node || e instanceof An(e).Node : !1;
}
function fr(e) {
  return uf() ? e instanceof Element || e instanceof An(e).Element : !1;
}
function Pr(e) {
  return uf() ? e instanceof HTMLElement || e instanceof An(e).HTMLElement : !1;
}
function xx(e) {
  return !uf() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof An(e).ShadowRoot;
}
function cl(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = dr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function b6(e) {
  return ["table", "td", "th"].includes(So(e));
}
function ff(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Dv(e) {
  const t = Mv(), n = fr(e) ? dr(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function x6(e) {
  let t = Ri(e);
  for (; Pr(t) && !io(t); ) {
    if (Dv(t))
      return t;
    if (ff(t))
      return null;
    t = Ri(t);
  }
  return null;
}
function Mv() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function io(e) {
  return ["html", "body", "#document"].includes(So(e));
}
function dr(e) {
  return An(e).getComputedStyle(e);
}
function df(e) {
  return fr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Ri(e) {
  if (So(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    xx(e) && e.host || // Fallback.
    Dr(e)
  );
  return xx(t) ? t.host : t;
}
function Zk(e) {
  const t = Ri(e);
  return io(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Pr(t) && cl(t) ? t : Zk(t);
}
function bi(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = Zk(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = An(i);
  if (a) {
    const s = Vh(o);
    return t.concat(o, o.visualViewport || [], cl(i) ? i : [], s && n ? bi(s) : []);
  }
  return t.concat(i, bi(i, [], n));
}
function Vh(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
const ao = Math.min, Cn = Math.max, bu = Math.round, Ul = Math.floor, Ii = (e) => ({
  x: e,
  y: e
});
function wx(e, t, n) {
  return Cn(e, ao(t, n));
}
function pf(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ul(e) {
  return e.split("-")[0];
}
function Lv(e) {
  return e.split("-")[1];
}
function Kk(e) {
  return e === "x" ? "y" : "x";
}
function w6(e) {
  return e === "y" ? "height" : "width";
}
function fl(e) {
  return ["top", "bottom"].includes(ul(e)) ? "y" : "x";
}
function S6(e) {
  return Kk(fl(e));
}
function E6(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function _6(e) {
  return typeof e != "number" ? E6(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function xu(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var k6 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Zh = /* @__PURE__ */ k6.join(","), Gk = typeof Element > "u", zs = Gk ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, wu = !Gk && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, Su = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), a = i === "" || i === "true", o = a || n && t && e(t.parentNode);
  return o;
}, $6 = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, O6 = function(t, n, r) {
  if (Su(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(Zh));
  return n && zs.call(t, Zh) && i.unshift(t), i = i.filter(r), i;
}, T6 = function e(t, n, r) {
  for (var i = [], a = Array.from(t); a.length; ) {
    var o = a.shift();
    if (!Su(o, !1))
      if (o.tagName === "SLOT") {
        var s = o.assignedElements(), l = s.length ? s : o.children, c = e(l, !0, r);
        r.flatten ? i.push.apply(i, c) : i.push({
          scopeParent: o,
          candidates: c
        });
      } else {
        var u = zs.call(o, Zh);
        u && r.filter(o) && (n || !t.includes(o)) && i.push(o);
        var f = o.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(o), d = !Su(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(o));
        if (f && d) {
          var p = e(f === !0 ? o.children : f.children, !0, r);
          r.flatten ? i.push.apply(i, p) : i.push({
            scopeParent: o,
            candidates: p
          });
        } else
          a.unshift.apply(a, o.children);
      }
  }
  return i;
}, Yk = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, Jk = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || $6(t)) && !Yk(t) ? 0 : t.tabIndex;
}, C6 = function(t, n) {
  var r = Jk(t);
  return r < 0 && n && !Yk(t) ? 0 : r;
}, R6 = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, Xk = function(t) {
  return t.tagName === "INPUT";
}, I6 = function(t) {
  return Xk(t) && t.type === "hidden";
}, A6 = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, P6 = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, j6 = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || wu(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var a = P6(i, t.form);
  return !a || a === t;
}, N6 = function(t) {
  return Xk(t) && t.type === "radio";
}, D6 = function(t) {
  return N6(t) && !j6(t);
}, M6 = function(t) {
  var n, r = t && wu(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, a = !1;
  if (r && r !== t) {
    var o, s, l;
    for (a = !!((o = i) !== null && o !== void 0 && (s = o.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !a && i; ) {
      var c, u, f;
      r = wu(i), i = (c = r) === null || c === void 0 ? void 0 : c.host, a = !!((u = i) !== null && u !== void 0 && (f = u.ownerDocument) !== null && f !== void 0 && f.contains(i));
    }
  }
  return a;
}, Sx = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, L6 = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var a = zs.call(t, "details>summary:first-of-type"), o = a ? t.parentElement : t;
  if (zs.call(o, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var l = t.parentElement, c = wu(t);
        if (l && !l.shadowRoot && i(l) === !0)
          return Sx(t);
        t.assignedSlot ? t = t.assignedSlot : !l && c !== t.ownerDocument ? t = c.host : t = l;
      }
      t = s;
    }
    if (M6(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return Sx(t);
  return !1;
}, F6 = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return zs.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, B6 = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Su(n) || I6(n) || L6(n, t) || // For a details element with a summary, the summary element gets the focus
  A6(n) || F6(n));
}, Ex = function(t, n) {
  return !(D6(n) || Jk(n) < 0 || !B6(t, n));
}, z6 = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, U6 = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, a) {
    var o = !!i.scopeParent, s = o ? i.scopeParent : i, l = C6(s, o), c = o ? e(i.candidates) : s;
    l === 0 ? o ? n.push.apply(n, c) : n.push(s) : r.push({
      documentOrder: a,
      tabIndex: l,
      item: i,
      isScope: o,
      content: c
    });
  }), r.sort(R6).reduce(function(i, a) {
    return a.isScope ? i.push.apply(i, a.content) : i.push(a.content), i;
  }, []).concat(n);
}, Fv = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = T6([t], n.includeContainer, {
    filter: Ex.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: z6
  }) : r = O6(t, n.includeContainer, Ex.bind(null, n)), U6(r);
};
function _x(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const a = fl(t), o = S6(t), s = w6(o), l = ul(t), c = a === "y", u = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, d = r[s] / 2 - i[s] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      p = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y
      };
  }
  switch (Lv(t)) {
    case "start":
      p[o] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      p[o] += d * (n && c ? -1 : 1);
      break;
  }
  return p;
}
const q6 = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: o
  } = n, s = a.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: f
  } = _x(c, r, l), d = r, p = {}, h = 0;
  for (let m = 0; m < s.length; m++) {
    const {
      name: y,
      fn: v
    } = s[m], {
      x: g,
      y: b,
      data: k,
      reset: S
    } = await v({
      x: u,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: p,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = g ?? u, f = b ?? f, p = {
      ...p,
      [y]: {
        ...p[y],
        ...k
      }
    }, S && h <= 50 && (h++, typeof S == "object" && (S.placement && (d = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : S.rects), {
      x: u,
      y: f
    } = _x(c, d, l)), m = -1);
  }
  return {
    x: u,
    y: f,
    placement: d,
    strategy: i,
    middlewareData: p
  };
};
async function Qk(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: o,
    elements: s,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = pf(t, e), h = _6(p), y = s[d ? f === "floating" ? "reference" : "floating" : f], v = xu(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(y))) == null || n ? y : y.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), g = f === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, b = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), k = await (a.isElement == null ? void 0 : a.isElement(b)) ? await (a.getScale == null ? void 0 : a.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = xu(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: g,
    offsetParent: b,
    strategy: l
  }) : g);
  return {
    top: (v.top - S.top + h.top) / k.y,
    bottom: (S.bottom - v.bottom + h.bottom) / k.y,
    left: (v.left - S.left + h.left) / k.x,
    right: (S.right - v.right + h.right) / k.x
  };
}
async function W6(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = ul(n), s = Lv(n), l = fl(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = a && l ? -1 : 1, f = pf(t, e);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: h
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof h == "number" && (p = s === "end" ? h * -1 : h), l ? {
    x: p * u,
    y: d * c
  } : {
    x: d * c,
    y: p * u
  };
}
const H6 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: a,
        placement: o,
        middlewareData: s
      } = t, l = await W6(t, e);
      return o === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: a + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, V6 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: a = !0,
        crossAxis: o = !1,
        limiter: s = {
          fn: (y) => {
            let {
              x: v,
              y: g
            } = y;
            return {
              x: v,
              y: g
            };
          }
        },
        ...l
      } = pf(e, t), c = {
        x: n,
        y: r
      }, u = await Qk(t, l), f = fl(ul(i)), d = Kk(f);
      let p = c[d], h = c[f];
      if (a) {
        const y = d === "y" ? "top" : "left", v = d === "y" ? "bottom" : "right", g = p + u[y], b = p - u[v];
        p = wx(g, p, b);
      }
      if (o) {
        const y = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", g = h + u[y], b = h - u[v];
        h = wx(g, h, b);
      }
      const m = s.fn({
        ...t,
        [d]: p,
        [f]: h
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r,
          enabled: {
            [d]: a,
            [f]: o
          }
        }
      };
    }
  };
}, Z6 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: a,
        platform: o,
        elements: s
      } = t, {
        apply: l = () => {
        },
        ...c
      } = pf(e, t), u = await Qk(t, c), f = ul(i), d = Lv(i), p = fl(i) === "y", {
        width: h,
        height: m
      } = a.floating;
      let y, v;
      f === "top" || f === "bottom" ? (y = f, v = d === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (v = f, y = d === "end" ? "top" : "bottom");
      const g = m - u.top - u.bottom, b = h - u.left - u.right, k = ao(m - u[y], g), S = ao(h - u[v], b), _ = !t.middlewareData.shift;
      let $ = k, j = S;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (j = b), (r = t.middlewareData.shift) != null && r.enabled.y && ($ = g), _ && !d) {
        const O = Cn(u.left, 0), N = Cn(u.right, 0), q = Cn(u.top, 0), M = Cn(u.bottom, 0);
        p ? j = h - 2 * (O !== 0 || N !== 0 ? O + N : Cn(u.left, u.right)) : $ = m - 2 * (q !== 0 || M !== 0 ? q + M : Cn(u.top, u.bottom));
      }
      await l({
        ...t,
        availableWidth: j,
        availableHeight: $
      });
      const B = await o.getDimensions(s.floating);
      return h !== B.width || m !== B.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function e$(e) {
  const t = dr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Pr(e), a = i ? e.offsetWidth : n, o = i ? e.offsetHeight : r, s = bu(n) !== a || bu(r) !== o;
  return s && (n = a, r = o), {
    width: n,
    height: r,
    $: s
  };
}
function Bv(e) {
  return fr(e) ? e : e.contextElement;
}
function qa(e) {
  const t = Bv(e);
  if (!Pr(t))
    return Ii(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = e$(t);
  let o = (a ? bu(n.width) : n.width) / r, s = (a ? bu(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: o,
    y: s
  };
}
const K6 = /* @__PURE__ */ Ii(0);
function t$(e) {
  const t = An(e);
  return !Mv() || !t.visualViewport ? K6 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function G6(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== An(e) ? !1 : t;
}
function oa(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), a = Bv(e);
  let o = Ii(1);
  t && (r ? fr(r) && (o = qa(r)) : o = qa(e));
  const s = G6(a, n, r) ? t$(a) : Ii(0);
  let l = (i.left + s.x) / o.x, c = (i.top + s.y) / o.y, u = i.width / o.x, f = i.height / o.y;
  if (a) {
    const d = An(a), p = r && fr(r) ? An(r) : r;
    let h = d, m = Vh(h);
    for (; m && r && p !== h; ) {
      const y = qa(m), v = m.getBoundingClientRect(), g = dr(m), b = v.left + (m.clientLeft + parseFloat(g.paddingLeft)) * y.x, k = v.top + (m.clientTop + parseFloat(g.paddingTop)) * y.y;
      l *= y.x, c *= y.y, u *= y.x, f *= y.y, l += b, c += k, h = An(m), m = Vh(h);
    }
  }
  return xu({
    width: u,
    height: f,
    x: l,
    y: c
  });
}
function Y6(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const a = i === "fixed", o = Dr(r), s = t ? ff(t.floating) : !1;
  if (r === o || s && a)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Ii(1);
  const u = Ii(0), f = Pr(r);
  if ((f || !f && !a) && ((So(r) !== "body" || cl(o)) && (l = df(r)), Pr(r))) {
    const d = oa(r);
    c = qa(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y
  };
}
function J6(e) {
  return Array.from(e.getClientRects());
}
function Kh(e, t) {
  const n = df(e).scrollLeft;
  return t ? t.left + n : oa(Dr(e)).left + n;
}
function X6(e) {
  const t = Dr(e), n = df(e), r = e.ownerDocument.body, i = Cn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Cn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + Kh(e);
  const s = -n.scrollTop;
  return dr(r).direction === "rtl" && (o += Cn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: o,
    y: s
  };
}
function Q6(e, t) {
  const n = An(e), r = Dr(e), i = n.visualViewport;
  let a = r.clientWidth, o = r.clientHeight, s = 0, l = 0;
  if (i) {
    a = i.width, o = i.height;
    const c = Mv();
    (!c || c && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: a,
    height: o,
    x: s,
    y: l
  };
}
function eU(e, t) {
  const n = oa(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = Pr(e) ? qa(e) : Ii(1), o = e.clientWidth * a.x, s = e.clientHeight * a.y, l = i * a.x, c = r * a.y;
  return {
    width: o,
    height: s,
    x: l,
    y: c
  };
}
function kx(e, t, n) {
  let r;
  if (t === "viewport")
    r = Q6(e, n);
  else if (t === "document")
    r = X6(Dr(e));
  else if (fr(t))
    r = eU(t, n);
  else {
    const i = t$(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return xu(r);
}
function n$(e, t) {
  const n = Ri(e);
  return n === t || !fr(n) || io(n) ? !1 : dr(n).position === "fixed" || n$(n, t);
}
function tU(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = bi(e, [], !1).filter((s) => fr(s) && So(s) !== "body"), i = null;
  const a = dr(e).position === "fixed";
  let o = a ? Ri(e) : e;
  for (; fr(o) && !io(o); ) {
    const s = dr(o), l = Dv(o);
    !l && s.position === "fixed" && (i = null), (a ? !l && !i : !l && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || cl(o) && !l && n$(e, o)) ? r = r.filter((u) => u !== o) : i = s, o = Ri(o);
  }
  return t.set(e, r), r;
}
function nU(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? ff(t) ? [] : tU(t, this._c) : [].concat(n), r], s = o[0], l = o.reduce((c, u) => {
    const f = kx(t, u, i);
    return c.top = Cn(f.top, c.top), c.right = ao(f.right, c.right), c.bottom = ao(f.bottom, c.bottom), c.left = Cn(f.left, c.left), c;
  }, kx(t, s, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function rU(e) {
  const {
    width: t,
    height: n
  } = e$(e);
  return {
    width: t,
    height: n
  };
}
function iU(e, t, n) {
  const r = Pr(t), i = Dr(t), a = n === "fixed", o = oa(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ii(0);
  if (r || !r && !a)
    if ((So(t) !== "body" || cl(i)) && (s = df(t)), r) {
      const p = oa(t, !0, a, t);
      l.x = p.x + t.clientLeft, l.y = p.y + t.clientTop;
    } else i && (l.x = Kh(i));
  let c = 0, u = 0;
  if (i && !r && !a) {
    const p = i.getBoundingClientRect();
    u = p.top + s.scrollTop, c = p.left + s.scrollLeft - // RTL <body> scrollbar.
    Kh(i, p);
  }
  const f = o.left + s.scrollLeft - l.x - c, d = o.top + s.scrollTop - l.y - u;
  return {
    x: f,
    y: d,
    width: o.width,
    height: o.height
  };
}
function Od(e) {
  return dr(e).position === "static";
}
function $x(e, t) {
  if (!Pr(e) || dr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Dr(e) === n && (n = n.ownerDocument.body), n;
}
function r$(e, t) {
  const n = An(e);
  if (ff(e))
    return n;
  if (!Pr(e)) {
    let i = Ri(e);
    for (; i && !io(i); ) {
      if (fr(i) && !Od(i))
        return i;
      i = Ri(i);
    }
    return n;
  }
  let r = $x(e, t);
  for (; r && b6(r) && Od(r); )
    r = $x(r, t);
  return r && io(r) && Od(r) && !Dv(r) ? n : r || x6(e) || n;
}
const aU = async function(e) {
  const t = this.getOffsetParent || r$, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: iU(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function oU(e) {
  return dr(e).direction === "rtl";
}
const sU = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Y6,
  getDocumentElement: Dr,
  getClippingRect: nU,
  getOffsetParent: r$,
  getElementRects: aU,
  getClientRects: J6,
  getDimensions: rU,
  getScale: qa,
  isElement: fr,
  isRTL: oU
};
function lU(e, t) {
  let n = null, r;
  const i = Dr(e);
  function a() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function o(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), a();
    const {
      left: c,
      top: u,
      width: f,
      height: d
    } = e.getBoundingClientRect();
    if (s || t(), !f || !d)
      return;
    const p = Ul(u), h = Ul(i.clientWidth - (c + f)), m = Ul(i.clientHeight - (u + d)), y = Ul(c), g = {
      rootMargin: -p + "px " + -h + "px " + -m + "px " + -y + "px",
      threshold: Cn(0, ao(1, l)) || 1
    };
    let b = !0;
    function k(S) {
      const _ = S[0].intersectionRatio;
      if (_ !== l) {
        if (!b)
          return o();
        _ ? o(!1, _) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(k, {
        ...g,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(k, g);
    }
    n.observe(e);
  }
  return o(!0), a;
}
function cU(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Bv(e), u = i || a ? [...c ? bi(c) : [], ...bi(t)] : [];
  u.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), a && v.addEventListener("resize", n);
  });
  const f = c && s ? lU(c, n) : null;
  let d = -1, p = null;
  o && (p = new ResizeObserver((v) => {
    let [g] = v;
    g && g.target === c && p && (p.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var b;
      (b = p) == null || b.observe(t);
    })), n();
  }), c && !l && p.observe(c), p.observe(t));
  let h, m = l ? oa(e) : null;
  l && y();
  function y() {
    const v = oa(e);
    m && (v.x !== m.x || v.y !== m.y || v.width !== m.width || v.height !== m.height) && n(), m = v, h = requestAnimationFrame(y);
  }
  return n(), () => {
    var v;
    u.forEach((g) => {
      i && g.removeEventListener("scroll", n), a && g.removeEventListener("resize", n);
    }), f == null || f(), (v = p) == null || v.disconnect(), p = null, l && cancelAnimationFrame(h);
  };
}
const uU = H6, fU = V6, dU = Z6, pU = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: sU,
    ...n
  }, a = {
    ...i.platform,
    _c: r
  };
  return q6(e, t, {
    ...i,
    platform: a
  });
};
var _c = typeof document < "u" ? mo : $t;
function Eu(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Eu(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = i[r];
      if (!(a === "_owner" && e.$$typeof) && !Eu(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function i$(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Ox(e, t) {
  const n = i$(e);
  return Math.round(t * n) / n;
}
function Td(e) {
  const t = w.useRef(e);
  return _c(() => {
    t.current = e;
  }), t;
}
function hU(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: a,
      floating: o
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, f] = w.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [d, p] = w.useState(r);
  Eu(d, r) || p(r);
  const [h, m] = w.useState(null), [y, v] = w.useState(null), g = w.useCallback((F) => {
    F !== _.current && (_.current = F, m(F));
  }, []), b = w.useCallback((F) => {
    F !== $.current && ($.current = F, v(F));
  }, []), k = a || h, S = o || y, _ = w.useRef(null), $ = w.useRef(null), j = w.useRef(u), B = l != null, O = Td(l), N = Td(i), q = Td(c), M = w.useCallback(() => {
    if (!_.current || !$.current)
      return;
    const F = {
      placement: t,
      strategy: n,
      middleware: d
    };
    N.current && (F.platform = N.current), pU(_.current, $.current, F).then((A) => {
      const x = {
        ...A,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: q.current !== !1
      };
      z.current && !Eu(j.current, x) && (j.current = x, JS.flushSync(() => {
        f(x);
      }));
    });
  }, [d, t, n, N, q]);
  _c(() => {
    c === !1 && j.current.isPositioned && (j.current.isPositioned = !1, f((F) => ({
      ...F,
      isPositioned: !1
    })));
  }, [c]);
  const z = w.useRef(!1);
  _c(() => (z.current = !0, () => {
    z.current = !1;
  }), []), _c(() => {
    if (k && (_.current = k), S && ($.current = S), k && S) {
      if (O.current)
        return O.current(k, S, M);
      M();
    }
  }, [k, S, M, O, B]);
  const D = w.useMemo(() => ({
    reference: _,
    floating: $,
    setReference: g,
    setFloating: b
  }), [g, b]), R = w.useMemo(() => ({
    reference: k,
    floating: S
  }), [k, S]), W = w.useMemo(() => {
    const F = {
      position: n,
      left: 0,
      top: 0
    };
    if (!R.floating)
      return F;
    const A = Ox(R.floating, u.x), x = Ox(R.floating, u.y);
    return s ? {
      ...F,
      transform: "translate(" + A + "px, " + x + "px)",
      ...i$(R.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: A,
      top: x
    };
  }, [n, s, R.floating, u.x, u.y]);
  return w.useMemo(() => ({
    ...u,
    update: M,
    refs: D,
    elements: R,
    floatingStyles: W
  }), [u, M, D, R, W]);
}
const mU = (e, t) => ({
  ...uU(e),
  options: [e, t]
}), vU = (e, t) => ({
  ...fU(e),
  options: [e, t]
}), gU = (e, t) => ({
  ...dU(e),
  options: [e, t]
});
var Un = function() {
  return Un = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Un.apply(this, arguments);
};
function a$(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function yU(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, a; r < i; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
function bU() {
  var e = Pt(!1), t = Et(function() {
    return e.current;
  }, []);
  return $t(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function xU(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Pt(0), i = bU(), a = ht(n), o = a[0], s = a[1], l = Et(function() {
    for (var c = [], u = 0; u < arguments.length; u++)
      c[u] = arguments[u];
    var f = ++r.current;
    return o.loading || s(function(d) {
      return Un(Un({}, d), { loading: !0 });
    }), e.apply(void 0, c).then(function(d) {
      return i() && f === r.current && s({ value: d, loading: !1 }), d;
    }, function(d) {
      return i() && f === r.current && s({ error: d, loading: !1 }), d;
    });
  }, t);
  return [o, l];
}
function Gh(e, t) {
  t === void 0 && (t = []);
  var n = xU(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return $t(function() {
    i();
  }, [i]), r;
}
function wU(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.addEventListener && e.addEventListener.apply(e, t);
}
function SU(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.removeEventListener && e.removeEventListener.apply(e, t);
}
var EU = function(e) {
  $t(e, []);
}, _U = function(e) {
  var t = Pt(e);
  t.current = e, EU(function() {
    return function() {
      return t.current();
    };
  });
}, kU = function(e) {
  var t = Pt(0), n = ht(e), r = n[0], i = n[1], a = Et(function(o) {
    cancelAnimationFrame(t.current), t.current = requestAnimationFrame(function() {
      i(o);
    });
  }, []);
  return _U(function() {
    cancelAnimationFrame(t.current);
  }), [r, a];
}, $U = function(e) {
  process.env.NODE_ENV === "development" && (typeof e != "object" || typeof e.current > "u") && console.error("`useScroll` expects a single ref argument.");
  var t = kU({
    x: 0,
    y: 0
  }), n = t[0], r = t[1];
  return $t(function() {
    var i = function() {
      e.current && r({
        x: e.current.scrollLeft,
        y: e.current.scrollTop
      });
    };
    return e.current && wU(e.current, "scroll", i, {
      capture: !1,
      passive: !0
    }), function() {
      e.current && SU(e.current, "scroll", i);
    };
  }, [e]), n;
};
const OU = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Tx = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (u, f) => {
    const d = typeof u == "function" ? u(t) : u;
    if (!Object.is(d, t)) {
      const p = t;
      t = f ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach((h) => h(t, p));
    }
  }, i = () => t, l = { setState: r, getState: i, getInitialState: () => c, subscribe: (u) => (n.add(u), () => n.delete(u)), destroy: () => {
    (OU ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, c = t = e(r, i, l);
  return l;
}, o$ = (e) => e ? Tx(e) : Tx;
var Yh = { exports: {} }, Cd = {}, ql = { exports: {} }, Rd = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cx;
function TU() {
  if (Cx) return Rd;
  Cx = 1;
  var e = bt;
  function t(f, d) {
    return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, a = e.useLayoutEffect, o = e.useDebugValue;
  function s(f, d) {
    var p = d(), h = r({ inst: { value: p, getSnapshot: d } }), m = h[0].inst, y = h[1];
    return a(function() {
      m.value = p, m.getSnapshot = d, l(m) && y({ inst: m });
    }, [f, p, d]), i(function() {
      return l(m) && y({ inst: m }), f(function() {
        l(m) && y({ inst: m });
      });
    }, [f]), o(p), p;
  }
  function l(f) {
    var d = f.getSnapshot;
    f = f.value;
    try {
      var p = d();
      return !n(f, p);
    } catch {
      return !0;
    }
  }
  function c(f, d) {
    return d();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return Rd.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, Rd;
}
var Id = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rx;
function CU() {
  return Rx || (Rx = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = bt, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(b) {
      {
        for (var k = arguments.length, S = new Array(k > 1 ? k - 1 : 0), _ = 1; _ < k; _++)
          S[_ - 1] = arguments[_];
        r("error", b, S);
      }
    }
    function r(b, k, S) {
      {
        var _ = t.ReactDebugCurrentFrame, $ = _.getStackAddendum();
        $ !== "" && (k += "%s", S = S.concat([$]));
        var j = S.map(function(B) {
          return String(B);
        });
        j.unshift("Warning: " + k), Function.prototype.apply.call(console[b], console, j);
      }
    }
    function i(b, k) {
      return b === k && (b !== 0 || 1 / b === 1 / k) || b !== b && k !== k;
    }
    var a = typeof Object.is == "function" ? Object.is : i, o = e.useState, s = e.useEffect, l = e.useLayoutEffect, c = e.useDebugValue, u = !1, f = !1;
    function d(b, k, S) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var _ = k();
      if (!f) {
        var $ = k();
        a(_, $) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var j = o({
        inst: {
          value: _,
          getSnapshot: k
        }
      }), B = j[0].inst, O = j[1];
      return l(function() {
        B.value = _, B.getSnapshot = k, p(B) && O({
          inst: B
        });
      }, [b, _, k]), s(function() {
        p(B) && O({
          inst: B
        });
        var N = function() {
          p(B) && O({
            inst: B
          });
        };
        return b(N);
      }, [b]), c(_), _;
    }
    function p(b) {
      var k = b.getSnapshot, S = b.value;
      try {
        var _ = k();
        return !a(S, _);
      } catch {
        return !0;
      }
    }
    function h(b, k, S) {
      return k();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !m, v = y ? h : d, g = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    Id.useSyncExternalStore = g, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Id;
}
var Ix;
function s$() {
  return Ix || (Ix = 1, process.env.NODE_ENV === "production" ? ql.exports = TU() : ql.exports = CU()), ql.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ax;
function RU() {
  if (Ax) return Cd;
  Ax = 1;
  var e = bt, t = s$();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return Cd.useSyncExternalStoreWithSelector = function(c, u, f, d, p) {
    var h = a(null);
    if (h.current === null) {
      var m = { hasValue: !1, value: null };
      h.current = m;
    } else m = h.current;
    h = s(function() {
      function v(_) {
        if (!g) {
          if (g = !0, b = _, _ = d(_), p !== void 0 && m.hasValue) {
            var $ = m.value;
            if (p($, _)) return k = $;
          }
          return k = _;
        }
        if ($ = k, r(b, _)) return $;
        var j = d(_);
        return p !== void 0 && p($, j) ? $ : (b = _, k = j);
      }
      var g = !1, b, k, S = f === void 0 ? null : f;
      return [function() {
        return v(u());
      }, S === null ? void 0 : function() {
        return v(S());
      }];
    }, [u, f, d, p]);
    var y = i(c, h[0], h[1]);
    return o(function() {
      m.hasValue = !0, m.value = y;
    }, [y]), l(y), y;
  }, Cd;
}
var Ad = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Px;
function IU() {
  return Px || (Px = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = bt, t = s$();
    function n(u, f) {
      return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, l = e.useDebugValue;
    function c(u, f, d, p, h) {
      var m = a(null), y;
      m.current === null ? (y = {
        hasValue: !1,
        value: null
      }, m.current = y) : y = m.current;
      var v = s(function() {
        var S = !1, _, $, j = function(q) {
          if (!S) {
            S = !0, _ = q;
            var M = p(q);
            if (h !== void 0 && y.hasValue) {
              var z = y.value;
              if (h(z, M))
                return $ = z, z;
            }
            return $ = M, M;
          }
          var D = _, R = $;
          if (r(D, q))
            return R;
          var W = p(q);
          return h !== void 0 && h(R, W) ? R : (_ = q, $ = W, W);
        }, B = d === void 0 ? null : d, O = function() {
          return j(f());
        }, N = B === null ? void 0 : function() {
          return j(B());
        };
        return [O, N];
      }, [f, d, p, h]), g = v[0], b = v[1], k = i(u, g, b);
      return o(function() {
        y.hasValue = !0, y.value = k;
      }, [k]), l(k), k;
    }
    Ad.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Ad;
}
process.env.NODE_ENV === "production" ? Yh.exports = RU() : Yh.exports = IU();
var AU = Yh.exports;
const PU = /* @__PURE__ */ Ze(AU), l$ = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, { useDebugValue: jU } = bt, { useSyncExternalStoreWithSelector: NU } = PU;
let jx = !1;
const DU = (e) => e;
function c$(e, t = DU, n) {
  (l$ ? "production" : void 0) !== "production" && n && !jx && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), jx = !0);
  const r = NU(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return jU(r), r;
}
const MU = (e) => {
  (l$ ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? o$(e) : e, n = (r, i) => c$(t, r, i);
  return Object.assign(n, t), n;
}, LU = (e) => MU, kc = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Jh = /* @__PURE__ */ new Map(), Wl = (e) => {
  const t = Jh.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, FU = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = Jh.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return Jh.set(n.name, i), { type: "tracked", store: e, ...i };
}, BU = (e, t = {}) => (n, r, i) => {
  const { enabled: a, anonymousActionType: o, store: s, ...l } = t;
  let c;
  try {
    c = (a ?? (kc ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!c)
    return (kc ? "production" : void 0) !== "production" && a && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), e(n, r, i);
  const { connection: u, ...f } = FU(s, c, l);
  let d = !0;
  i.setState = (m, y, v) => {
    const g = n(m, y);
    if (!d) return g;
    const b = v === void 0 ? { type: o || "anonymous" } : typeof v == "string" ? { type: v } : v;
    return s === void 0 ? (u == null || u.send(b, r()), g) : (u == null || u.send(
      {
        ...b,
        type: `${s}/${b.type}`
      },
      {
        ...Wl(l.name),
        [s]: i.getState()
      }
    ), g);
  };
  const p = (...m) => {
    const y = d;
    d = !1, n(...m), d = y;
  }, h = e(i.setState, r, i);
  if (f.type === "untracked" ? u == null || u.init(h) : (f.stores[f.store] = i, u == null || u.init(
    Object.fromEntries(
      Object.entries(f.stores).map(([m, y]) => [
        m,
        m === f.store ? h : y.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let m = !1;
    const y = i.dispatch;
    i.dispatch = (...v) => {
      (kc ? "production" : void 0) !== "production" && v[0].type === "__setState" && !m && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), m = !0), y(...v);
    };
  }
  return u.subscribe((m) => {
    var y;
    switch (m.type) {
      case "ACTION":
        if (typeof m.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return Pd(
          m.payload,
          (v) => {
            if (v.type === "__setState") {
              if (s === void 0) {
                p(v.state);
                return;
              }
              Object.keys(v.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const g = v.state[s];
              if (g == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(g) && p(g);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(v);
          }
        );
      case "DISPATCH":
        switch (m.payload.type) {
          case "RESET":
            return p(h), s === void 0 ? u == null ? void 0 : u.init(i.getState()) : u == null ? void 0 : u.init(Wl(l.name));
          case "COMMIT":
            if (s === void 0) {
              u == null || u.init(i.getState());
              return;
            }
            return u == null ? void 0 : u.init(Wl(l.name));
          case "ROLLBACK":
            return Pd(m.state, (v) => {
              if (s === void 0) {
                p(v), u == null || u.init(i.getState());
                return;
              }
              p(v[s]), u == null || u.init(Wl(l.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return Pd(m.state, (v) => {
              if (s === void 0) {
                p(v);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(v[s]) && p(v[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: v } = m.payload, g = (y = v.computedStates.slice(-1)[0]) == null ? void 0 : y.state;
            if (!g) return;
            p(s === void 0 ? g : g[s]), u == null || u.send(
              null,
              // FIXME no-any
              v
            );
            return;
          }
          case "PAUSE_RECORDING":
            return d = !d;
        }
        return;
    }
  }), h;
}, u$ = BU, Pd = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function zU(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var a;
      const o = (l) => l === null ? null : JSON.parse(l, void 0), s = (a = n.getItem(i)) != null ? a : null;
      return s instanceof Promise ? s.then(o) : o(s);
    },
    setItem: (i, a) => n.setItem(
      i,
      JSON.stringify(a, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Us = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Us(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Us(r)(n);
      }
    };
  }
}, UU = (e, t) => (n, r, i) => {
  let a = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (y) => y,
    version: 0,
    merge: (y, v) => ({
      ...v,
      ...y
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let c;
  try {
    c = a.getStorage();
  } catch {
  }
  if (!c)
    return e(
      (...y) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...y);
      },
      r,
      i
    );
  const u = Us(a.serialize), f = () => {
    const y = a.partialize({ ...r() });
    let v;
    const g = u({ state: y, version: a.version }).then(
      (b) => c.setItem(a.name, b)
    ).catch((b) => {
      v = b;
    });
    if (v)
      throw v;
    return g;
  }, d = i.setState;
  i.setState = (y, v) => {
    d(y, v), f();
  };
  const p = e(
    (...y) => {
      n(...y), f();
    },
    r,
    i
  );
  let h;
  const m = () => {
    var y;
    if (!c) return;
    o = !1, s.forEach((g) => g(r()));
    const v = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, r())) || void 0;
    return Us(c.getItem.bind(c))(a.name).then((g) => {
      if (g)
        return a.deserialize(g);
    }).then((g) => {
      if (g)
        if (typeof g.version == "number" && g.version !== a.version) {
          if (a.migrate)
            return a.migrate(
              g.state,
              g.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return g.state;
    }).then((g) => {
      var b;
      return h = a.merge(
        g,
        (b = r()) != null ? b : p
      ), n(h, !0), f();
    }).then(() => {
      v == null || v(h, void 0), o = !0, l.forEach((g) => g(h));
    }).catch((g) => {
      v == null || v(void 0, g);
    });
  };
  return i.persist = {
    setOptions: (y) => {
      a = {
        ...a,
        ...y
      }, y.getStorage && (c = y.getStorage());
    },
    clearStorage: () => {
      c == null || c.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => m(),
    hasHydrated: () => o,
    onHydrate: (y) => (s.add(y), () => {
      s.delete(y);
    }),
    onFinishHydration: (y) => (l.add(y), () => {
      l.delete(y);
    })
  }, m(), h || p;
}, qU = (e, t) => (n, r, i) => {
  let a = {
    storage: zU(() => localStorage),
    partialize: (m) => m,
    version: 0,
    merge: (m, y) => ({
      ...y,
      ...m
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let c = a.storage;
  if (!c)
    return e(
      (...m) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...m);
      },
      r,
      i
    );
  const u = () => {
    const m = a.partialize({ ...r() });
    return c.setItem(a.name, {
      state: m,
      version: a.version
    });
  }, f = i.setState;
  i.setState = (m, y) => {
    f(m, y), u();
  };
  const d = e(
    (...m) => {
      n(...m), u();
    },
    r,
    i
  );
  i.getInitialState = () => d;
  let p;
  const h = () => {
    var m, y;
    if (!c) return;
    o = !1, s.forEach((g) => {
      var b;
      return g((b = r()) != null ? b : d);
    });
    const v = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, (m = r()) != null ? m : d)) || void 0;
    return Us(c.getItem.bind(c))(a.name).then((g) => {
      if (g)
        if (typeof g.version == "number" && g.version !== a.version) {
          if (a.migrate)
            return [
              !0,
              a.migrate(
                g.state,
                g.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, g.state];
      return [!1, void 0];
    }).then((g) => {
      var b;
      const [k, S] = g;
      if (p = a.merge(
        S,
        (b = r()) != null ? b : d
      ), n(p, !0), k)
        return u();
    }).then(() => {
      v == null || v(p, void 0), p = r(), o = !0, l.forEach((g) => g(p));
    }).catch((g) => {
      v == null || v(void 0, g);
    });
  };
  return i.persist = {
    setOptions: (m) => {
      a = {
        ...a,
        ...m
      }, m.storage && (c = m.storage);
    },
    clearStorage: () => {
      c == null || c.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => h(),
    hasHydrated: () => o,
    onHydrate: (m) => (s.add(m), () => {
      s.delete(m);
    }),
    onFinishHydration: (m) => (l.add(m), () => {
      l.delete(m);
    })
  }, a.skipHydration || h(), p || d;
}, WU = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? ((kc ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), UU(e, t)) : qU(e, t), HU = WU, Rn = LU()(
  u$(
    HU(
      (e, t) => ({
        messageHistory: {},
        addMessageToHistory: ({ userId: n, message: r }) => e((i) => ({
          ...i,
          messageHistory: {
            ...i.messageHistory,
            [n]: [r, ...(i.messageHistory[n] ?? []).slice(0, 100)]
          }
        })),
        clientMode: "",
        setClientMode: (n) => {
          const { clearAll: r, clientMode: i } = t();
          i !== n && r(), e((a) => ({
            ...a,
            clientMode: n
          }));
        },
        setUser: (n) => e((r) => ({
          ...r,
          user: n
        })),
        setConversationId: (n) => e((r) => ({
          ...r,
          conversationId: n
        })),
        clearAll: () => {
          e((n) => ({
            ...n,
            messageHistory: {},
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: "botpress-webchat"
      }
    )
  )
), f$ = Yu(null), VU = (e) => {
  const t = {
    configuration: {},
    messages: {},
    connected: !0,
    disableComposer: !1,
    renderers: {},
    isReadOnly: !1,
    userData: {},
    userName: void 0,
    userPictureUrl: void 0,
    closeWindow: void 0,
    messageContainerRef: { current: null },
    isTyping: !1,
    lastTypingHeartbeat: null,
    allowFileUpload: !1,
    conversationId: void 0,
    disableRestartConversation: !1
  }, n = e == null ? void 0 : e.client, r = e == null ? void 0 : e.conversationId, i = Rn.getState().setClientMode, a = Rn.getState().setConversationId;
  return n && i(n.mode), $t(() => {
    r && a(r);
  }, [r]), o$()(
    u$(
      (o, s) => {
        const l = (f) => {
          const d = Rn.getState().conversationId;
          if (d)
            return o((p) => {
              const h = p.messages[d] ?? [];
              return {
                ...p,
                messages: {
                  ...p.messages,
                  [d]: [...h.filter((m) => m.id !== f.id), { id: Qo(), ...f }]
                }
              };
            });
        }, c = (f) => {
          const d = Rn.getState().conversationId;
          if (d)
            return o((p) => ({ ...p, messages: { ...p.messages, [d]: f } }));
        }, u = Rn.getState().addMessageToHistory;
        return {
          ...t,
          ...e,
          eventEmitter: LI,
          client: n,
          sendFile: (f) => s().client.sendFile(f),
          sendTextMessage: async (f, d) => {
            const p = s().client;
            l({
              id: Qo(),
              // This is temporary untile we fix the client to return the id
              direction: "outgoing",
              sender: { name: "You" },
              timestamp: /* @__PURE__ */ new Date(),
              disableInput: !1,
              block: { type: "bubble", block: { type: "text", text: f, value: d } }
            }), p && await p.sendMessage({ type: "text", text: f, value: d }), p != null && p.userId && u({ message: f, userId: p.userId });
          },
          sendMessage: async (f) => {
            const d = s().client;
            l({
              id: Qo(),
              // This is temporary untile we fix the client to return the id
              direction: "outgoing",
              sender: { name: "You" },
              timestamp: /* @__PURE__ */ new Date(),
              disableInput: !1,
              block: cs(f).payload
            }), d && await d.sendMessage(f), d != null && d.userId && f.type === "text" && u({ message: f.text, userId: d.userId });
          },
          on: (f, d) => {
            const p = s().client;
            return p ? p.on(f, d) : () => {
            };
          },
          getClientId: () => {
            var f;
            return (f = s().client) == null ? void 0 : f.clientId;
          },
          setHeaderMessage: (f) => o({ headerMessage: f }),
          setDisableComposer: (f) => o({ disableComposer: f }),
          setState: (f) => o((d) => ({ ...d, ...f })),
          setMessages: c,
          getMessages: () => s().messages[Rn.getState().conversationId ?? ""] ?? [],
          setIsTyping: (f, d) => {
            o((p) => ({ ...p, isTyping: f })), f && (o((p) => ({ ...p, lastTypingHeartbeat: /* @__PURE__ */ new Date() })), d && setTimeout(() => {
              const p = s().lastTypingHeartbeat;
              p && (/* @__PURE__ */ new Date()).getTime() - p.getTime() > d && o((h) => ({ ...h, isTyping: !1 }));
            }, d + 100));
          },
          setLastTypingHeartbeat: (f) => o((d) => ({ ...d, lastTypingHeartbeat: f })),
          addMessage: l,
          setConnected: (f) => o((d) => ({ ...d, connected: f })),
          restartConversation: async () => {
            const f = s().client, d = s().setMessages;
            f && (await f.newConversation(), d([]));
          }
        };
      },
      { name: "webchatStore" }
    )
  );
};
function De(e) {
  const t = Pi(f$);
  if (!t) throw new Error("Missing WebchatContext.Provider in the tree");
  return c$(t, e);
}
const ZU = ({ text: e, buttonValue: t, type: n, variant: r, groupId: i, reusable: a, ...o }) => {
  const s = De((g) => g.eventEmitter), l = De((g) => g.sendTextMessage), c = De((g) => g.isReadOnly), [u, f] = ht(!1), [d, p] = ht(!1), [h, m] = ht(!1), {
    message: {
      blocks: { button: y }
    }
  } = xt;
  $t(() => {
    if (i)
      return s.on(`button-group-${i}-click`, () => {
        p(!0), a || m(!0);
      });
  }, [s, i, a]);
  function v() {
    i && s.emit(`button-group-${i}-click`), f(!0), a || m(!0), r !== "link" && l(e, t);
  }
  return /* @__PURE__ */ C.jsx(
    KU,
    {
      ...o,
      variant: r,
      onClick: v,
      disabled: h || c,
      "data-activated": u ? "" : void 0,
      "data-group-activated": d ? "" : void 0,
      "data-type": r,
      value: t,
      ...y,
      children: e
    }
  );
}, KU = (e) => {
  if (e.variant === "link") {
    const { value: r, variant: i, ...a } = e;
    return /* @__PURE__ */ C.jsx("a", { ...a, href: r, target: "_blank", rel: "noopener noreferrer" });
  }
  const { variant: t, ...n } = e;
  return /* @__PURE__ */ C.jsx("button", { type: "button", ...n });
}, GU = _n(
  ({ block: e, type: t, direction: n, timestamp: r, sender: i, metadata: a, ...o }, s) => {
    const {
      message: {
        blocks: { bubble: l }
      }
    } = xt;
    return /* @__PURE__ */ C.jsx("div", { ...o, ...l, ref: s, children: /* @__PURE__ */ C.jsx(hl, { direction: n, timestamp: r, sender: i, block: e, metadata: a }) });
  }
), d$ = Yu(null);
function YU() {
  const e = Pi(d$);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const p$ = Yu(null);
function h$() {
  const e = Pi(p$);
  if (!e)
    throw new Error("useModalContext must be used within a ModalProvider");
  return e;
}
const m$ = Yu(null);
function v$() {
  const e = Pi(m$);
  if (!e)
    throw new Error("useWebchatConfig must be used within a WebchatConfigProvider");
  return e;
}
const JU = _n(({ url: e, type: t, orientation: n = "auto", ...r }, i) => {
  const a = ZR(), { setIsLoading: o } = YU(), [s, l] = ht(n), [c, u] = ht(!1), {
    message: {
      blocks: { image: f }
    }
  } = xt;
  return mo(() => {
    o((d) => [...d, a]);
  }, []), Gh(async () => {
    if (e && s === "auto") {
      try {
        const { width: d, height: p } = await Tz(e);
        l(XU(d, p));
      } catch (d) {
        l("square"), console.error(d);
      }
      o((d) => d.filter((p) => p !== a));
    }
  }, [e]), /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    c ? null : /* @__PURE__ */ C.jsx("div", { "data-orientation": s, ...f.placeholder }),
    /* @__PURE__ */ C.jsx(
      "img",
      {
        "data-orientation": s,
        "data-loaded": c,
        ...r,
        ...f.image,
        src: e,
        alt: "",
        ref: i,
        loading: "lazy",
        onLoad: () => {
          u(!0);
        }
      }
    )
  ] });
});
function XU(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((a, o) => Math.abs(n[o] - r) < Math.abs(n[a] - r) ? o : a);
}
const QU = _n(({ url: e, type: t, ...n }, r) => {
  const {
    message: {
      blocks: { video: i }
    }
  } = xt;
  return /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsx("video", { ...n, controls: !0, src: e, ...i, ref: r }) });
}), e7 = _n(({ url: e, type: t, ...n }, r) => {
  const {
    message: {
      blocks: { audio: i }
    }
  } = xt;
  return /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsx("audio", { ...n, controls: !0, src: e, ...i, ref: r }) });
});
function t7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3a.75.75 0 0 1 .75.75v10.638l3.96-4.158a.75.75 0 1 1 1.08 1.04l-5.25 5.5a.75.75 0 0 1-1.08 0l-5.25-5.5a.75.75 0 1 1 1.08-1.04l3.96 4.158V3.75A.75.75 0 0 1 10 3Z",
    clipRule: "evenodd"
  }));
}
const n7 = /* @__PURE__ */ w.forwardRef(t7);
function r7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M15.312 11.424a5.5 5.5 0 0 1-9.201 2.466l-.312-.311h2.433a.75.75 0 0 0 0-1.5H3.989a.75.75 0 0 0-.75.75v4.242a.75.75 0 0 0 1.5 0v-2.43l.31.31a7 7 0 0 0 11.712-3.138.75.75 0 0 0-1.449-.39Zm1.23-3.723a.75.75 0 0 0 .219-.53V2.929a.75.75 0 0 0-1.5 0V5.36l-.31-.31A7 7 0 0 0 3.239 8.188a.75.75 0 1 0 1.448.389A5.5 5.5 0 0 1 13.89 6.11l.311.31h-2.432a.75.75 0 0 0 0 1.5h4.243a.75.75 0 0 0 .53-.219Z",
    clipRule: "evenodd"
  }));
}
const i7 = /* @__PURE__ */ w.forwardRef(r7);
function a7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z",
    clipRule: "evenodd"
  }));
}
const o7 = /* @__PURE__ */ w.forwardRef(a7);
function s7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 2A1.5 1.5 0 0 0 3 3.5v13A1.5 1.5 0 0 0 4.5 18h11a1.5 1.5 0 0 0 1.5-1.5V7.621a1.5 1.5 0 0 0-.44-1.06l-4.12-4.122A1.5 1.5 0 0 0 11.378 2H4.5Zm4.75 6.75a.75.75 0 0 1 1.5 0v2.546l.943-1.048a.75.75 0 0 1 1.114 1.004l-2.25 2.5a.75.75 0 0 1-1.114 0l-2.25-2.5a.75.75 0 1 1 1.114-1.004l.943 1.048V8.75Z",
    clipRule: "evenodd"
  }));
}
const l7 = /* @__PURE__ */ w.forwardRef(s7);
function c7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "m9.69 18.933.003.001C9.89 19.02 10 19 10 19s.11.02.308-.066l.002-.001.006-.003.018-.008a5.741 5.741 0 0 0 .281-.14c.186-.096.446-.24.757-.433.62-.384 1.445-.966 2.274-1.765C15.302 14.988 17 12.493 17 9A7 7 0 1 0 3 9c0 3.492 1.698 5.988 3.355 7.584a13.731 13.731 0 0 0 2.273 1.765 11.842 11.842 0 0 0 .976.544l.062.029.018.008.006.003ZM10 11.25a2.25 2.25 0 1 0 0-4.5 2.25 2.25 0 0 0 0 4.5Z",
    clipRule: "evenodd"
  }));
}
const u7 = /* @__PURE__ */ w.forwardRef(c7), f7 = _n(({ type: e, latitude: t, longitude: n, title: r, ...i }, a) => {
  const o = `https://www.google.com/maps/search/?api=1&query=${t},${n}`, {
    message: {
      blocks: { location: s }
    }
  } = xt;
  return /* @__PURE__ */ C.jsxs("a", { ...i, ...s.container, href: o, type: "_blank", rel: "noopener", ref: a, children: [
    /* @__PURE__ */ C.jsx("p", { ...s.title, children: r }),
    /* @__PURE__ */ C.jsx(u7, { ...s.icon })
  ] });
}), d7 = _n(
  ({ blocks: e, type: t, horizontalAlignment: n, verticalAlignment: r, direction: i, sender: a, timestamp: o, metadata: s, ...l }, c) => {
    const {
      message: {
        blocks: { column: u }
      }
    } = xt;
    return /* @__PURE__ */ C.jsx("div", { "data-horizontal": n, "data-vertical": r, ...l, ...u, ref: c, children: e.map((f, d) => /* @__PURE__ */ C.jsx(hl, { block: f, direction: i, sender: a, timestamp: o, metadata: s }, d)) });
  }
), p7 = _n(
  ({ blocks: e, type: t, horizontalAlignment: n, verticalAlignment: r, direction: i, sender: a, timestamp: o, metadata: s, ...l }, c) => {
    const {
      message: {
        blocks: { row: u }
      }
    } = xt;
    return /* @__PURE__ */ C.jsx("div", { "data-horizontal": n, "data-vertical": r, ...l, ...u, ref: c, children: e.map((f, d) => /* @__PURE__ */ C.jsx(hl, { block: f, direction: i, sender: a, timestamp: o, metadata: s }, d)) });
  }
);
function h7(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Nx(e) {
  return h7(e) || Array.isArray(e);
}
function m7() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function zv(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), a = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== a ? !1 : n.every((o) => {
    const s = e[o], l = t[o];
    return typeof s == "function" ? `${s}` == `${l}` : !Nx(s) || !Nx(l) ? s === l : zv(s, l);
  });
}
function Dx(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function v7(e, t) {
  if (e.length !== t.length) return !1;
  const n = Dx(e), r = Dx(t);
  return n.every((i, a) => {
    const o = r[a];
    return zv(i, o);
  });
}
function Uv(e) {
  return typeof e == "number";
}
function Mx(e) {
  return typeof e == "string";
}
function qv(e) {
  return typeof e == "boolean";
}
function Lx(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ct(e) {
  return Math.abs(e);
}
function Wv(e) {
  return Math.sign(e);
}
function $c(e, t) {
  return Ct(e - t);
}
function g7(e, t) {
  if (e === 0 || t === 0 || Ct(e) <= Ct(t)) return 0;
  const n = $c(Ct(e), Ct(t));
  return Ct(n / e);
}
function qs(e) {
  return _u(e).map(Number);
}
function Gr(e) {
  return e[hf(e)];
}
function hf(e) {
  return Math.max(0, e.length - 1);
}
function _u(e) {
  return Object.keys(e);
}
function g$(e, t) {
  return [e, t].reduce((n, r) => (_u(r).forEach((i) => {
    const a = n[i], o = r[i], s = Lx(a) && Lx(o);
    n[i] = s ? g$(a, o) : o;
  }), n), {});
}
function y$(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function y7(e, t) {
  const n = {
    start: r,
    center: i,
    end: a
  };
  function r() {
    return 0;
  }
  function i(c) {
    return a(c) / 2;
  }
  function a(c) {
    return t - c;
  }
  function o() {
    return t * Number(e);
  }
  function s(c) {
    return Uv(e) ? o() : n[e](c);
  }
  return {
    measure: s
  };
}
function b7(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), a = l();
  function o(u) {
    const {
      width: f,
      height: d
    } = u;
    return n === "x" ? f : d;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function l() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: a,
    measureSize: o
  };
}
function Ai(e, t) {
  const n = Ct(e - t);
  function r(c) {
    return c < e;
  }
  function i(c) {
    return c > t;
  }
  function a(c) {
    return r(c) || i(c);
  }
  function o(c) {
    return a(c) ? r(c) ? e : t : c;
  }
  function s(c) {
    return n ? c - n * Math.ceil((c - t) / n) : c;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: o,
    reachedAny: a,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function b$(e, t, n) {
  const {
    constrain: r
  } = Ai(0, e), i = e + 1;
  let a = o(t);
  function o(d) {
    return n ? Ct((i + d) % i) : r(d);
  }
  function s() {
    return a;
  }
  function l(d) {
    return a = o(d), f;
  }
  function c(d) {
    return u().set(s() + d);
  }
  function u() {
    return b$(e, s(), n);
  }
  const f = {
    get: s,
    set: l,
    add: c,
    clone: u
  };
  return f;
}
function x7(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function Ws() {
  let e = [];
  function t(i, a, o, s = {
    passive: !0
  }) {
    return i.addEventListener(a, o, s), e.push(() => i.removeEventListener(a, o, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function w7(e, t, n, r, i, a, o, s, l, c, u, f, d, p, h, m, y, v, g) {
  const {
    cross: b
  } = e, k = ["INPUT", "SELECT", "TEXTAREA"], S = {
    passive: !1
  }, _ = Ws(), $ = Ws(), j = Ai(50, 225).constrain(h.measure(20)), B = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, N = m ? 43 : 25;
  let q = !1, M = 0, z = 0, D = !1, R = !1, W = !1, F = !1;
  function A(J, V) {
    if (!V) return;
    function fe(Oe) {
      (qv(V) || V(J, Oe)) && ae(Oe);
    }
    const me = n;
    _.add(me, "dragstart", (Oe) => Oe.preventDefault(), S).add(me, "touchmove", () => {
    }, S).add(me, "touchend", () => {
    }).add(me, "touchstart", fe).add(me, "mousedown", fe).add(me, "touchcancel", se).add(me, "contextmenu", se).add(me, "click", de, !0);
  }
  function x() {
    _.clear(), $.clear();
  }
  function U() {
    const J = F ? r : n;
    $.add(J, "touchmove", te, S).add(J, "touchend", se).add(J, "mousemove", te, S).add(J, "mouseup", se);
  }
  function Z(J) {
    const V = J.nodeName || "";
    return k.includes(V);
  }
  function E() {
    return (m ? O : B)[F ? "mouse" : "touch"];
  }
  function X(J, V) {
    const fe = d.add(Wv(J) * -1), me = f.byDistance(J, !m).distance;
    return m || Ct(J) < j ? me : v && V ? me * 0.5 : f.byIndex(fe.get(), 0).distance;
  }
  function ae(J) {
    const V = y$(J, i);
    F = V, !(V && J.button !== 0) && (Z(J.target) || (W = m && V && !J.buttons && q, q = $c(a.get(), s.get()) >= 2, D = !0, o.pointerDown(J), u.useFriction(0).useDuration(0), a.set(s), U(), M = o.readPoint(J), z = o.readPoint(J, b), p.emit("pointerDown")));
  }
  function te(J) {
    const V = o.readPoint(J), fe = o.readPoint(J, b), me = $c(V, M), Oe = $c(fe, z);
    if (!R && !F && (!J.cancelable || (R = me > Oe, !R)))
      return se(J);
    const I = o.pointerMove(J);
    me > y && (W = !0), u.useFriction(0.3).useDuration(1), l.start(), a.add(t.apply(I)), J.preventDefault();
  }
  function se(J) {
    const fe = f.byDistance(0, !1).index !== d.get(), me = o.pointerUp(J) * E(), Oe = X(t.apply(me), fe), I = g7(me, Oe), G = N - 10 * I, re = g + I / 50;
    R = !1, D = !1, $.clear(), u.useDuration(G).useFriction(re), c.distance(Oe, !m), F = !1, p.emit("pointerUp");
  }
  function de(J) {
    W && (J.stopPropagation(), J.preventDefault());
  }
  function pe() {
    return D;
  }
  return {
    init: A,
    pointerDown: pe,
    destroy: x
  };
}
function S7(e, t) {
  let r, i;
  function a(f) {
    return f.timeStamp;
  }
  function o(f, d) {
    const h = `client${(d || e.scroll) === "x" ? "X" : "Y"}`;
    return (y$(f, t) ? f : f.touches[0])[h];
  }
  function s(f) {
    return r = f, i = f, o(f);
  }
  function l(f) {
    const d = o(f) - o(i), p = a(f) - a(r) > 170;
    return i = f, p && (r = f), d;
  }
  function c(f) {
    if (!r || !i) return 0;
    const d = o(i) - o(r), p = a(f) - a(r), h = a(f) - a(i) > 170, m = d / p;
    return p && !h && Ct(m) > 0.1 ? m : 0;
  }
  return {
    pointerDown: s,
    pointerMove: l,
    pointerUp: c,
    readPoint: o
  };
}
function E7(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function _7(e, t, n, r, i) {
  let a, o, s = [], l = !1;
  function c(p) {
    return i.measureSize(p.getBoundingClientRect());
  }
  function u(p, h) {
    if (!h) return;
    o = c(e), s = r.map(c);
    function m(v) {
      for (const g of v) {
        const b = g.target === e, k = r.indexOf(g.target), S = b ? o : s[k], _ = c(b ? e : r[k]);
        if (S !== _) {
          n.requestAnimationFrame(() => {
            p.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    a = new ResizeObserver((v) => {
      l || (qv(h) || h(p, v)) && m(v);
    }), [e].concat(r).forEach((v) => a.observe(v));
  }
  function f() {
    a && a.disconnect(), l = !0;
  }
  return {
    init: u,
    destroy: f
  };
}
function k7(e, t, n, r) {
  let i = !0, a = 0, o = 0, s = n, l = r, c = e.get(), u = 0;
  function f() {
    const S = t.get() - e.get(), _ = !s;
    let $ = 0;
    return _ ? (a = 0, e.set(t), $ = S) : (a += S / s, a *= l, c += a, e.add(a), $ = c - u), o = Wv($), u = c, i = Ct(S) < 1e-3, k;
  }
  function d() {
    return i;
  }
  function p() {
    return s;
  }
  function h() {
    return o;
  }
  function m() {
    return a;
  }
  function y() {
    return g(n);
  }
  function v() {
    return b(r);
  }
  function g(S) {
    return s = S, k;
  }
  function b(S) {
    return l = S, k;
  }
  const k = {
    direction: h,
    duration: p,
    velocity: m,
    seek: f,
    settled: d,
    useBaseFriction: v,
    useBaseDuration: y,
    useFriction: b,
    useDuration: g
  };
  return k;
}
function $7(e, t, n, r, i) {
  const a = i.measure(10), o = i.measure(50), s = Ai(0.1, 0.99);
  let l = !1;
  function c() {
    return !(l || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function u(p) {
    if (!c()) return;
    const h = e.reachedMin(t.get()) ? "min" : "max", m = Ct(e[h] - t.get()), y = n.get() - t.get(), v = s.constrain(m / o);
    n.subtract(y * v), !p && Ct(y) < a && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function f(p) {
    l = !p;
  }
  return {
    constrain: u,
    toggleActive: f
  };
}
function O7(e, t, n, r) {
  const i = Ai(-t + e, n[0]), a = l(), o = c();
  function s() {
    const f = a[0], d = Gr(a), p = a.lastIndexOf(f), h = a.indexOf(d) + 1;
    return Ai(p, h);
  }
  function l() {
    return n.map(i.constrain).map((f) => parseFloat(f.toFixed(3)));
  }
  function c() {
    if (t <= e) return [i.max];
    if (r === "keepSnaps") return a;
    const {
      min: f,
      max: d
    } = s();
    return a.slice(f, d);
  }
  return {
    snapsContained: o
  };
}
function T7(e, t, n) {
  const r = t[0], i = n ? r - e : Gr(t);
  return {
    limit: Ai(i, r)
  };
}
function C7(e, t, n, r) {
  const a = t.min + 0.1, o = t.max + 0.1, {
    reachedMin: s,
    reachedMax: l
  } = Ai(a, o);
  function c(d) {
    return d === 1 ? l(n.get()) : d === -1 ? s(n.get()) : !1;
  }
  function u(d) {
    if (!c(d)) return;
    const p = e * (d * -1);
    r.forEach((h) => h.add(p));
  }
  return {
    loop: u
  };
}
function R7(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(a) {
    return (a - t) / -n;
  }
  return {
    get: r
  };
}
function I7(e, t, n, r, i, a, o) {
  const {
    startEdge: s,
    endEdge: l
  } = e, {
    groupSlides: c
  } = a, u = p().map(t.measure), f = h(), d = m();
  function p() {
    return c(r).map((v) => Gr(v)[l] - v[0][s]).map(Ct);
  }
  function h() {
    return r.map((v) => n[s] - v[s]).map((v) => -Ct(v));
  }
  function m() {
    const g = Gr(f) - Gr(i);
    return c(f).map((b) => b[0]).map((b, k, S) => {
      const _ = !k, $ = k === hf(S);
      return o && _ ? 0 : o && $ ? g : b + u[k];
    });
  }
  return {
    snaps: f,
    snapsAligned: d
  };
}
function A7(e, t, n, r, i) {
  const {
    reachedAny: a,
    removeOffset: o,
    constrain: s
  } = r;
  function l(h) {
    return h.concat().sort((m, y) => Ct(m) - Ct(y))[0];
  }
  function c(h) {
    const m = e ? o(h) : s(h), y = t.map((g) => g - m).map((g) => u(g, 0)).map((g, b) => ({
      diff: g,
      index: b
    })).sort((g, b) => Ct(g.diff) - Ct(b.diff)), {
      index: v
    } = y[0];
    return {
      index: v,
      distance: m
    };
  }
  function u(h, m) {
    const y = [h, h + n, h - n];
    if (!e) return y[0];
    if (!m) return l(y);
    const v = y.filter((g) => Wv(g) === m);
    return l(v);
  }
  function f(h, m) {
    const y = t[h] - i.get(), v = u(y, m);
    return {
      index: h,
      distance: v
    };
  }
  function d(h, m) {
    const y = i.get() + h, {
      index: v,
      distance: g
    } = c(y), b = !e && a(y);
    if (!m || b) return {
      index: v,
      distance: h
    };
    const k = t[v] - g, S = h + u(k, 0);
    return {
      index: v,
      distance: S
    };
  }
  return {
    byDistance: d,
    byIndex: f,
    shortcut: u
  };
}
function P7(e, t, n, r, i, a, o) {
  function s(f) {
    const d = f.distance, p = f.index !== t.get();
    a.add(d), d && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), p && (n.set(t.get()), t.set(f.index), o.emit("select"));
  }
  function l(f, d) {
    const p = r.byDistance(f, d);
    s(p);
  }
  function c(f, d) {
    const p = t.clone().set(f), h = r.byIndex(p.get(), d);
    s(h);
  }
  return {
    distance: l,
    index: c
  };
}
function Oc(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(l) {
    t = o(l);
  }
  function i(l) {
    t += o(l);
  }
  function a(l) {
    t -= o(l);
  }
  function o(l) {
    return Uv(l) ? l : l.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: a
  };
}
function x$(e, t, n) {
  const r = e.scroll === "x" ? o : s, i = n.style;
  let a = !1;
  function o(d) {
    return `translate3d(${d}px,0px,0px)`;
  }
  function s(d) {
    return `translate3d(0px,${d}px,0px)`;
  }
  function l(d) {
    a || (i.transform = r(t.apply(d)));
  }
  function c(d) {
    a = !d;
  }
  function u() {
    a || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: u,
    to: l,
    toggleActive: c
  };
}
function j7(e, t, n, r, i, a, o, s, l) {
  const c = qs(i), u = qs(i).reverse(), f = m().concat(y());
  function d(S, _) {
    return S.reduce(($, j) => $ - i[j], _);
  }
  function p(S, _) {
    return S.reduce(($, j) => d($, _) > 0 ? $.concat([j]) : $, []);
  }
  function h(S, _) {
    const $ = _ === "start", j = $ ? -r : r, B = o.findSlideBounds([j]);
    return S.map((O) => {
      const N = $ ? 0 : -r, q = $ ? r : 0, z = B.filter((D) => D.index === O)[0][$ ? "end" : "start"];
      return {
        index: O,
        slideLocation: Oc(-1),
        translate: x$(e, t, l[O]),
        target: () => s.get() > z ? N : q
      };
    });
  }
  function m() {
    const S = a[0] - 1, _ = p(u, S);
    return h(_, "end");
  }
  function y() {
    const S = n - a[0] - 1, _ = p(c, S);
    return h(_, "start");
  }
  function v() {
    return f.every(({
      index: S
    }) => {
      const _ = c.filter(($) => $ !== S);
      return d(_, n) <= 0.1;
    });
  }
  function g() {
    f.forEach((S) => {
      const {
        target: _,
        translate: $,
        slideLocation: j
      } = S, B = _();
      B !== j.get() && ($.to(B), j.set(B));
    });
  }
  function b() {
    f.forEach((S) => S.translate.clear());
  }
  return {
    canLoop: v,
    clear: b,
    loop: g,
    loopPoints: f
  };
}
function N7(e, t) {
  let n, r = !1;
  function i(s, l) {
    if (!l) return;
    function c(u) {
      for (const f of u)
        if (f.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((u) => {
      r || (qv(l) || l(s, u)) && c(u);
    }), n.observe(e, {
      childList: !0
    });
  }
  function a() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: a
  };
}
function D7(e, t, n, r, i, a, o) {
  const {
    removeOffset: s,
    constrain: l
  } = i, c = 0.5, u = a ? [0, t, -t] : [0], f = p(u, o);
  function d(y) {
    const v = y || 0;
    return n.map((g) => Ai(c, g - c).constrain(g * v));
  }
  function p(y, v) {
    const g = y || u, b = d(v);
    return g.reduce((k, S) => {
      const _ = r.map(($, j) => ({
        start: $ - n[j] + b[j] + S,
        end: $ + e - b[j] + S,
        index: j
      }));
      return k.concat(_);
    }, []);
  }
  function h(y, v) {
    const g = a ? s(y) : l(y);
    return (v || f).reduce((k, S) => {
      const {
        index: _,
        start: $,
        end: j
      } = S, B = k.includes(_), O = $ < g && j > g;
      return !B && O ? k.concat([_]) : k;
    }, []);
  }
  return {
    check: h,
    findSlideBounds: p
  };
}
function M7(e, t, n, r, i, a) {
  const {
    measureSize: o,
    startEdge: s,
    endEdge: l
  } = e, c = n[0] && i, u = h(), f = m(), d = n.map(o), p = y();
  function h() {
    if (!c) return 0;
    const g = n[0];
    return Ct(t[s] - g[s]);
  }
  function m() {
    if (!c) return 0;
    const g = a.getComputedStyle(Gr(r));
    return parseFloat(g.getPropertyValue(`margin-${l}`));
  }
  function y() {
    return n.map((g, b, k) => {
      const S = !b, _ = b === hf(k);
      return S ? d[b] + u : _ ? d[b] + f : k[b + 1][s] - g[s];
    }).map(Ct);
  }
  return {
    slideSizes: d,
    slideSizesWithGaps: p
  };
}
function L7(e, t, n) {
  const r = Uv(n);
  function i(l, c) {
    return qs(l).filter((u) => u % c === 0).map((u) => l.slice(u, u + c));
  }
  function a(l) {
    return qs(l).reduce((c, u) => {
      const d = t.slice(Gr(c), u + 1).reduce((p, h) => p + h, 0);
      return !u || d > e ? c.concat(u) : c;
    }, []).map((c, u, f) => l.slice(c, f[u + 1]));
  }
  function o(l) {
    return r ? i(l, n) : a(l);
  }
  return {
    groupSlides: o
  };
}
function F7(e, t, n, r, i, a, o, s) {
  const {
    align: l,
    axis: c,
    direction: u,
    startIndex: f,
    inViewThreshold: d,
    loop: p,
    duration: h,
    dragFree: m,
    dragThreshold: y,
    slidesToScroll: v,
    skipSnaps: g,
    containScroll: b
  } = a, k = t.getBoundingClientRect(), S = n.map((re) => re.getBoundingClientRect()), _ = x7(u), $ = b7(c, u), j = $.measureSize(k), B = E7(j), O = y7(l, j), N = !p && !!b, q = p || !!b, {
    slideSizes: M,
    slideSizesWithGaps: z
  } = M7($, k, S, n, q, i), D = L7(j, z, v), {
    snaps: R,
    snapsAligned: W
  } = I7($, O, k, S, z, D, N), F = -Gr(R) + Gr(z), {
    snapsContained: A
  } = O7(j, F, W, b), x = N ? A : W, {
    limit: U
  } = T7(F, x, p), Z = b$(hf(x), f, p), E = Z.clone(), X = qs(n), ae = ({
    dragHandler: re,
    scrollBody: Q,
    scrollBounds: _e,
    eventHandler: xe,
    animation: Ce,
    options: {
      loop: We
    }
  }) => {
    const Ie = re.pointerDown();
    We || _e.constrain(Ie);
    const Me = Q.seek().settled();
    Me && !Ie && (Ce.stop(), xe.emit("settle")), Me || xe.emit("scroll");
  }, te = ({
    scrollBody: re,
    translate: Q,
    location: _e,
    offsetLocation: xe,
    scrollLooper: Ce,
    slideLooper: We,
    options: {
      loop: Ie
    }
  }, Me) => {
    const L = re.velocity();
    xe.set(_e.get() - L + L * Me), Ie && (Ce.loop(re.direction()), We.loop()), Q.to(xe.get());
  }, se = {
    start: () => s.start(G),
    stop: () => s.stop(G),
    update: () => ae(G),
    render: (re) => te(G, re)
  }, de = 0.68, pe = x[Z.get()], le = Oc(pe), J = Oc(pe), V = Oc(pe), fe = k7(le, V, h, de), me = A7(p, x, F, U, V), Oe = P7(se, Z, E, me, fe, V, o), I = D7(j, F, M, R, U, p, d), G = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: o,
    containerRect: k,
    slideRects: S,
    animation: se,
    axis: $,
    direction: _,
    dragHandler: w7($, _, e, r, i, V, S7($, i), le, se, Oe, fe, me, Z, o, B, m, y, g, de),
    eventStore: Ws(),
    percentOfView: B,
    index: Z,
    indexPrevious: E,
    limit: U,
    location: le,
    offsetLocation: J,
    options: a,
    resizeHandler: _7(t, o, i, n, $),
    scrollBody: fe,
    scrollBounds: $7(U, le, V, fe, B),
    scrollLooper: C7(F, U, J, [le, J, V]),
    scrollProgress: R7(U),
    scrollSnaps: x,
    scrollTarget: me,
    scrollTo: Oe,
    slideLooper: j7($, _, j, F, z, x, I, J, n),
    slidesHandler: N7(t, o),
    slidesInView: I,
    slideIndexes: X,
    slidesToScroll: D,
    target: V,
    translate: x$($, _, t)
  };
  return G;
}
function B7(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, a = 0;
  function o(f) {
    r || (r = f);
    const d = f - r;
    for (r = f, i += d; i >= t; )
      n.forEach(({
        animation: h
      }) => h.update()), i -= t;
    const p = Ct(i / t);
    n.forEach(({
      animation: h
    }) => h.render(p)), a && e.requestAnimationFrame(o);
  }
  function s(f) {
    n.includes(f) || n.push(f), !a && (a = e.requestAnimationFrame(o));
  }
  function l(f) {
    n = n.filter((d) => d !== f), !n.length && (e.cancelAnimationFrame(a), r = null, i = 0, a = 0);
  }
  function c() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: l,
    reset: c,
    window: e
  };
}
function z7() {
  const e = {};
  let t;
  function n(l) {
    t = l;
  }
  function r(l) {
    return e[l] || [];
  }
  function i(l) {
    return r(l).forEach((c) => c(t, l)), s;
  }
  function a(l, c) {
    return e[l] = r(l).concat([c]), s;
  }
  function o(l, c) {
    return e[l] = r(l).filter((u) => u !== c), s;
  }
  const s = {
    init: n,
    emit: i,
    off: o,
    on: a
  };
  return s;
}
const U7 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function q7(e) {
  function t(a, o) {
    return g$(a, o || {});
  }
  function n(a) {
    const o = a.breakpoints || {}, s = _u(o).filter((l) => e.matchMedia(l).matches).map((l) => o[l]).reduce((l, c) => t(l, c), {});
    return t(a, s);
  }
  function r(a) {
    return a.map((o) => _u(o.breakpoints || {})).reduce((o, s) => o.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function W7(e) {
  let t = [];
  function n(a, o) {
    return t = a.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(o, e)), a.reduce((s, l) => Object.assign(s, {
      [l.name]: l
    }), {});
  }
  function r() {
    t = t.filter((a) => a.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function oo(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, a = q7(i), o = W7(a), s = Ws(), l = Ws(), c = z7(), {
    animationRealms: u
  } = oo, {
    mergeOptions: f,
    optionsAtMedia: d,
    optionsMediaQueries: p
  } = a, {
    on: h,
    off: m,
    emit: y
  } = c, v = M;
  let g = !1, b, k = f(U7, oo.globalOptions), S = f(k), _ = [], $, j, B;
  function O() {
    const {
      container: fe,
      slides: me
    } = S;
    j = (Mx(fe) ? e.querySelector(fe) : fe) || e.children[0];
    const I = Mx(me) ? j.querySelectorAll(me) : me;
    B = [].slice.call(I || j.children);
  }
  function N(fe, me) {
    const Oe = F7(e, j, B, r, i, fe, c, me);
    if (fe.loop && !Oe.slideLooper.canLoop()) {
      const I = Object.assign({}, fe, {
        loop: !1
      });
      return N(I, me);
    }
    return Oe;
  }
  function q(fe, me) {
    if (g) return;
    const Oe = u.find((G) => G.window === i), I = Oe || B7(i);
    Oe || u.push(I), k = f(k, fe), S = d(k), _ = me || _, O(), b = N(S, I), p([k, ..._.map(({
      options: G
    }) => G)]).forEach((G) => s.add(G, "change", M)), S.active && (b.translate.to(b.location.get()), b.eventHandler.init(V), b.resizeHandler.init(V, S.watchResize), b.slidesHandler.init(V, S.watchSlides), l.add(r, "visibilitychange", () => {
      r.hidden && I.reset();
    }), b.options.loop && b.slideLooper.loop(), j.offsetParent && B.length && b.dragHandler.init(V, S.watchDrag), $ = o.init(_, V));
  }
  function M(fe, me) {
    const Oe = ae();
    z(), q(f({
      startIndex: Oe
    }, fe), me), c.emit("reInit");
  }
  function z() {
    b.dragHandler.destroy(), b.animation.stop(), b.eventStore.clear(), b.translate.clear(), b.slideLooper.clear(), b.resizeHandler.destroy(), b.slidesHandler.destroy(), o.destroy(), s.clear(), l.clear();
  }
  function D() {
    g || (g = !0, s.clear(), z(), c.emit("destroy"));
  }
  function R(fe) {
    const me = b[fe ? "target" : "location"].get(), Oe = S.loop ? "removeOffset" : "constrain";
    return b.slidesInView.check(b.limit[Oe](me));
  }
  function W(fe) {
    const me = R(fe);
    return b.slideIndexes.filter((Oe) => !me.includes(Oe));
  }
  function F(fe, me, Oe) {
    !S.active || g || (b.scrollBody.useBaseFriction().useDuration(me ? 0 : S.duration), b.scrollTo.index(fe, Oe || 0));
  }
  function A(fe) {
    const me = b.index.add(1).get();
    F(me, fe === !0, -1);
  }
  function x(fe) {
    const me = b.index.add(-1).get();
    F(me, fe === !0, 1);
  }
  function U() {
    return b.index.add(1).get() !== ae();
  }
  function Z() {
    return b.index.add(-1).get() !== ae();
  }
  function E() {
    return b.scrollSnaps.map(b.scrollProgress.get);
  }
  function X() {
    return b.scrollProgress.get(b.location.get());
  }
  function ae() {
    return b.index.get();
  }
  function te() {
    return b.indexPrevious.get();
  }
  function se() {
    return $;
  }
  function de() {
    return b;
  }
  function pe() {
    return e;
  }
  function le() {
    return j;
  }
  function J() {
    return B;
  }
  const V = {
    canScrollNext: U,
    canScrollPrev: Z,
    containerNode: le,
    internalEngine: de,
    destroy: D,
    off: m,
    on: h,
    emit: y,
    plugins: se,
    previousScrollSnap: te,
    reInit: v,
    rootNode: pe,
    scrollNext: A,
    scrollPrev: x,
    scrollProgress: X,
    scrollSnapList: E,
    scrollTo: F,
    selectedScrollSnap: ae,
    slideNodes: J,
    slidesInView: R,
    slidesNotInView: W
  };
  return q(t, n), setTimeout(() => c.emit("init"), 0), V;
}
oo.animationRealms = [];
oo.globalOptions = void 0;
function Hv(e = {}, t = []) {
  const n = Pt(e), r = Pt(t), [i, a] = ht(), [o, s] = ht(), l = Et(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return $t(() => {
    if (m7() && o) {
      oo.globalOptions = Hv.globalOptions;
      const c = oo(o, n.current, r.current);
      return a(c), () => c.destroy();
    } else
      a(void 0);
  }, [o, a]), $t(() => {
    zv(n.current, e) || (n.current = e, l());
  }, [e, l]), $t(() => {
    v7(r.current, t) || (r.current = t, l());
  }, [t, l]), [s, i];
}
Hv.globalOptions = void 0;
function H7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M15.75 2.25H21a.75.75 0 0 1 .75.75v5.25a.75.75 0 0 1-1.5 0V4.81L8.03 17.03a.75.75 0 0 1-1.06-1.06L19.19 3.75h-3.44a.75.75 0 0 1 0-1.5Zm-10.5 4.5a1.5 1.5 0 0 0-1.5 1.5v10.5a1.5 1.5 0 0 0 1.5 1.5h10.5a1.5 1.5 0 0 0 1.5-1.5V10.5a.75.75 0 0 1 1.5 0v8.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V8.25a3 3 0 0 1 3-3h8.25a.75.75 0 0 1 0 1.5H5.25Z",
    clipRule: "evenodd"
  }));
}
const V7 = /* @__PURE__ */ w.forwardRef(H7);
function Z7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 0 1 0-1.06l7.5-7.5a.75.75 0 1 1 1.06 1.06L9.31 12l6.97 6.97a.75.75 0 1 1-1.06 1.06l-7.5-7.5Z",
    clipRule: "evenodd"
  }));
}
const K7 = /* @__PURE__ */ w.forwardRef(Z7);
function G7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
    clipRule: "evenodd"
  }));
}
const Y7 = /* @__PURE__ */ w.forwardRef(G7);
function J7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a1.875 1.875 0 0 1-1.875-1.875V5.25A3.75 3.75 0 0 0 9 1.5H5.625ZM7.5 15a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 7.5 15Zm.75 2.25a.75.75 0 0 0 0 1.5H12a.75.75 0 0 0 0-1.5H8.25Z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ w.createElement("path", {
    d: "M12.971 1.816A5.23 5.23 0 0 1 14.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 0 1 3.434 1.279 9.768 9.768 0 0 0-6.963-6.963Z"
  }));
}
const X7 = /* @__PURE__ */ w.forwardRef(J7);
function Q7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    d: "M1.5 8.67v8.58a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V8.67l-8.928 5.493a3 3 0 0 1-3.144 0L1.5 8.67Z"
  }), /* @__PURE__ */ w.createElement("path", {
    d: "M22.5 6.908V6.75a3 3 0 0 0-3-3h-15a3 3 0 0 0-3 3v.158l9.714 5.978a1.5 1.5 0 0 0 1.572 0L22.5 6.908Z"
  }));
}
const e9 = /* @__PURE__ */ w.forwardRef(Q7);
function t9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    d: "M21.721 12.752a9.711 9.711 0 0 0-.945-5.003 12.754 12.754 0 0 1-4.339 2.708 18.991 18.991 0 0 1-.214 4.772 17.165 17.165 0 0 0 5.498-2.477ZM14.634 15.55a17.324 17.324 0 0 0 .332-4.647c-.952.227-1.945.347-2.966.347-1.021 0-2.014-.12-2.966-.347a17.515 17.515 0 0 0 .332 4.647 17.385 17.385 0 0 0 5.268 0ZM9.772 17.119a18.963 18.963 0 0 0 4.456 0A17.182 17.182 0 0 1 12 21.724a17.18 17.18 0 0 1-2.228-4.605ZM7.777 15.23a18.87 18.87 0 0 1-.214-4.774 12.753 12.753 0 0 1-4.34-2.708 9.711 9.711 0 0 0-.944 5.004 17.165 17.165 0 0 0 5.498 2.477ZM21.356 14.752a9.765 9.765 0 0 1-7.478 6.817 18.64 18.64 0 0 0 1.988-4.718 18.627 18.627 0 0 0 5.49-2.098ZM2.644 14.752c1.682.971 3.53 1.688 5.49 2.099a18.64 18.64 0 0 0 1.988 4.718 9.765 9.765 0 0 1-7.478-6.816ZM13.878 2.43a9.755 9.755 0 0 1 6.116 3.986 11.267 11.267 0 0 1-3.746 2.504 18.63 18.63 0 0 0-2.37-6.49ZM12 2.276a17.152 17.152 0 0 1 2.805 7.121c-.897.23-1.837.353-2.805.353-.968 0-1.908-.122-2.805-.353A17.151 17.151 0 0 1 12 2.276ZM10.122 2.43a18.629 18.629 0 0 0-2.37 6.49 11.266 11.266 0 0 1-3.746-2.504 9.754 9.754 0 0 1 6.116-3.985Z"
  }));
}
const n9 = /* @__PURE__ */ w.forwardRef(t9);
function r9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M12 1.5a5.25 5.25 0 0 0-5.25 5.25v3a3 3 0 0 0-3 3v6.75a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3v-6.75a3 3 0 0 0-3-3v-3c0-2.9-2.35-5.25-5.25-5.25Zm3.75 8.25v-3a3.75 3.75 0 1 0-7.5 0v3h7.5Z",
    clipRule: "evenodd"
  }));
}
const i9 = /* @__PURE__ */ w.forwardRef(r9);
function a9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M1.5 4.5a3 3 0 0 1 3-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 0 1-.694 1.955l-1.293.97c-.135.101-.164.249-.126.352a11.285 11.285 0 0 0 6.697 6.697c.103.038.25.009.352-.126l.97-1.293a1.875 1.875 0 0 1 1.955-.694l4.423 1.105c.834.209 1.42.959 1.42 1.82V19.5a3 3 0 0 1-3 3h-2.25C8.552 22.5 1.5 15.448 1.5 6.75V4.5Z",
    clipRule: "evenodd"
  }));
}
const o9 = /* @__PURE__ */ w.forwardRef(a9), s9 = _n(({ blocks: e, direction: t, sender: n, timestamp: r, metadata: i }, a) => {
  const [o, s] = Hv({ skipSnaps: !0, loop: !0 }), [l, c] = ht(!0), [u, f] = ht(!0), d = Et(() => s == null ? void 0 : s.scrollPrev(), [s]), p = Et(() => s == null ? void 0 : s.scrollNext(), [s]), {
    message: {
      blocks: { carousel: h }
    }
  } = xt, m = Et((y) => {
    c(!y.canScrollPrev()), f(!y.canScrollNext());
  }, []);
  return $t(() => {
    s && (m(s), s.on("reInit", m), s.on("select", m));
  }, [s, m]), /* @__PURE__ */ C.jsxs("div", { ...h == null ? void 0 : h.container, "data-container": "carousel", ref: o, children: [
    /* @__PURE__ */ C.jsx("div", { ref: a, ...h == null ? void 0 : h.slidesContainer, children: e.map((y, v) => /* @__PURE__ */ C.jsx(hl, { block: y, direction: t, sender: n, timestamp: r, metadata: i }, v)) }),
    e.length > 1 && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsx(
        K7,
        {
          ...h == null ? void 0 : h.backButton,
          "data-disabled": l ? "" : void 0,
          onClick: d
        }
      ),
      /* @__PURE__ */ C.jsx(
        Y7,
        {
          ...h == null ? void 0 : h.nextButton,
          "data-disabled": u ? "" : void 0,
          onClick: p
        }
      )
    ] })
  ] });
}), Fx = Math.floor;
function w$(e) {
  return S$(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function dl(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function l9(e) {
  var t;
  return (t = (S$(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function S$(e) {
  return e instanceof Node || e instanceof dl(e).Node;
}
function zn(e) {
  return e instanceof Element || e instanceof dl(e).Element;
}
function so(e) {
  return e instanceof HTMLElement || e instanceof dl(e).HTMLElement;
}
function Xh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof dl(e).ShadowRoot;
}
function c9(e) {
  return ["html", "body", "#document"].includes(w$(e));
}
function u9(e) {
  return dl(e).getComputedStyle(e);
}
function f9(e) {
  if (w$(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Xh(e) && e.host || // Fallback.
    l9(e)
  );
  return Xh(t) ? t.host : t;
}
function vi(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function xn(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Xh(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function E$() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function d9() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function _$(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(E$()) || t.test(d9())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function k$(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function $$() {
  return /apple/i.test(navigator.vendor);
}
function p9() {
  return E$().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function Bx(e, t) {
  return ["mouse", "pen"].includes(e);
}
function h9(e) {
  return "nativeEvent" in e;
}
function m9(e) {
  return e.matches("html,body");
}
function nr(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function jd(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function O$(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const v9 = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function T$(e) {
  return so(e) && e.matches(v9);
}
function en(e) {
  e.preventDefault(), e.stopPropagation();
}
const Vv = "ArrowUp", mf = "ArrowDown", lo = "ArrowLeft", pl = "ArrowRight";
function Hl(e, t, n) {
  return Math.floor(e / t) !== n;
}
function as(e, t) {
  return t < 0 || t >= e.current.length;
}
function Nd(e, t) {
  return an(e, {
    disabledIndices: t
  });
}
function zx(e, t) {
  return an(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function an(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: a = 1
  } = t === void 0 ? {} : t;
  const o = e.current;
  let s = n;
  do {
    var l, c;
    s = s + (r ? -a : a);
  } while (s >= 0 && s <= o.length - 1 && (i ? i.includes(s) : o[s] == null || (l = o[s]) != null && l.hasAttribute("disabled") || ((c = o[s]) == null ? void 0 : c.getAttribute("aria-disabled")) === "true"));
  return s;
}
function g9(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: a,
    disabledIndices: o,
    minIndex: s,
    maxIndex: l,
    prevIndex: c,
    stopEvent: u = !1
  } = t, f = c;
  if (n.key === Vv) {
    if (u && en(n), c === -1)
      f = l;
    else if (f = an(e, {
      startingIndex: f,
      amount: a,
      decrement: !0,
      disabledIndices: o
    }), i && (c - a < s || f < 0)) {
      const d = c % a, p = l % a, h = l - (p - d);
      p === d ? f = l : f = p > d ? h : h - a;
    }
    as(e, f) && (f = c);
  }
  if (n.key === mf && (u && en(n), c === -1 ? f = s : (f = an(e, {
    startingIndex: c,
    amount: a,
    disabledIndices: o
  }), i && c + a > l && (f = an(e, {
    startingIndex: c % a - a,
    amount: a,
    disabledIndices: o
  }))), as(e, f) && (f = c)), r === "both") {
    const d = Fx(c / a);
    n.key === pl && (u && en(n), c % a !== a - 1 ? (f = an(e, {
      startingIndex: c,
      disabledIndices: o
    }), i && Hl(f, a, d) && (f = an(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    }))) : i && (f = an(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    })), Hl(f, a, d) && (f = c)), n.key === lo && (u && en(n), c % a !== 0 ? (f = an(e, {
      startingIndex: c,
      disabledIndices: o,
      decrement: !0
    }), i && Hl(f, a, d) && (f = an(e, {
      startingIndex: c + (a - c % a),
      decrement: !0,
      disabledIndices: o
    }))) : i && (f = an(e, {
      startingIndex: c + (a - c % a),
      decrement: !0,
      disabledIndices: o
    })), Hl(f, a, d) && (f = c));
    const p = Fx(l / a) === d;
    as(e, f) && (i && p ? f = n.key === lo ? l : an(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    }) : f = c);
  }
  return f;
}
let Ux = 0;
function Zr(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(Ux);
  const a = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? a() : Ux = requestAnimationFrame(a);
}
var Ht = typeof document < "u" ? mo : $t;
function ku() {
  return ku = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ku.apply(this, arguments);
}
let Dd = !1, y9 = 0;
const qx = () => "floating-ui-" + y9++;
function b9() {
  const [e, t] = w.useState(() => Dd ? qx() : void 0);
  return Ht(() => {
    e == null && t(qx());
  }, []), w.useEffect(() => {
    Dd || (Dd = !0);
  }, []), e;
}
const x9 = w.useId, Zv = x9 || b9;
function w9() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const S9 = /* @__PURE__ */ w.createContext(null), E9 = /* @__PURE__ */ w.createContext(null), C$ = () => {
  var e;
  return ((e = w.useContext(S9)) == null ? void 0 : e.id) || null;
}, vf = () => w.useContext(E9);
function Hs(e) {
  return "data-floating-ui-" + e;
}
function xi(e) {
  const t = Pt(e);
  return Ht(() => {
    t.current = e;
  }), t;
}
function _9(e, t) {
  var n;
  let r = [], i = (n = e.find((a) => a.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const a = e.find((o) => o.id === i);
    i = a == null ? void 0 : a.parentId, a && (r = r.concat(a));
  }
  return r;
}
function Wa(e, t) {
  let n = e.filter((i) => {
    var a;
    return i.parentId === t && ((a = i.context) == null ? void 0 : a.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var a;
      return (a = r) == null ? void 0 : a.some((o) => {
        var s;
        return i.parentId === o.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function k9(e, t) {
  let n, r = -1;
  function i(a, o) {
    o > r && (n = a, r = o), Wa(e, a).forEach((l) => {
      i(l.id, o + 1);
    });
  }
  return i(t, 0), e.find((a) => a.id === n);
}
let Sa = /* @__PURE__ */ new WeakMap(), Vl = /* @__PURE__ */ new WeakSet(), Zl = {}, Md = 0;
const $9 = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, R$ = (e) => e && (e.host || R$(e.parentNode)), O9 = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = R$(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function T9(e, t, n, r) {
  const i = "data-floating-ui-inert", a = r ? "inert" : n ? "aria-hidden" : null, o = O9(t, e), s = /* @__PURE__ */ new Set(), l = new Set(o), c = [];
  Zl[i] || (Zl[i] = /* @__PURE__ */ new WeakMap());
  const u = Zl[i];
  o.forEach(f), d(t), s.clear();
  function f(p) {
    !p || s.has(p) || (s.add(p), p.parentNode && f(p.parentNode));
  }
  function d(p) {
    !p || l.has(p) || Array.prototype.forEach.call(p.children, (h) => {
      if (s.has(h))
        d(h);
      else {
        const m = a ? h.getAttribute(a) : null, y = m !== null && m !== "false", v = (Sa.get(h) || 0) + 1, g = (u.get(h) || 0) + 1;
        Sa.set(h, v), u.set(h, g), c.push(h), v === 1 && y && Vl.add(h), g === 1 && h.setAttribute(i, ""), !y && a && h.setAttribute(a, "true");
      }
    });
  }
  return Md++, () => {
    c.forEach((p) => {
      const h = (Sa.get(p) || 0) - 1, m = (u.get(p) || 0) - 1;
      Sa.set(p, h), u.set(p, m), h || (!Vl.has(p) && a && p.removeAttribute(a), Vl.delete(p)), m || p.removeAttribute(i);
    }), Md--, Md || (Sa = /* @__PURE__ */ new WeakMap(), Sa = /* @__PURE__ */ new WeakMap(), Vl = /* @__PURE__ */ new WeakSet(), Zl = {});
  };
}
function Wx(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = nr(e[0]).body;
  return T9(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const Kv = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function I$(e, t) {
  const n = Fv(e, Kv());
  t === "prev" && n.reverse();
  const r = n.indexOf(vi(nr(e)));
  return n.slice(r + 1)[0];
}
function A$() {
  return I$(document.body, "next");
}
function P$() {
  return I$(document.body, "prev");
}
function os(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !xn(n, r);
}
function C9(e) {
  Fv(e, Kv()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function R9(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const Gv = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let I9;
function Hx(e) {
  e.key === "Tab" && (e.target, clearTimeout(I9));
}
const $u = /* @__PURE__ */ w.forwardRef(function(t, n) {
  const [r, i] = w.useState();
  Ht(() => ($$() && i("button"), document.addEventListener("keydown", Hx), () => {
    document.removeEventListener("keydown", Hx);
  }), []);
  const a = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [Hs("focus-guard")]: "",
    style: Gv
  };
  return /* @__PURE__ */ w.createElement("span", ku({}, t, a));
}), j$ = /* @__PURE__ */ w.createContext(null);
function A9(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = w.useState(null), a = Zv(), o = N$(), s = w.useMemo(() => ({
    id: t,
    root: n,
    portalContext: o,
    uniqueId: a
  }), [t, n, o, a]), l = w.useRef();
  return Ht(() => () => {
    r == null || r.remove();
  }, [r, s]), Ht(() => {
    if (l.current === s) return;
    l.current = s;
    const {
      id: c,
      root: u,
      portalContext: f,
      uniqueId: d
    } = s, p = c ? document.getElementById(c) : null, h = Hs("portal");
    if (p) {
      const m = document.createElement("div");
      m.id = d, m.setAttribute(h, ""), p.appendChild(m), i(m);
    } else {
      let m = u || (f == null ? void 0 : f.portalNode);
      m && !zn(m) && (m = m.current), m = m || document.body;
      let y = null;
      c && (y = document.createElement("div"), y.id = c, m.appendChild(y));
      const v = document.createElement("div");
      v.id = d, v.setAttribute(h, ""), m = y || m, m.appendChild(v), i(v);
    }
  }, [s]), r;
}
function P9(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const a = A9({
    id: n,
    root: r
  }), [o, s] = w.useState(null), l = w.useRef(null), c = w.useRef(null), u = w.useRef(null), f = w.useRef(null), d = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!o && // Guards are only for non-modal focus management.
    !o.modal && // Don't render if unmount is transitioning.
    o.open && i && !!(r || a)
  );
  return w.useEffect(() => {
    if (!a || !i || o != null && o.modal)
      return;
    function p(h) {
      a && os(h) && (h.type === "focusin" ? R9 : C9)(a);
    }
    return a.addEventListener("focusin", p, !0), a.addEventListener("focusout", p, !0), () => {
      a.removeEventListener("focusin", p, !0), a.removeEventListener("focusout", p, !0);
    };
  }, [a, i, o == null ? void 0 : o.modal]), /* @__PURE__ */ w.createElement(j$.Provider, {
    value: w.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: l,
      afterOutsideRef: c,
      beforeInsideRef: u,
      afterInsideRef: f,
      portalNode: a,
      setFocusManagerState: s
    }), [i, a])
  }, d && a && /* @__PURE__ */ w.createElement($u, {
    "data-type": "outside",
    ref: l,
    onFocus: (p) => {
      if (os(p, a)) {
        var h;
        (h = u.current) == null || h.focus();
      } else {
        const m = P$() || (o == null ? void 0 : o.refs.domReference.current);
        m == null || m.focus();
      }
    }
  }), d && a && /* @__PURE__ */ w.createElement("span", {
    "aria-owns": a.id,
    style: Gv
  }), a && /* @__PURE__ */ KR(t, a), d && a && /* @__PURE__ */ w.createElement($u, {
    "data-type": "outside",
    ref: c,
    onFocus: (p) => {
      if (os(p, a)) {
        var h;
        (h = f.current) == null || h.focus();
      } else {
        const m = A$() || (o == null ? void 0 : o.refs.domReference.current);
        m == null || m.focus(), o != null && o.closeOnFocusOut && (o == null || o.onOpenChange(!1, p.nativeEvent));
      }
    }
  }));
}
const N$ = () => w.useContext(j$), j9 = /* @__PURE__ */ w.forwardRef(function(t, n) {
  return /* @__PURE__ */ w.createElement("button", ku({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: Gv
  }));
});
function N9(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: a = !0,
    initialFocus: o = 0,
    returnFocus: s = !0,
    modal: l = !0,
    visuallyHiddenDismiss: c = !1,
    closeOnFocusOut: u = !0
  } = e, {
    open: f,
    refs: d,
    nodeId: p,
    onOpenChange: h,
    events: m,
    dataRef: y,
    elements: {
      domReference: v,
      floating: g
    }
  } = t, b = $9() ? a : !0, k = xi(i), S = xi(o), _ = xi(s), $ = vf(), j = N$(), B = typeof o == "number" && o < 0, O = w.useRef(null), N = w.useRef(null), q = w.useRef(!1), M = w.useRef(null), z = w.useRef(!1), D = j != null, R = v && v.getAttribute("role") === "combobox" && T$(v) && B, W = w.useCallback(function(U) {
    return U === void 0 && (U = g), U ? Fv(U, Kv()) : [];
  }, [g]), F = w.useCallback((U) => {
    const Z = W(U);
    return k.current.map((E) => v && E === "reference" ? v : g && E === "floating" ? g : Z).filter(Boolean).flat();
  }, [v, g, k, W]);
  w.useEffect(() => {
    if (r || !l) return;
    function U(E) {
      if (E.key === "Tab") {
        xn(g, vi(nr(g))) && W().length === 0 && !R && en(E);
        const X = F(), ae = O$(E);
        k.current[0] === "reference" && ae === v && (en(E), E.shiftKey ? Zr(X[X.length - 1]) : Zr(X[1])), k.current[1] === "floating" && ae === g && E.shiftKey && (en(E), Zr(X[0]));
      }
    }
    const Z = nr(g);
    return Z.addEventListener("keydown", U), () => {
      Z.removeEventListener("keydown", U);
    };
  }, [r, v, g, l, k, d, R, W, F]), w.useEffect(() => {
    if (r || !u) return;
    function U() {
      z.current = !0, setTimeout(() => {
        z.current = !1;
      });
    }
    function Z(E) {
      const X = E.relatedTarget;
      queueMicrotask(() => {
        const ae = !(xn(v, X) || xn(g, X) || xn(X, g) || xn(j == null ? void 0 : j.portalNode, X) || X != null && X.hasAttribute(Hs("focus-guard")) || $ && (Wa($.nodesRef.current, p).find((te) => {
          var se, de;
          return xn((se = te.context) == null ? void 0 : se.elements.floating, X) || xn((de = te.context) == null ? void 0 : de.elements.domReference, X);
        }) || _9($.nodesRef.current, p).find((te) => {
          var se, de;
          return ((se = te.context) == null ? void 0 : se.elements.floating) === X || ((de = te.context) == null ? void 0 : de.elements.domReference) === X;
        })));
        X && ae && !z.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        X !== M.current && (q.current = !0, h(!1, E));
      });
    }
    if (g && so(v))
      return v.addEventListener("focusout", Z), v.addEventListener("pointerdown", U), !l && g.addEventListener("focusout", Z), () => {
        v.removeEventListener("focusout", Z), v.removeEventListener("pointerdown", U), !l && g.removeEventListener("focusout", Z);
      };
  }, [r, v, g, l, p, $, j, h, u]), w.useEffect(() => {
    var U;
    if (r) return;
    const Z = Array.from((j == null || (U = j.portalNode) == null ? void 0 : U.querySelectorAll("[" + Hs("portal") + "]")) || []);
    if (g) {
      const E = [g, ...Z, O.current, N.current, k.current.includes("reference") || R ? v : null].filter((ae) => ae != null), X = l ? Wx(E, b, !b) : Wx(E);
      return () => {
        X();
      };
    }
  }, [r, v, g, l, k, j, R, b]), Ht(() => {
    if (r || !g) return;
    const U = nr(g), Z = vi(U);
    queueMicrotask(() => {
      const E = F(g), X = S.current, ae = (typeof X == "number" ? E[X] : X.current) || g, te = xn(g, Z);
      !B && !te && f && Zr(ae, {
        preventScroll: ae === g
      });
    });
  }, [r, f, g, B, F, S]), Ht(() => {
    if (r || !g) return;
    let U = !1;
    const Z = nr(g), E = vi(Z), X = y.current;
    M.current = E;
    function ae(te) {
      if (te.type === "escapeKey" && d.domReference.current && (M.current = d.domReference.current), ["referencePress", "escapeKey"].includes(te.type))
        return;
      const se = te.data.returnFocus;
      typeof se == "object" ? (q.current = !1, U = se.preventScroll) : q.current = !se;
    }
    return m.on("dismiss", ae), () => {
      m.off("dismiss", ae);
      const te = vi(Z);
      (xn(g, te) || $ && Wa($.nodesRef.current, p).some((de) => {
        var pe;
        return xn((pe = de.context) == null ? void 0 : pe.elements.floating, te);
      }) || X.openEvent && ["click", "mousedown"].includes(X.openEvent.type)) && d.domReference.current && (M.current = d.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      _.current && so(M.current) && !q.current && Zr(M.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored  leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: U
      });
    };
  }, [r, g, _, y, d, m, $, p]), Ht(() => {
    if (!(r || !j))
      return j.setFocusManagerState({
        modal: l,
        closeOnFocusOut: u,
        open: f,
        onOpenChange: h,
        refs: d
      }), () => {
        j.setFocusManagerState(null);
      };
  }, [r, j, l, f, h, d, u]), Ht(() => {
    if (!r && g && typeof MutationObserver == "function" && !B) {
      const U = () => {
        const E = g.getAttribute("tabindex");
        k.current.includes("floating") || vi(nr(g)) !== d.domReference.current && W().length === 0 ? E !== "0" && g.setAttribute("tabindex", "0") : E !== "-1" && g.setAttribute("tabindex", "-1");
      };
      U();
      const Z = new MutationObserver(U);
      return Z.observe(g, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        Z.disconnect();
      };
    }
  }, [r, g, d, k, W, B]);
  function A(U) {
    return r || !c || !l ? null : /* @__PURE__ */ w.createElement(j9, {
      ref: U === "start" ? O : N,
      onClick: (Z) => h(!1, Z.nativeEvent)
    }, typeof c == "string" ? c : "Dismiss");
  }
  const x = !r && b && !R && (D || l);
  return /* @__PURE__ */ w.createElement(w.Fragment, null, x && /* @__PURE__ */ w.createElement($u, {
    "data-type": "inside",
    ref: j == null ? void 0 : j.beforeInsideRef,
    onFocus: (U) => {
      if (l) {
        const E = F();
        Zr(i[0] === "reference" ? E[0] : E[E.length - 1]);
      } else if (j != null && j.preserveTabOrder && j.portalNode)
        if (q.current = !1, os(U, j.portalNode)) {
          const E = A$() || v;
          E == null || E.focus();
        } else {
          var Z;
          (Z = j.beforeOutsideRef.current) == null || Z.focus();
        }
    }
  }), !R && A("start"), n, A("end"), x && /* @__PURE__ */ w.createElement($u, {
    "data-type": "inside",
    ref: j == null ? void 0 : j.afterInsideRef,
    onFocus: (U) => {
      if (l)
        Zr(F()[0]);
      else if (j != null && j.preserveTabOrder && j.portalNode)
        if (u && (q.current = !0), os(U, j.portalNode)) {
          const E = P$() || v;
          E == null || E.focus();
        } else {
          var Z;
          (Z = j.afterOutsideRef.current) == null || Z.focus();
        }
    }
  }));
}
function Vx(e) {
  return so(e.target) && e.target.tagName === "BUTTON";
}
function Zx(e) {
  return T$(e);
}
function D9(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: a
    }
  } = e, {
    enabled: o = !0,
    event: s = "click",
    toggle: l = !0,
    ignoreMouse: c = !1,
    keyboardHandlers: u = !0
  } = t, f = w.useRef(), d = w.useRef(!1);
  return w.useMemo(() => o ? {
    reference: {
      onPointerDown(p) {
        f.current = p.pointerType;
      },
      onMouseDown(p) {
        p.button === 0 && (Bx(f.current) && c || s !== "click" && (n && l && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, p.nativeEvent) : (p.preventDefault(), r(!0, p.nativeEvent))));
      },
      onClick(p) {
        if (s === "mousedown" && f.current) {
          f.current = void 0;
          return;
        }
        Bx(f.current) && c || (n && l && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, p.nativeEvent) : r(!0, p.nativeEvent));
      },
      onKeyDown(p) {
        f.current = void 0, !(p.defaultPrevented || !u || Vx(p)) && (p.key === " " && !Zx(a) && (p.preventDefault(), d.current = !0), p.key === "Enter" && r(!(n && l), p.nativeEvent));
      },
      onKeyUp(p) {
        p.defaultPrevented || !u || Vx(p) || Zx(a) || p.key === " " && d.current && (d.current = !1, r(!(n && l), p.nativeEvent));
      }
    }
  } : {}, [o, i, s, c, u, a, l, n, r]);
}
const M9 = w.useInsertionEffect, L9 = M9 || ((e) => e());
function wi(e) {
  const t = w.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return L9(() => {
    t.current = e;
  }), w.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const F9 = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, B9 = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, z9 = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function U9(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: a,
    elements: {
      reference: o,
      domReference: s,
      floating: l
    },
    dataRef: c
  } = e, {
    enabled: u = !0,
    escapeKey: f = !0,
    outsidePress: d = !0,
    outsidePressEvent: p = "pointerdown",
    referencePress: h = !1,
    referencePressEvent: m = "pointerdown",
    ancestorScroll: y = !1,
    bubbles: v
  } = t, g = vf(), b = C$() != null, k = wi(typeof d == "function" ? d : () => !1), S = typeof d == "function" ? k : d, _ = w.useRef(!1), {
    escapeKeyBubbles: $,
    outsidePressBubbles: j
  } = z9(v), B = wi((N) => {
    if (!n || !u || !f || N.key !== "Escape")
      return;
    const q = g ? Wa(g.nodesRef.current, a) : [];
    if (!$ && (N.stopPropagation(), q.length > 0)) {
      let M = !0;
      if (q.forEach((z) => {
        var D;
        if ((D = z.context) != null && D.open && !z.context.dataRef.current.__escapeKeyBubbles) {
          M = !1;
          return;
        }
      }), !M)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, h9(N) ? N.nativeEvent : N);
  }), O = wi((N) => {
    const q = _.current;
    if (_.current = !1, q || typeof S == "function" && !S(N))
      return;
    const M = O$(N), z = "[" + Hs("inert") + "]", D = nr(l).querySelectorAll(z);
    let R = zn(M) ? M : null;
    for (; R && !c9(R); ) {
      const A = f9(R);
      if (A === nr(l).body || !zn(A))
        break;
      R = A;
    }
    if (D.length && zn(M) && !m9(M) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !xn(M, l) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(D).every((A) => !xn(R, A)))
      return;
    if (so(M) && l) {
      const A = M.clientWidth > 0 && M.scrollWidth > M.clientWidth, x = M.clientHeight > 0 && M.scrollHeight > M.clientHeight;
      let U = x && N.offsetX > M.clientWidth;
      if (x && u9(M).direction === "rtl" && (U = N.offsetX <= M.offsetWidth - M.clientWidth), U || A && N.offsetY > M.clientHeight)
        return;
    }
    const W = g && Wa(g.nodesRef.current, a).some((A) => {
      var x;
      return jd(N, (x = A.context) == null ? void 0 : x.elements.floating);
    });
    if (jd(N, l) || jd(N, s) || W)
      return;
    const F = g ? Wa(g.nodesRef.current, a) : [];
    if (F.length > 0) {
      let A = !0;
      if (F.forEach((x) => {
        var U;
        if ((U = x.context) != null && U.open && !x.context.dataRef.current.__outsidePressBubbles) {
          A = !1;
          return;
        }
      }), !A)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: b ? {
          preventScroll: !0
        } : _$(N) || k$(N)
      }
    }), r(!1, N);
  });
  return w.useEffect(() => {
    if (!n || !u)
      return;
    c.current.__escapeKeyBubbles = $, c.current.__outsidePressBubbles = j;
    function N(z) {
      r(!1, z);
    }
    const q = nr(l);
    f && q.addEventListener("keydown", B), S && q.addEventListener(p, O);
    let M = [];
    return y && (zn(s) && (M = bi(s)), zn(l) && (M = M.concat(bi(l))), !zn(o) && o && o.contextElement && (M = M.concat(bi(o.contextElement)))), M = M.filter((z) => {
      var D;
      return z !== ((D = q.defaultView) == null ? void 0 : D.visualViewport);
    }), M.forEach((z) => {
      z.addEventListener("scroll", N, {
        passive: !0
      });
    }), () => {
      f && q.removeEventListener("keydown", B), S && q.removeEventListener(p, O), M.forEach((z) => {
        z.removeEventListener("scroll", N);
      });
    };
  }, [c, l, s, o, f, S, p, n, r, y, u, $, j, B, O]), w.useEffect(() => {
    _.current = !1;
  }, [S, p]), w.useMemo(() => u ? {
    reference: {
      onKeyDown: B,
      [F9[m]]: (N) => {
        h && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, N.nativeEvent));
      }
    },
    floating: {
      onKeyDown: B,
      [B9[p]]: () => {
        _.current = !0;
      }
    }
  } : {}, [u, i, h, p, m, r, B]);
}
let Qh;
process.env.NODE_ENV !== "production" && (Qh = /* @__PURE__ */ new Set());
function q9(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var a;
    const $ = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((a = e.elements) != null && a.reference && !zn(e.elements.reference)) {
      var o;
      if (!((o = Qh) != null && o.has($))) {
        var s;
        (s = Qh) == null || s.add($), console.error($);
      }
    }
  }
  const [l, c] = w.useState(null), u = ((t = e.elements) == null ? void 0 : t.reference) || l, f = hU(e), d = vf(), p = wi(($, j) => {
    $ && (m.current.openEvent = j), r == null || r($, j);
  }), h = w.useRef(null), m = w.useRef({}), y = w.useState(() => w9())[0], v = Zv(), g = w.useCallback(($) => {
    const j = zn($) ? {
      getBoundingClientRect: () => $.getBoundingClientRect(),
      contextElement: $
    } : $;
    f.refs.setReference(j);
  }, [f.refs]), b = w.useCallback(($) => {
    (zn($) || $ === null) && (h.current = $, c($)), (zn(f.refs.reference.current) || f.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    $ !== null && !zn($)) && f.refs.setReference($);
  }, [f.refs]), k = w.useMemo(() => ({
    ...f.refs,
    setReference: b,
    setPositionReference: g,
    domReference: h
  }), [f.refs, b, g]), S = w.useMemo(() => ({
    ...f.elements,
    domReference: u
  }), [f.elements, u]), _ = w.useMemo(() => ({
    ...f,
    refs: k,
    elements: S,
    dataRef: m,
    nodeId: i,
    floatingId: v,
    events: y,
    open: n,
    onOpenChange: p
  }), [f, i, v, y, n, p, k, S]);
  return Ht(() => {
    const $ = d == null ? void 0 : d.nodesRef.current.find((j) => j.id === i);
    $ && ($.context = _);
  }), w.useMemo(() => ({
    ...f,
    context: _,
    refs: k,
    elements: S
  }), [f, k, S, _]);
}
function Ld(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, a) => (a && Object.entries(a).forEach((o) => {
      let [s, l] = o;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof l == "function") {
          var c;
          (c = r.get(s)) == null || c.push(l), i[s] = function() {
            for (var u, f = arguments.length, d = new Array(f), p = 0; p < f; p++)
              d[p] = arguments[p];
            return (u = r.get(s)) == null ? void 0 : u.map((h) => h(...d)).find((h) => h !== void 0);
          };
        }
      } else
        i[s] = l;
    }), i), {})
  };
}
function W9(e) {
  e === void 0 && (e = []);
  const t = e, n = w.useCallback(
    (a) => Ld(a, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = w.useCallback(
    (a) => Ld(a, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = w.useCallback(
    (a) => Ld(a, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((a) => a == null ? void 0 : a.item)
  );
  return w.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let Kx = !1;
function gf(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function Gx(e, t) {
  return gf(t, e === Vv || e === mf, e === lo || e === pl);
}
function Fd(e, t, n) {
  return gf(t, e === mf, n ? e === lo : e === pl) || e === "Enter" || e == " " || e === "";
}
function H9(e, t, n) {
  return gf(t, n ? e === lo : e === pl, e === mf);
}
function Yx(e, t, n) {
  return gf(t, n ? e === pl : e === lo, e === Vv);
}
function V9(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: a,
      floating: o
    }
  } = e, {
    listRef: s,
    activeIndex: l,
    onNavigate: c = () => {
    },
    enabled: u = !0,
    selectedIndex: f = null,
    allowEscape: d = !1,
    loop: p = !1,
    nested: h = !1,
    rtl: m = !1,
    virtual: y = !1,
    focusItemOnOpen: v = "auto",
    focusItemOnHover: g = !0,
    openOnArrowKeyDown: b = !0,
    disabledIndices: k = void 0,
    orientation: S = "vertical",
    cols: _ = 1,
    scrollItemIntoView: $ = !0,
    virtualItemRef: j
  } = t;
  process.env.NODE_ENV !== "production" && (d && (p || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), y || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), S === "vertical" && _ > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const B = C$(), O = vf(), N = wi(c), q = w.useRef(v), M = w.useRef(f ?? -1), z = w.useRef(null), D = w.useRef(!0), R = w.useRef(N), W = w.useRef(!!o), F = w.useRef(!1), A = w.useRef(!1), x = xi(k), U = xi(n), Z = xi($), [E, X] = w.useState(), [ae, te] = w.useState(), se = wi(function(le, J, V) {
    V === void 0 && (V = !1);
    const fe = le.current[J.current];
    fe && (y ? (X(fe.id), O == null || O.events.emit("virtualfocus", fe), j && (j.current = fe)) : Zr(fe, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: p9() && $$() ? Kx || F.current : !1
    }), requestAnimationFrame(() => {
      const me = Z.current;
      me && fe && (V || !D.current) && (fe.scrollIntoView == null || fe.scrollIntoView(typeof me == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : me));
    }));
  });
  Ht(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return Kx = !0, !1;
      }
    });
  }, []), Ht(() => {
    u && (n && o ? q.current && f != null && (A.current = !0, N(f)) : W.current && (M.current = -1, R.current(null)));
  }, [u, n, o, f, N]), Ht(() => {
    if (u && n && o)
      if (l == null) {
        if (F.current = !1, f != null)
          return;
        if (W.current && (M.current = -1, se(s, M)), !W.current && q.current && (z.current != null || q.current === !0 && z.current == null)) {
          let le = 0;
          const J = () => {
            s.current[0] == null ? (le < 2 && (le ? requestAnimationFrame : queueMicrotask)(J), le++) : (M.current = z.current == null || Fd(z.current, S, m) || h ? Nd(s, x.current) : zx(s, x.current), z.current = null, N(M.current));
          };
          J();
        }
      } else as(s, l) || (M.current = l, se(s, M, A.current), A.current = !1);
  }, [u, n, o, l, f, h, s, S, m, N, se, x]), Ht(() => {
    var le, J;
    if (!u || o || !O || y || !W.current)
      return;
    const V = O.nodesRef.current, fe = (le = V.find((I) => I.id === B)) == null || (J = le.context) == null ? void 0 : J.elements.floating, me = vi(nr(o)), Oe = V.some((I) => I.context && xn(I.context.elements.floating, me));
    fe && !Oe && D.current && fe.focus({
      preventScroll: !0
    });
  }, [u, o, O, B, y]), Ht(() => {
    if (!u || !O || !y || B) return;
    function le(J) {
      te(J.id), j && (j.current = J);
    }
    return O.events.on("virtualfocus", le), () => {
      O.events.off("virtualfocus", le);
    };
  }, [u, O, y, B, j]), Ht(() => {
    R.current = N, W.current = !!o;
  }), Ht(() => {
    n || (z.current = null);
  }, [n]);
  const de = l != null, pe = w.useMemo(() => {
    function le(V) {
      if (!n) return;
      const fe = s.current.indexOf(V);
      fe !== -1 && N(fe);
    }
    return {
      onFocus(V) {
        let {
          currentTarget: fe
        } = V;
        le(fe);
      },
      onClick: (V) => {
        let {
          currentTarget: fe
        } = V;
        return fe.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...g && {
        onMouseMove(V) {
          let {
            currentTarget: fe
          } = V;
          le(fe);
        },
        onPointerLeave(V) {
          let {
            pointerType: fe
          } = V;
          !D.current || fe === "touch" || (M.current = -1, se(s, M), N(null), y || Zr(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, se, g, s, N, y]);
  return w.useMemo(() => {
    if (!u)
      return {};
    const le = x.current;
    function J(I) {
      if (D.current = !1, F.current = !0, !U.current && I.currentTarget === i.floating.current)
        return;
      if (h && Yx(I.key, S, m)) {
        en(I), r(!1, I.nativeEvent), so(a) && !y && a.focus();
        return;
      }
      const G = M.current, re = Nd(s, le), Q = zx(s, le);
      if (I.key === "Home" && (en(I), M.current = re, N(M.current)), I.key === "End" && (en(I), M.current = Q, N(M.current)), !(_ > 1 && (M.current = g9(s, {
        event: I,
        orientation: S,
        loop: p,
        cols: _,
        disabledIndices: le,
        minIndex: re,
        maxIndex: Q,
        prevIndex: M.current,
        stopEvent: !0
      }), N(M.current), S === "both")) && Gx(I.key, S)) {
        if (en(I), n && !y && vi(I.currentTarget.ownerDocument) === I.currentTarget) {
          M.current = Fd(I.key, S, m) ? re : Q, N(M.current);
          return;
        }
        Fd(I.key, S, m) ? p ? M.current = G >= Q ? d && G !== s.current.length ? -1 : re : an(s, {
          startingIndex: G,
          disabledIndices: le
        }) : M.current = Math.min(Q, an(s, {
          startingIndex: G,
          disabledIndices: le
        })) : p ? M.current = G <= re ? d && G !== -1 ? s.current.length : Q : an(s, {
          startingIndex: G,
          decrement: !0,
          disabledIndices: le
        }) : M.current = Math.max(re, an(s, {
          startingIndex: G,
          decrement: !0,
          disabledIndices: le
        })), as(s, M.current) ? N(null) : N(M.current);
      }
    }
    function V(I) {
      v === "auto" && _$(I.nativeEvent) && (q.current = !0);
    }
    function fe(I) {
      q.current = v, v === "auto" && k$(I.nativeEvent) && (q.current = !0);
    }
    const me = y && n && de && {
      "aria-activedescendant": ae || E
    }, Oe = s.current.find((I) => (I == null ? void 0 : I.id) === E);
    return {
      reference: {
        ...me,
        onKeyDown(I) {
          D.current = !1;
          const G = I.key.indexOf("Arrow") === 0, re = H9(I.key, S, m), Q = Yx(I.key, S, m), _e = Gx(I.key, S), xe = (h ? re : _e) || I.key === "Enter" || I.key.trim() === "";
          if (y && n) {
            const Me = O == null ? void 0 : O.nodesRef.current.find((P) => P.parentId == null), L = O && Me ? k9(O.nodesRef.current, Me.id) : null;
            if (G && L && j) {
              const P = new KeyboardEvent("keydown", {
                key: I.key,
                bubbles: !0
              });
              if (re || Q) {
                var Ce, We;
                const Y = ((Ce = L.context) == null ? void 0 : Ce.elements.domReference) === I.currentTarget, ce = Q && !Y ? (We = L.context) == null ? void 0 : We.elements.domReference : re ? Oe : null;
                ce && (en(I), ce.dispatchEvent(P), te(void 0));
              }
              if (_e && L.context && L.context.open && L.parentId && I.currentTarget !== L.context.elements.domReference) {
                var Ie;
                en(I), (Ie = L.context.elements.domReference) == null || Ie.dispatchEvent(P);
                return;
              }
            }
            return J(I);
          }
          if (!(!n && !b && G)) {
            if (xe && (z.current = h && _e ? null : I.key), h) {
              re && (en(I), n ? (M.current = Nd(s, le), N(M.current)) : r(!0, I.nativeEvent));
              return;
            }
            _e && (f != null && (M.current = f), en(I), !n && b ? r(!0, I.nativeEvent) : J(I), n && N(M.current));
          }
        },
        onFocus() {
          n && N(null);
        },
        onPointerDown: fe,
        onMouseDown: V,
        onClick: V
      },
      floating: {
        "aria-orientation": S === "both" ? void 0 : S,
        ...me,
        onKeyDown: J,
        onPointerMove() {
          D.current = !0;
        }
      },
      item: pe
    };
  }, [a, i, E, ae, x, U, s, u, S, m, y, n, de, h, f, b, d, _, p, v, N, r, pe, O, j]);
}
function Z9(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: a = "dialog"
  } = t, o = Zv();
  return w.useMemo(() => {
    const s = {
      id: r,
      role: a
    };
    return i ? a === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": a === "alertdialog" ? "dialog" : a,
        "aria-controls": n ? r : void 0,
        ...a === "listbox" && {
          role: "combobox"
        },
        ...a === "menu" && {
          id: o
        }
      },
      floating: {
        ...s,
        ...a === "menu" && {
          "aria-labelledby": o
        }
      }
    } : {};
  }, [i, a, n, r, o]);
}
function K9(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: a,
    activeIndex: o,
    onMatch: s,
    onTypingChange: l,
    enabled: c = !0,
    findMatch: u = null,
    resetMs: f = 750,
    ignoreKeys: d = [],
    selectedIndex: p = null
  } = t, h = w.useRef(), m = w.useRef(""), y = w.useRef((n = p ?? o) != null ? n : -1), v = w.useRef(null), g = wi(s), b = wi(l), k = xi(u), S = xi(d);
  return Ht(() => {
    r && (clearTimeout(h.current), v.current = null, m.current = "");
  }, [r]), Ht(() => {
    if (r && m.current === "") {
      var _;
      y.current = (_ = p ?? o) != null ? _ : -1;
    }
  }, [r, p, o]), w.useMemo(() => {
    if (!c)
      return {};
    function _(B) {
      B ? i.current.typing || (i.current.typing = B, b(B)) : i.current.typing && (i.current.typing = B, b(B));
    }
    function $(B, O, N) {
      const q = k.current ? k.current(O, N) : O.find((M) => (M == null ? void 0 : M.toLocaleLowerCase().indexOf(N.toLocaleLowerCase())) === 0);
      return q ? B.indexOf(q) : -1;
    }
    function j(B) {
      const O = a.current;
      if (m.current.length > 0 && m.current[0] !== " " && ($(O, O, m.current) === -1 ? _(!1) : B.key === " " && en(B)), O == null || S.current.includes(B.key) || // Character key.
      B.key.length !== 1 || // Modifier key.
      B.ctrlKey || B.metaKey || B.altKey)
        return;
      r && B.key !== " " && (en(B), _(!0)), O.every((z) => {
        var D, R;
        return z ? ((D = z[0]) == null ? void 0 : D.toLocaleLowerCase()) !== ((R = z[1]) == null ? void 0 : R.toLocaleLowerCase()) : !0;
      }) && m.current === B.key && (m.current = "", y.current = v.current), m.current += B.key, clearTimeout(h.current), h.current = setTimeout(() => {
        m.current = "", y.current = v.current, _(!1);
      }, f);
      const q = y.current, M = $(O, [...O.slice((q || 0) + 1), ...O.slice(0, (q || 0) + 1)], m.current);
      M !== -1 ? (g(M), v.current = M) : B.key !== " " && (m.current = "", _(!1));
    }
    return {
      reference: {
        onKeyDown: j
      },
      floating: {
        onKeyDown: j,
        onKeyUp(B) {
          B.key === " " && _(!1);
        }
      }
    };
  }, [c, r, i, a, f, S, k, g, b]);
}
const G9 = ({ options: e, label: t, reusable: n }) => {
  var D, R, W, F, A;
  const r = De((x) => x.sendTextMessage), i = De((x) => x.messageContainerRef), a = De((x) => x.isReadOnly), [o, s] = w.useState(!1), [l, c] = w.useState(null), [u, f] = w.useState(null), {
    message: {
      blocks: { dropdown: d }
    }
  } = xt, p = e.reduce(
    (x, U) => (x[U.label] = U.value, x),
    {}
  ), h = p ? Object.keys(p) : [], m = (x) => {
    s(u !== null && !n ? !1 : x);
  }, { refs: y, floatingStyles: v, context: g } = q9({
    placement: "bottom-start",
    open: o,
    onOpenChange: m,
    whileElementsMounted: cU,
    middleware: [
      mU(5),
      vU({
        padding: 10,
        boundary: (i == null ? void 0 : i.current) ?? void 0,
        crossAxis: !0
      }),
      gU({
        apply({ rects: x, elements: U, availableHeight: Z }) {
          Object.assign(U.floating.style, {
            maxHeight: `${Z}px`,
            minWidth: `${x.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), b = w.useRef([]), k = w.useRef(h), S = w.useRef(!1), _ = D9(g, { event: "mousedown" }), $ = U9(g), j = Z9(g, { role: "listbox" }), B = V9(g, {
    listRef: b,
    activeIndex: l,
    selectedIndex: u,
    onNavigate: c,
    // This is a large list, allow looping.
    loop: !0
  }), O = K9(g, {
    listRef: k,
    activeIndex: l,
    selectedIndex: u,
    onMatch: o ? c : f,
    onTypingChange(x) {
      S.current = x;
    }
  }), { getReferenceProps: N, getFloatingProps: q, getItemProps: M } = W9([
    $,
    j,
    B,
    O,
    _
  ]), z = (x) => {
    f(x), h[x] !== void 0 && r(h[x], p[h[x]]), s(!1);
  };
  return u !== null && h[u], /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: y.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": u !== null && !n ? "" : void 0,
        ...(D = d.button) == null ? void 0 : D.container,
        ...N(),
        children: [
          /* @__PURE__ */ C.jsx("span", { ...(R = d.button) == null ? void 0 : R.text, children: "Select..." }),
          /* @__PURE__ */ C.jsx(o7, { ...(W = d.button) == null ? void 0 : W.icon })
        ]
      }
    ),
    o && /* @__PURE__ */ C.jsx(P9, { children: /* @__PURE__ */ C.jsx(N9, { context: g, modal: !1, children: /* @__PURE__ */ C.jsx(
      "div",
      {
        ref: y.setFloating,
        className: (A = (F = d.content) == null ? void 0 : F.container) == null ? void 0 : A.className,
        style: { ...v },
        ...q(),
        children: h.map((x, U) => {
          var Z;
          return /* @__PURE__ */ C.jsx(
            "div",
            {
              ref: (E) => {
                b.current[U] = E;
              },
              role: "option",
              tabIndex: U === l ? 0 : -1,
              "aria-selected": U === u && U === l,
              "data-active": U === l ? "" : void 0,
              ...(Z = d.content) == null ? void 0 : Z.item,
              ...M({
                onClick() {
                  a || z(U);
                },
                onKeyDown(E) {
                  a || (E.key === "Enter" && (E.preventDefault(), z(U)), E.key === " " && !S.current && (E.preventDefault(), z(U)));
                }
              }),
              children: x
            },
            x
          );
        })
      }
    ) }) })
  ] });
}, Y9 = _n(({ type: e, title: t, url: n, ...r }, i) => {
  const {
    message: {
      blocks: { file: a }
    }
  } = xt;
  return /* @__PURE__ */ C.jsxs("a", { ...r, ...a.container, href: n, download: !0, ref: i, target: "_blank", rel: "noreferrer", children: [
    /* @__PURE__ */ C.jsx("p", { ...a.title, children: t || n }),
    /* @__PURE__ */ C.jsx(l7, { ...a.icon })
  ] });
}), J9 = {
  audio: e7,
  bubble: GU,
  button: ZU,
  carousel: s9,
  column: d7,
  dropdown: G9,
  file: Y9,
  image: JU,
  location: f7,
  row: p7,
  text: FL,
  video: QU
}, hl = ({ block: e, ...t }) => {
  const r = De((a) => a.renderers)[e.type] ?? J9[e.type], i = { ...t, ...e };
  return /* @__PURE__ */ C.jsx(r, { ...i });
};
function X9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    fillRule: "evenodd",
    d: "M8 14a.75.75 0 0 1-.75-.75V4.56L4.03 7.78a.75.75 0 0 1-1.06-1.06l4.5-4.5a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1-1.06 1.06L8.75 4.56v8.69A.75.75 0 0 1 8 14Z",
    clipRule: "evenodd"
  }));
}
const Q9 = /* @__PURE__ */ w.forwardRef(X9);
function eq({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    d: "M8 1a2 2 0 0 0-2 2v4a2 2 0 1 0 4 0V3a2 2 0 0 0-2-2Z"
  }), /* @__PURE__ */ w.createElement("path", {
    d: "M4.5 7A.75.75 0 0 0 3 7a5.001 5.001 0 0 0 4.25 4.944V13.5h-1.5a.75.75 0 0 0 0 1.5h4.5a.75.75 0 0 0 0-1.5h-1.5v-1.556A5.001 5.001 0 0 0 13 7a.75.75 0 0 0-1.5 0 3.5 3.5 0 1 1-7 0Z"
  }));
}
const tq = /* @__PURE__ */ w.forwardRef(eq);
function nq({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    d: "M8.75 3.75a.75.75 0 0 0-1.5 0v3.5h-3.5a.75.75 0 0 0 0 1.5h3.5v3.5a.75.75 0 0 0 1.5 0v-3.5h3.5a.75.75 0 0 0 0-1.5h-3.5v-3.5Z"
  }));
}
const rq = /* @__PURE__ */ w.forwardRef(nq);
function em() {
  return em = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, em.apply(null, arguments);
}
function iq(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
var aq = mo, oq = function(t) {
  var n = w.useRef(t);
  return aq(function() {
    n.current = t;
  }), n;
}, Jx = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, sq = function(t, n) {
  var r = Pt();
  return Et(function(i) {
    t.current = i, r.current && Jx(r.current, null), r.current = n, n && Jx(n, i);
  }, [n]);
}, Xx = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
}, lq = function(t) {
  Object.keys(Xx).forEach(function(n) {
    t.style.setProperty(n, Xx[n], "important");
  });
}, Qx = lq, dn = null, ew = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function cq(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), dn || (dn = document.createElement("textarea"), dn.setAttribute("tabindex", "-1"), dn.setAttribute("aria-hidden", "true"), Qx(dn)), dn.parentNode === null && document.body.appendChild(dn);
  var i = e.paddingSize, a = e.borderSize, o = e.sizingStyle, s = o.boxSizing;
  Object.keys(o).forEach(function(d) {
    var p = d;
    dn.style[p] = o[p];
  }), Qx(dn), dn.value = t;
  var l = ew(dn, e);
  dn.value = t, l = ew(dn, e), dn.value = "x";
  var c = dn.scrollHeight - i, u = c * n;
  s === "border-box" && (u = u + i + a), l = Math.max(u, l);
  var f = c * r;
  return s === "border-box" && (f = f + i + a), l = Math.min(f, l), [l, c];
}
var tw = function() {
}, uq = function(t, n) {
  return t.reduce(function(r, i) {
    return r[i] = n[i], r;
  }, {});
}, fq = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], dq = !!document.documentElement.currentStyle, pq = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = uq(fq, n), i = r.boxSizing;
  if (i === "")
    return null;
  dq && i === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var a = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), o = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: a,
    borderSize: o
  };
}, hq = pq;
function D$(e, t, n) {
  var r = oq(n);
  w.useLayoutEffect(function() {
    var i = function(o) {
      return r.current(o);
    };
    if (e)
      return e.addEventListener(t, i), function() {
        return e.removeEventListener(t, i);
      };
  }, []);
}
var mq = function(t) {
  D$(window, "resize", t);
}, vq = function(t) {
  D$(document.fonts, "loadingdone", t);
}, gq = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], yq = function(t, n) {
  var r = t.cacheMeasurements, i = t.maxRows, a = t.minRows, o = t.onChange, s = o === void 0 ? tw : o, l = t.onHeightChange, c = l === void 0 ? tw : l, u = iq(t, gq), f = u.value !== void 0, d = w.useRef(null), p = sq(d, n), h = w.useRef(0), m = w.useRef(), y = function() {
    var b = d.current, k = r && m.current ? m.current : hq(b);
    if (k) {
      m.current = k;
      var S = cq(k, b.value || b.placeholder || "x", a, i), _ = S[0], $ = S[1];
      h.current !== _ && (h.current = _, b.style.setProperty("height", _ + "px", "important"), c(_, {
        rowHeight: $
      }));
    }
  }, v = function(b) {
    f || y(), s(b);
  };
  return w.useLayoutEffect(y), mq(y), vq(y), /* @__PURE__ */ w.createElement("textarea", em({}, u, {
    onChange: v,
    ref: p
  }));
}, bq = /* @__PURE__ */ w.forwardRef(yq);
const xq = Ju(
  _n(({ children: e, className: t, inputRef: n, ...r }, i) => {
    const { composer: a } = xt, o = De((R) => R.disableComposer), s = De((R) => R.setIsTyping), l = De((R) => R.isReadOnly), c = De((R) => R.sendFile), u = De((R) => R.addMessage), f = De((R) => R.sendTextMessage), d = De((R) => R.allowFileUpload), p = De((R) => R.connected), { composerPlaceholder: h, showPoweredBy: m } = v$(), [y, v] = ht(""), [g, b] = ht(-1), [k, S] = ht(!1), _ = Pt(null), $ = Pt(null), j = Rn((R) => R.user), B = Rn((R) => R.messageHistory);
    if (l)
      return null;
    const O = () => {
      var R;
      _.current && ((R = _.current) == null || R.click());
    }, N = o || l || !p, q = async (R) => {
      var F;
      const W = (F = R.target.files) == null ? void 0 : F[0];
      if (W)
        try {
          const { fileUrl: A, type: x } = await c(W) ?? "";
          u({
            direction: "outgoing",
            sender: { name: "You" },
            timestamp: /* @__PURE__ */ new Date(),
            disableInput: !1,
            block: { type: x, url: A }
          });
        } catch (A) {
          console.error("Error sending file:", A);
        }
    }, M = window.SpeechRecognition || window.webkitSpeechRecognition, z = () => {
      $.current || ($.current = new M());
      const R = $.current;
      R && (R.continuous = !0, R.onresult = (W) => {
        var A, x, U;
        const F = ((U = (x = (A = W.results) == null ? void 0 : A[0]) == null ? void 0 : x[0]) == null ? void 0 : U.transcript) ?? "";
        v(F ?? ""), R.stop(), S(!1);
      }, k ? (R.stop(), S(!1)) : (R.start(), S(!0)));
    }, D = () => {
      y && (f(y), setTimeout(() => s(!0, 9e3), 500), v(""), b(-1));
    };
    return /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsxs(
        "div",
        {
          "data-disabled": N,
          ...r,
          className: Nv(a.container.className, t),
          ref: i,
          children: [
            d && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
              /* @__PURE__ */ C.jsx(
                "button",
                {
                  type: "button",
                  disabled: N,
                  ...a.uploadButton.container,
                  onClick: O,
                  children: /* @__PURE__ */ C.jsx(rq, { ...a.uploadButton.icon })
                }
              ),
              /* @__PURE__ */ C.jsx("input", { type: "file", ref: _, style: { display: "none" }, onChange: q })
            ] }),
            /* @__PURE__ */ C.jsx(
              bq,
              {
                ...a == null ? void 0 : a.input,
                ref: n,
                placeholder: h ?? "Type your message...",
                disabled: N,
                value: y,
                "data-has-value": !!y,
                onChange: (R) => v(R.target.value),
                maxRows: 5,
                onKeyDown: (R) => {
                  if (!N) {
                    if (R.key === "Enter" && R.shiftKey ? (R.preventDefault(), v(`${y}
`)) : R.key === "Enter" && (R.preventDefault(), D()), R.key === "ArrowUp") {
                      R.preventDefault();
                      const W = B[(j == null ? void 0 : j.userId) ?? ""] ?? [];
                      g < W.length - 1 && v(W[g + 1] ?? ""), b(() => Math.min(g + 1, W.length - 1));
                    }
                    if (R.key === "ArrowDown") {
                      R.preventDefault();
                      const W = B[(j == null ? void 0 : j.userId) ?? ""] ?? [];
                      v(g === 0 ? "" : W[g - 1] ?? ""), b(() => Math.max(g - 1, -1));
                    }
                  }
                }
              }
            ),
            y && /* @__PURE__ */ C.jsx(
              "button",
              {
                type: "button",
                "aria-label": "Send message",
                ...a.button.container,
                disabled: !y || N,
                onClick: D,
                children: /* @__PURE__ */ C.jsx(Q9, { ...a.button.icon })
              }
            ),
            !y && M && /* @__PURE__ */ C.jsx(
              "button",
              {
                type: "button",
                "aria-label": "Activate voice input",
                ...a.voiceButton.container,
                disabled: !!y,
                onClick: z,
                "data-listens": !!k,
                children: /* @__PURE__ */ C.jsx(tq, { ...a.voiceButton.icon })
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ C.jsx(
        "a",
        {
          ...a.poweredBy,
          "data-hidden": m === !1,
          hidden: m === !1,
          href: "https://botpress.com/?from=webchat",
          target: "_blank",
          rel: "noopener noreferrer",
          children: " by Botpress"
        }
      )
    ] });
  })
), wq = ({ children: e }) => {
  const [t, n] = ht(!1), [r, i] = ht(""), [a, o] = ht(null), s = ({ title: c, content: u }) => {
    i(c), o(u), n(!0);
  }, l = () => {
    n(!1);
  };
  return /* @__PURE__ */ C.jsxs(p$.Provider, { value: { hideModal: l, showModal: s, title: r, content: a, open: t }, children: [
    /* @__PURE__ */ C.jsx(la, { open: t, onOpenChange: n, children: /* @__PURE__ */ C.jsx(la.Content, { title: r, children: a }) }),
    e
  ] });
};
var M$ = {}, Yv = {}, Ou = ft && ft.__assign || function() {
  return Ou = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, Ou.apply(this, arguments);
};
Object.defineProperty(Yv, "__esModule", { value: !0 });
var Sq = {
  delayFirstAttempt: !1,
  jitter: "none",
  maxDelay: 1 / 0,
  numOfAttempts: 10,
  retry: function() {
    return !0;
  },
  startingDelay: 100,
  timeMultiple: 2
};
function Eq(e) {
  var t = Ou(Ou({}, Sq), e);
  return t.numOfAttempts < 1 && (t.numOfAttempts = 1), t;
}
Yv.getSanitizedOptions = Eq;
var Jv = {}, Xv = {}, yf = {}, Qv = {}, eg = {};
Object.defineProperty(eg, "__esModule", { value: !0 });
function _q(e) {
  var t = Math.random() * e;
  return Math.round(t);
}
eg.fullJitter = _q;
var tg = {};
Object.defineProperty(tg, "__esModule", { value: !0 });
function kq(e) {
  return e;
}
tg.noJitter = kq;
Object.defineProperty(Qv, "__esModule", { value: !0 });
var $q = eg, Oq = tg;
function Tq(e) {
  switch (e.jitter) {
    case "full":
      return $q.fullJitter;
    case "none":
    default:
      return Oq.noJitter;
  }
}
Qv.JitterFactory = Tq;
Object.defineProperty(yf, "__esModule", { value: !0 });
var Cq = Qv, Rq = (
  /** @class */
  function() {
    function e(t) {
      this.options = t, this.attempt = 0;
    }
    return e.prototype.apply = function() {
      var t = this;
      return new Promise(function(n) {
        return setTimeout(n, t.jitteredDelay);
      });
    }, e.prototype.setAttemptNumber = function(t) {
      this.attempt = t;
    }, Object.defineProperty(e.prototype, "jitteredDelay", {
      get: function() {
        var t = Cq.JitterFactory(this.options);
        return t(this.delay);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "delay", {
      get: function() {
        var t = this.options.startingDelay, n = this.options.timeMultiple, r = this.numOfDelayedAttempts, i = t * Math.pow(n, r);
        return Math.min(i, this.options.maxDelay);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "numOfDelayedAttempts", {
      get: function() {
        return this.attempt;
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }()
);
yf.Delay = Rq;
var Iq = ft && ft.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var a in i) i.hasOwnProperty(a) && (r[a] = i[a]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Aq = ft && ft.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      u.done ? a(u.value) : i(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}, Pq = ft && ft.__generator || function(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a;
      switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) {
        case 0:
        case 1:
          a = c;
          break;
        case 4:
          return n.label++, { value: c[1], done: !1 };
        case 5:
          n.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            n = 0;
            continue;
          }
          if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
            n.label = c[1];
            break;
          }
          if (c[0] === 6 && n.label < a[1]) {
            n.label = a[1], a = c;
            break;
          }
          if (a && n.label < a[2]) {
            n.label = a[2], n.ops.push(c);
            break;
          }
          a[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      c = t.call(e, n);
    } catch (u) {
      c = [6, u], i = 0;
    } finally {
      r = a = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
};
Object.defineProperty(Xv, "__esModule", { value: !0 });
var jq = yf, Nq = (
  /** @class */
  function(e) {
    Iq(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.apply = function() {
      return Aq(this, void 0, void 0, function() {
        return Pq(this, function(n) {
          return [2, this.isFirstAttempt ? !0 : e.prototype.apply.call(this)];
        });
      });
    }, Object.defineProperty(t.prototype, "isFirstAttempt", {
      get: function() {
        return this.attempt === 0;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "numOfDelayedAttempts", {
      get: function() {
        return this.attempt - 1;
      },
      enumerable: !0,
      configurable: !0
    }), t;
  }(jq.Delay)
);
Xv.SkipFirstDelay = Nq;
var ng = {}, Dq = ft && ft.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var a in i) i.hasOwnProperty(a) && (r[a] = i[a]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
Object.defineProperty(ng, "__esModule", { value: !0 });
var Mq = yf, Lq = (
  /** @class */
  function(e) {
    Dq(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(Mq.Delay)
);
ng.AlwaysDelay = Lq;
Object.defineProperty(Jv, "__esModule", { value: !0 });
var Fq = Xv, Bq = ng;
function zq(e, t) {
  var n = Uq(e);
  return n.setAttemptNumber(t), n;
}
Jv.DelayFactory = zq;
function Uq(e) {
  return e.delayFirstAttempt ? new Bq.AlwaysDelay(e) : new Fq.SkipFirstDelay(e);
}
var tm = ft && ft.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      u.done ? a(u.value) : i(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}, nm = ft && ft.__generator || function(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a;
      switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) {
        case 0:
        case 1:
          a = c;
          break;
        case 4:
          return n.label++, { value: c[1], done: !1 };
        case 5:
          n.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            n = 0;
            continue;
          }
          if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
            n.label = c[1];
            break;
          }
          if (c[0] === 6 && n.label < a[1]) {
            n.label = a[1], a = c;
            break;
          }
          if (a && n.label < a[2]) {
            n.label = a[2], n.ops.push(c);
            break;
          }
          a[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      c = t.call(e, n);
    } catch (u) {
      c = [6, u], i = 0;
    } finally {
      r = a = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
};
Object.defineProperty(M$, "__esModule", { value: !0 });
var qq = Yv, Wq = Jv;
function Hq(e, t) {
  return t === void 0 && (t = {}), tm(this, void 0, void 0, function() {
    var n, r;
    return nm(this, function(i) {
      switch (i.label) {
        case 0:
          return n = qq.getSanitizedOptions(t), r = new Zq(e, n), [4, r.execute()];
        case 1:
          return [2, i.sent()];
      }
    });
  });
}
var Vq = M$.backOff = Hq, Zq = (
  /** @class */
  function() {
    function e(t, n) {
      this.request = t, this.options = n, this.attemptNumber = 0;
    }
    return e.prototype.execute = function() {
      return tm(this, void 0, void 0, function() {
        var t, n;
        return nm(this, function(r) {
          switch (r.label) {
            case 0:
              if (this.attemptLimitReached) return [3, 7];
              r.label = 1;
            case 1:
              return r.trys.push([1, 4, , 6]), [4, this.applyDelay()];
            case 2:
              return r.sent(), [4, this.request()];
            case 3:
              return [2, r.sent()];
            case 4:
              return t = r.sent(), this.attemptNumber++, [4, this.options.retry(t, this.attemptNumber)];
            case 5:
              if (n = r.sent(), !n || this.attemptLimitReached)
                throw t;
              return [3, 6];
            case 6:
              return [3, 0];
            case 7:
              throw new Error("Something went wrong.");
          }
        });
      });
    }, Object.defineProperty(e.prototype, "attemptLimitReached", {
      get: function() {
        return this.attemptNumber >= this.options.numOfAttempts;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.applyDelay = function() {
      return tm(this, void 0, void 0, function() {
        var t;
        return nm(this, function(n) {
          switch (n.label) {
            case 0:
              return t = Wq.DelayFactory(this.options, this.attemptNumber), [4, t.apply()];
            case 1:
              return n.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e;
  }()
), nw = Object.prototype.toString, L$ = function(t) {
  var n = nw.call(t), r = n === "[object Arguments]";
  return r || (r = n !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && nw.call(t.callee) === "[object Function]"), r;
}, Bd, rw;
function Kq() {
  if (rw) return Bd;
  rw = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = L$, i = Object.prototype.propertyIsEnumerable, a = !i.call({ toString: null }, "toString"), o = i.call(function() {
    }, "prototype"), s = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], l = function(d) {
      var p = d.constructor;
      return p && p.prototype === d;
    }, c = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, u = function() {
      if (typeof window > "u")
        return !1;
      for (var d in window)
        try {
          if (!c["$" + d] && t.call(window, d) && window[d] !== null && typeof window[d] == "object")
            try {
              l(window[d]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), f = function(d) {
      if (typeof window > "u" || !u)
        return l(d);
      try {
        return l(d);
      } catch {
        return !1;
      }
    };
    e = function(p) {
      var h = p !== null && typeof p == "object", m = n.call(p) === "[object Function]", y = r(p), v = h && n.call(p) === "[object String]", g = [];
      if (!h && !m && !y)
        throw new TypeError("Object.keys called on a non-object");
      var b = o && m;
      if (v && p.length > 0 && !t.call(p, 0))
        for (var k = 0; k < p.length; ++k)
          g.push(String(k));
      if (y && p.length > 0)
        for (var S = 0; S < p.length; ++S)
          g.push(String(S));
      else
        for (var _ in p)
          !(b && _ === "prototype") && t.call(p, _) && g.push(String(_));
      if (a)
        for (var $ = f(p), j = 0; j < s.length; ++j)
          !($ && s[j] === "constructor") && t.call(p, s[j]) && g.push(s[j]);
      return g;
    };
  }
  return Bd = e, Bd;
}
var Gq = Array.prototype.slice, Yq = L$, iw = Object.keys, Tc = iw ? function(t) {
  return iw(t);
} : Kq(), aw = Object.keys;
Tc.shim = function() {
  if (Object.keys) {
    var t = function() {
      var n = Object.keys(arguments);
      return n && n.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(r) {
      return Yq(r) ? aw(Gq.call(r)) : aw(r);
    });
  } else
    Object.keys = Tc;
  return Object.keys || Tc;
};
var rg = Tc, Jq = rg, Xq = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Qq = Object.prototype.toString, eW = Array.prototype.concat, ow = $v, tW = function(e) {
  return typeof e == "function" && Qq.call(e) === "[object Function]";
}, F$ = Ov(), nW = function(e, t, n, r) {
  if (t in e) {
    if (r === !0) {
      if (e[t] === n)
        return;
    } else if (!tW(r) || !r())
      return;
  }
  F$ ? ow(e, t, n, !0) : ow(e, t, n);
}, B$ = function(e, t) {
  var n = arguments.length > 2 ? arguments[2] : {}, r = Jq(t);
  Xq && (r = eW.call(r, Object.getOwnPropertySymbols(t)));
  for (var i = 0; i < r.length; i += 1)
    nW(e, r[i], t[r[i]], n[r[i]]);
};
B$.supportsDescriptors = !!F$;
var fa = B$, rW = rg, z$ = sf(), U$ = Kn, sw = Object, iW = U$("Array.prototype.push"), lw = U$("Object.prototype.propertyIsEnumerable"), aW = z$ ? Object.getOwnPropertySymbols : null, q$ = function(t, n) {
  if (t == null)
    throw new TypeError("target must be an object");
  var r = sw(t);
  if (arguments.length === 1)
    return r;
  for (var i = 1; i < arguments.length; ++i) {
    var a = sw(arguments[i]), o = rW(a), s = z$ && (Object.getOwnPropertySymbols || aW);
    if (s)
      for (var l = s(a), c = 0; c < l.length; ++c) {
        var u = l[c];
        lw(a, u) && iW(o, u);
      }
    for (var f = 0; f < o.length; ++f) {
      var d = o[f];
      if (lw(a, d)) {
        var p = a[d];
        r[d] = p;
      }
    }
  }
  return r;
}, zd = q$, oW = function() {
  if (!Object.assign)
    return !1;
  for (var e = "abcdefghijklmnopqrst", t = e.split(""), n = {}, r = 0; r < t.length; ++r)
    n[t[r]] = t[r];
  var i = Object.assign({}, n), a = "";
  for (var o in i)
    a += o;
  return e !== a;
}, sW = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var e = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(e, "xy");
  } catch {
    return e[1] === "y";
  }
  return !1;
}, W$ = function() {
  return !Object.assign || oW() || sW() ? zd : Object.assign;
}, lW = fa, cW = W$, uW = function() {
  var t = cW();
  return lW(
    Object,
    { assign: t },
    { assign: function() {
      return Object.assign !== t;
    } }
  ), t;
}, fW = fa, dW = xo, pW = q$, H$ = W$, hW = uW, mW = dW.apply(H$()), V$ = function(t, n) {
  return mW(Object, arguments);
};
fW(V$, {
  getPolyfill: H$,
  implementation: pW,
  shim: hW
});
var vW = V$, Vs = function() {
  return typeof (function() {
  }).name == "string";
}, ss = Object.getOwnPropertyDescriptor;
if (ss)
  try {
    ss([], "length");
  } catch {
    ss = null;
  }
Vs.functionsHaveConfigurableNames = function() {
  if (!Vs() || !ss)
    return !1;
  var t = ss(function() {
  }, "name");
  return !!t && !!t.configurable;
};
var gW = Function.prototype.bind;
Vs.boundFunctionsHaveNames = function() {
  return Vs() && typeof gW == "function" && (function() {
  }).bind().name !== "";
};
var yW = Vs, cw = $v, bW = Ov(), xW = yW.functionsHaveConfigurableNames(), wW = Di, SW = function(t, n) {
  if (typeof t != "function")
    throw new wW("`fn` is not a function");
  var r = arguments.length > 2 && !!arguments[2];
  return (!r || xW) && (bW ? cw(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    n,
    !0,
    !0
  ) : cw(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    n
  )), t;
}, EW = SW, _W = Di, kW = Object, Z$ = EW(function() {
  if (this == null || this !== kW(this))
    throw new _W("RegExp.prototype.flags getter called on non-object");
  var t = "";
  return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t;
}, "get flags", !0), $W = Z$, OW = fa.supportsDescriptors, TW = Object.getOwnPropertyDescriptor, K$ = function() {
  if (OW && /a/mig.flags === "gim") {
    var t = TW(RegExp.prototype, "flags");
    if (t && typeof t.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
      var n = "", r = {};
      if (Object.defineProperty(r, "hasIndices", {
        get: function() {
          n += "d";
        }
      }), Object.defineProperty(r, "sticky", {
        get: function() {
          n += "y";
        }
      }), n === "dy")
        return t.get;
    }
  }
  return $W;
}, CW = fa.supportsDescriptors, RW = K$, IW = Object.getOwnPropertyDescriptor, AW = Object.defineProperty, PW = TypeError, uw = Object.getPrototypeOf, jW = /a/, NW = function() {
  if (!CW || !uw)
    throw new PW("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var t = RW(), n = uw(jW), r = IW(n, "flags");
  return (!r || r.get !== t) && AW(n, "flags", {
    configurable: !0,
    enumerable: !1,
    get: t
  }), t;
}, DW = fa, MW = xo, LW = Z$, G$ = K$, FW = NW, Y$ = MW(G$());
DW(Y$, {
  getPolyfill: G$,
  implementation: LW,
  shim: FW
});
var BW = Y$, Cc = { exports: {} }, zW = sf, da = function() {
  return zW() && !!Symbol.toStringTag;
}, UW = da(), qW = Kn, rm = qW("Object.prototype.toString"), bf = function(t) {
  return UW && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : rm(t) === "[object Arguments]";
}, J$ = function(t) {
  return bf(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && rm(t) !== "[object Array]" && rm(t.callee) === "[object Function]";
}, WW = function() {
  return bf(arguments);
}();
bf.isLegacyArguments = J$;
var X$ = WW ? bf : J$, HW = sk, Lo = Av(), Hr = Di, ig = {
  assert: function(e, t) {
    if (!e || typeof e != "object" && typeof e != "function")
      throw new Hr("`O` is not an object");
    if (typeof t != "string")
      throw new Hr("`slot` must be a string");
    if (Lo.assert(e), !ig.has(e, t))
      throw new Hr("`" + t + "` is not present on `O`");
  },
  get: function(e, t) {
    if (!e || typeof e != "object" && typeof e != "function")
      throw new Hr("`O` is not an object");
    if (typeof t != "string")
      throw new Hr("`slot` must be a string");
    var n = Lo.get(e);
    return n && n["$" + t];
  },
  has: function(e, t) {
    if (!e || typeof e != "object" && typeof e != "function")
      throw new Hr("`O` is not an object");
    if (typeof t != "string")
      throw new Hr("`slot` must be a string");
    var n = Lo.get(e);
    return !!n && HW(n, "$" + t);
  },
  set: function(e, t, n) {
    if (!e || typeof e != "object" && typeof e != "function")
      throw new Hr("`O` is not an object");
    if (typeof t != "string")
      throw new Hr("`slot` must be a string");
    var r = Lo.get(e);
    r || (r = {}, Lo.set(e, r)), r["$" + t] = n;
  }
};
Object.freeze && Object.freeze(ig);
var VW = ig, Fo = VW, ZW = SyntaxError, fw = typeof StopIteration == "object" ? StopIteration : null, KW = function(t) {
  if (!fw)
    throw new ZW("this environment lacks StopIteration");
  Fo.set(t, "[[Done]]", !1);
  var n = {
    next: function() {
      var i = Fo.get(this, "[[Iterator]]"), a = Fo.get(i, "[[Done]]");
      try {
        return {
          done: a,
          value: a ? void 0 : i.next()
        };
      } catch (o) {
        if (Fo.set(i, "[[Done]]", !0), o !== fw)
          throw o;
        return {
          done: !0,
          value: void 0
        };
      }
    }
  };
  return Fo.set(n, "[[Iterator]]", t), n;
}, GW = {}.toString, Q$ = Array.isArray || function(e) {
  return GW.call(e) == "[object Array]";
}, YW = String.prototype.valueOf, JW = function(t) {
  try {
    return YW.call(t), !0;
  } catch {
    return !1;
  }
}, XW = Object.prototype.toString, QW = "[object String]", eH = da(), eO = function(t) {
  return typeof t == "string" ? !0 : typeof t != "object" ? !1 : eH ? JW(t) : XW.call(t) === QW;
}, ag = typeof Map == "function" && Map.prototype ? Map : null, tH = typeof Set == "function" && Set.prototype ? Set : null, Tu;
ag || (Tu = function(t) {
  return !1;
});
var tO = ag ? Map.prototype.has : null, dw = tH ? Set.prototype.has : null;
!Tu && !tO && (Tu = function(t) {
  return !1;
});
var nO = Tu || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (tO.call(t), dw)
      try {
        dw.call(t);
      } catch {
        return !0;
      }
    return t instanceof ag;
  } catch {
  }
  return !1;
}, nH = typeof Map == "function" && Map.prototype ? Map : null, og = typeof Set == "function" && Set.prototype ? Set : null, Cu;
og || (Cu = function(t) {
  return !1;
});
var pw = nH ? Map.prototype.has : null, rO = og ? Set.prototype.has : null;
!Cu && !rO && (Cu = function(t) {
  return !1;
});
var iO = Cu || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (rO.call(t), pw)
      try {
        pw.call(t);
      } catch {
        return !0;
      }
    return t instanceof og;
  } catch {
  }
  return !1;
}, hw = X$, mw = KW;
if (Sv() || sf()) {
  var Ud = Symbol.iterator;
  Cc.exports = function(t) {
    if (t != null && typeof t[Ud] < "u")
      return t[Ud]();
    if (hw(t))
      return Array.prototype[Ud].call(t);
  };
} else {
  var rH = Q$, iH = eO, vw = Nr, aH = vw("%Map%", !0), oH = vw("%Set%", !0), Xn = Kn, gw = Xn("Array.prototype.push"), yw = Xn("String.prototype.charCodeAt"), sH = Xn("String.prototype.slice"), lH = function(t, n) {
    var r = t.length;
    if (n + 1 >= r)
      return n + 1;
    var i = yw(t, n);
    if (i < 55296 || i > 56319)
      return n + 1;
    var a = yw(t, n + 1);
    return a < 56320 || a > 57343 ? n + 1 : n + 2;
  }, qd = function(t) {
    var n = 0;
    return {
      next: function() {
        var i = n >= t.length, a;
        return i || (a = t[n], n += 1), {
          done: i,
          value: a
        };
      }
    };
  }, bw = function(t, n) {
    if (rH(t) || hw(t))
      return qd(t);
    if (iH(t)) {
      var r = 0;
      return {
        next: function() {
          var a = lH(t, r), o = sH(t, r, a);
          return r = a, {
            done: a > t.length,
            value: o
          };
        }
      };
    }
    if (n && typeof t["_es6-shim iterator_"] < "u")
      return t["_es6-shim iterator_"]();
  };
  if (!aH && !oH)
    Cc.exports = function(t) {
      if (t != null)
        return bw(t, !0);
    };
  else {
    var cH = nO, uH = iO, xw = Xn("Map.prototype.forEach", !0), ww = Xn("Set.prototype.forEach", !0);
    if (typeof process > "u" || !process.versions || !process.versions.node)
      var Sw = Xn("Map.prototype.iterator", !0), Ew = Xn("Set.prototype.iterator", !0);
    var _w = Xn("Map.prototype.@@iterator", !0) || Xn("Map.prototype._es6-shim iterator_", !0), kw = Xn("Set.prototype.@@iterator", !0) || Xn("Set.prototype._es6-shim iterator_", !0), fH = function(t) {
      if (cH(t)) {
        if (Sw)
          return mw(Sw(t));
        if (_w)
          return _w(t);
        if (xw) {
          var n = [];
          return xw(t, function(i, a) {
            gw(n, [a, i]);
          }), qd(n);
        }
      }
      if (uH(t)) {
        if (Ew)
          return mw(Ew(t));
        if (kw)
          return kw(t);
        if (ww) {
          var r = [];
          return ww(t, function(i) {
            gw(r, i);
          }), qd(r);
        }
      }
    };
    Cc.exports = function(t) {
      return fH(t) || bw(t);
    };
  }
}
var dH = Cc.exports, $w = function(e) {
  return e !== e;
}, aO = function(t, n) {
  return t === 0 && n === 0 ? 1 / t === 1 / n : !!(t === n || $w(t) && $w(n));
}, pH = aO, oO = function() {
  return typeof Object.is == "function" ? Object.is : pH;
}, hH = oO, mH = fa, vH = function() {
  var t = hH();
  return mH(Object, { is: t }, {
    is: function() {
      return Object.is !== t;
    }
  }), t;
}, gH = fa, yH = xo, bH = aO, sO = oO, xH = vH, lO = yH(sO(), Object);
gH(lO, {
  getPolyfill: sO,
  implementation: bH,
  shim: xH
});
var wH = lO, SH = xo, cO = Kn, EH = Nr, im = EH("%ArrayBuffer%", !0), Rc = cO("ArrayBuffer.prototype.byteLength", !0), _H = cO("Object.prototype.toString"), Ow = !!im && !Rc && new im(0).slice, Tw = !!Ow && SH(Ow), uO = Rc || Tw ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return Rc ? Rc(t) : Tw(t, 0), !0;
  } catch {
    return !1;
  }
} : im ? function(t) {
  return _H(t) === "[object ArrayBuffer]";
} : function(t) {
  return !1;
}, kH = Date.prototype.getDay, $H = function(t) {
  try {
    return kH.call(t), !0;
  } catch {
    return !1;
  }
}, OH = Object.prototype.toString, TH = "[object Date]", CH = da(), RH = function(t) {
  return typeof t != "object" || t === null ? !1 : CH ? $H(t) : OH.call(t) === TH;
}, am = Kn, fO = da(), dO, pO, om, sm;
if (fO) {
  dO = am("Object.prototype.hasOwnProperty"), pO = am("RegExp.prototype.exec"), om = {};
  var Wd = function() {
    throw om;
  };
  sm = {
    toString: Wd,
    valueOf: Wd
  }, typeof Symbol.toPrimitive == "symbol" && (sm[Symbol.toPrimitive] = Wd);
}
var IH = am("Object.prototype.toString"), AH = Object.getOwnPropertyDescriptor, PH = "[object RegExp]", jH = fO ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  var n = AH(t, "lastIndex"), r = n && dO(n, "value");
  if (!r)
    return !1;
  try {
    pO(t, sm);
  } catch (i) {
    return i === om;
  }
} : function(t) {
  return !t || typeof t != "object" && typeof t != "function" ? !1 : IH(t) === PH;
}, NH = Kn, Cw = NH("SharedArrayBuffer.prototype.byteLength", !0), DH = Cw ? function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    return Cw(t), !0;
  } catch {
    return !1;
  }
} : function(t) {
  return !1;
}, MH = Number.prototype.toString, LH = function(t) {
  try {
    return MH.call(t), !0;
  } catch {
    return !1;
  }
}, FH = Object.prototype.toString, BH = "[object Number]", zH = da(), UH = function(t) {
  return typeof t == "number" ? !0 : typeof t != "object" ? !1 : zH ? LH(t) : FH.call(t) === BH;
}, hO = Kn, qH = hO("Boolean.prototype.toString"), WH = hO("Object.prototype.toString"), HH = function(t) {
  try {
    return qH(t), !0;
  } catch {
    return !1;
  }
}, VH = "[object Boolean]", ZH = da(), KH = function(t) {
  return typeof t == "boolean" ? !0 : t === null || typeof t != "object" ? !1 : ZH && Symbol.toStringTag in t ? HH(t) : WH(t) === VH;
}, lm = { exports: {} }, GH = Object.prototype.toString, YH = Sv();
if (YH) {
  var JH = Symbol.prototype.toString, XH = /^Symbol\(.*\)$/, QH = function(t) {
    return typeof t.valueOf() != "symbol" ? !1 : XH.test(JH.call(t));
  };
  lm.exports = function(t) {
    if (typeof t == "symbol")
      return !0;
    if (GH.call(t) !== "[object Symbol]")
      return !1;
    try {
      return QH(t);
    } catch {
      return !1;
    }
  };
} else
  lm.exports = function(t) {
    return !1;
  };
var eV = lm.exports, cm = { exports: {} }, Rw = typeof BigInt < "u" && BigInt, tV = function() {
  return typeof Rw == "function" && typeof BigInt == "function" && typeof Rw(42) == "bigint" && typeof BigInt(42) == "bigint";
}, nV = tV();
if (nV) {
  var rV = BigInt.prototype.valueOf, iV = function(t) {
    try {
      return rV.call(t), !0;
    } catch {
    }
    return !1;
  };
  cm.exports = function(t) {
    return t === null || typeof t > "u" || typeof t == "boolean" || typeof t == "string" || typeof t == "number" || typeof t == "symbol" || typeof t == "function" ? !1 : typeof t == "bigint" ? !0 : iV(t);
  };
} else
  cm.exports = function(t) {
    return !1;
  };
var aV = cm.exports, oV = eO, sV = UH, lV = KH, cV = eV, uV = aV, fV = function(t) {
  if (t == null || typeof t != "object" && typeof t != "function")
    return null;
  if (oV(t))
    return "String";
  if (sV(t))
    return "Number";
  if (lV(t))
    return "Boolean";
  if (cV(t))
    return "Symbol";
  if (uV(t))
    return "BigInt";
}, Ru = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, Iw = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, Iu;
Ru || (Iu = function(t) {
  return !1;
});
var um = Ru ? Ru.prototype.has : null, Hd = Iw ? Iw.prototype.has : null;
!Iu && !um && (Iu = function(t) {
  return !1;
});
var dV = Iu || function(t) {
  if (!t || typeof t != "object")
    return !1;
  try {
    if (um.call(t, um), Hd)
      try {
        Hd.call(t, Hd);
      } catch {
        return !0;
      }
    return t instanceof Ru;
  } catch {
  }
  return !1;
}, fm = { exports: {} }, pV = Nr, mO = Kn, hV = pV("%WeakSet%", !0), Vd = mO("WeakSet.prototype.has", !0);
if (Vd) {
  var Zd = mO("WeakMap.prototype.has", !0);
  fm.exports = function(t) {
    if (!t || typeof t != "object")
      return !1;
    try {
      if (Vd(t, Vd), Zd)
        try {
          Zd(t, Zd);
        } catch {
          return !0;
        }
      return t instanceof hV;
    } catch {
    }
    return !1;
  };
} else
  fm.exports = function(t) {
    return !1;
  };
var mV = fm.exports, vV = nO, gV = iO, yV = dV, bV = mV, xV = function(t) {
  if (t && typeof t == "object") {
    if (vV(t))
      return "Map";
    if (gV(t))
      return "Set";
    if (yV(t))
      return "WeakMap";
    if (bV(t))
      return "WeakSet";
  }
  return !1;
}, vO = Function.prototype.toString, Ma = typeof Reflect == "object" && Reflect !== null && Reflect.apply, dm, Ic;
if (typeof Ma == "function" && typeof Object.defineProperty == "function")
  try {
    dm = Object.defineProperty({}, "length", {
      get: function() {
        throw Ic;
      }
    }), Ic = {}, Ma(function() {
      throw 42;
    }, null, dm);
  } catch (e) {
    e !== Ic && (Ma = null);
  }
else
  Ma = null;
var wV = /^\s*class\b/, pm = function(t) {
  try {
    var n = vO.call(t);
    return wV.test(n);
  } catch {
    return !1;
  }
}, Kd = function(t) {
  try {
    return pm(t) ? !1 : (vO.call(t), !0);
  } catch {
    return !1;
  }
}, Ac = Object.prototype.toString, SV = "[object Object]", EV = "[object Function]", _V = "[object GeneratorFunction]", kV = "[object HTMLAllCollection]", $V = "[object HTML document.all class]", OV = "[object HTMLCollection]", TV = typeof Symbol == "function" && !!Symbol.toStringTag, CV = !(0 in [,]), hm = function() {
  return !1;
};
if (typeof document == "object") {
  var RV = document.all;
  Ac.call(RV) === Ac.call(document.all) && (hm = function(t) {
    if ((CV || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var n = Ac.call(t);
        return (n === kV || n === $V || n === OV || n === SV) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var IV = Ma ? function(t) {
  if (hm(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    Ma(t, null, dm);
  } catch (n) {
    if (n !== Ic)
      return !1;
  }
  return !pm(t) && Kd(t);
} : function(t) {
  if (hm(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (TV)
    return Kd(t);
  if (pm(t))
    return !1;
  var n = Ac.call(t);
  return n !== EV && n !== _V && !/^\[object HTML/.test(n) ? !1 : Kd(t);
}, AV = IV, PV = Object.prototype.toString, gO = Object.prototype.hasOwnProperty, jV = function(t, n, r) {
  for (var i = 0, a = t.length; i < a; i++)
    gO.call(t, i) && (r == null ? n(t[i], i, t) : n.call(r, t[i], i, t));
}, NV = function(t, n, r) {
  for (var i = 0, a = t.length; i < a; i++)
    r == null ? n(t.charAt(i), i, t) : n.call(r, t.charAt(i), i, t);
}, DV = function(t, n, r) {
  for (var i in t)
    gO.call(t, i) && (r == null ? n(t[i], i, t) : n.call(r, t[i], i, t));
}, MV = function(t, n, r) {
  if (!AV(n))
    throw new TypeError("iterator must be a function");
  var i;
  arguments.length >= 3 && (i = r), PV.call(t) === "[object Array]" ? jV(t, n, i) : typeof t == "string" ? NV(t, n, i) : DV(t, n, i);
}, LV = MV, FV = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], Gd = FV, BV = typeof globalThis > "u" ? ft : globalThis, zV = function() {
  for (var t = [], n = 0; n < Gd.length; n++)
    typeof BV[Gd[n]] == "function" && (t[t.length] = Gd[n]);
  return t;
}, Au = LV, UV = zV, Aw = xo, sg = Kn, Pc = kv, qV = sg("Object.prototype.toString"), yO = da(), Pw = typeof globalThis > "u" ? ft : globalThis, mm = UV(), lg = sg("String.prototype.slice"), Yd = Object.getPrototypeOf, WV = sg("Array.prototype.indexOf", !0) || function(t, n) {
  for (var r = 0; r < t.length; r += 1)
    if (t[r] === n)
      return r;
  return -1;
}, Pu = { __proto__: null };
yO && Pc && Yd ? Au(mm, function(e) {
  var t = new Pw[e]();
  if (Symbol.toStringTag in t) {
    var n = Yd(t), r = Pc(n, Symbol.toStringTag);
    if (!r) {
      var i = Yd(n);
      r = Pc(i, Symbol.toStringTag);
    }
    Pu["$" + e] = Aw(r.get);
  }
}) : Au(mm, function(e) {
  var t = new Pw[e](), n = t.slice || t.set;
  n && (Pu["$" + e] = Aw(n));
});
var HV = function(t) {
  var n = !1;
  return Au(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Pu,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          "$" + r(t) === i && (n = lg(i, 1));
        } catch {
        }
    }
  ), n;
}, VV = function(t) {
  var n = !1;
  return Au(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Pu,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          r(t), n = lg(i, 1);
        } catch {
        }
    }
  ), n;
}, ZV = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!yO) {
    var n = lg(qV(t), 8, -1);
    return WV(mm, n) > -1 ? n : n !== "Object" ? !1 : VV(t);
  }
  return Pc ? HV(t) : null;
}, KV = Kn, jw = KV("ArrayBuffer.prototype.byteLength", !0), GV = uO, YV = function(t) {
  return GV(t) ? jw ? jw(t) : t.byteLength : NaN;
}, bO = vW, Mr = Kn, Nw = BW, JV = Nr, co = dH, XV = Av, Dw = wH, Mw = X$, Lw = Q$, Fw = uO, Bw = RH, zw = jH, Uw = DH, qw = rg, Ww = fV, Hw = xV, Vw = ZV, Zw = YV, Kw = Mr("SharedArrayBuffer.prototype.byteLength", !0), Gw = Mr("Date.prototype.getTime"), Jd = Object.getPrototypeOf, Yw = Mr("Object.prototype.toString"), ju = JV("%Set%", !0), vm = Mr("Map.prototype.has", !0), Nu = Mr("Map.prototype.get", !0), Jw = Mr("Map.prototype.size", !0), Du = Mr("Set.prototype.add", !0), xO = Mr("Set.prototype.delete", !0), Mu = Mr("Set.prototype.has", !0), jc = Mr("Set.prototype.size", !0);
function Xw(e, t, n, r) {
  for (var i = co(e), a; (a = i.next()) && !a.done; )
    if (lr(t, a.value, n, r))
      return xO(e, a.value), !0;
  return !1;
}
function wO(e) {
  if (typeof e > "u")
    return null;
  if (typeof e != "object")
    return typeof e == "symbol" ? !1 : typeof e == "string" || typeof e == "number" ? +e == +e : !0;
}
function QV(e, t, n, r, i, a) {
  var o = wO(n);
  if (o != null)
    return o;
  var s = Nu(t, o), l = bO({}, i, { strict: !1 });
  return typeof s > "u" && !vm(t, o) || !lr(r, s, l, a) ? !1 : !vm(e, o) && lr(r, s, l, a);
}
function e8(e, t, n) {
  var r = wO(n);
  return r ?? (Mu(t, r) && !Mu(e, r));
}
function Qw(e, t, n, r, i, a) {
  for (var o = co(e), s, l; (s = o.next()) && !s.done; )
    if (l = s.value, // eslint-disable-next-line no-use-before-define
    lr(n, l, i, a) && lr(r, Nu(t, l), i, a))
      return xO(e, l), !0;
  return !1;
}
function lr(e, t, n, r) {
  var i = n || {};
  if (i.strict ? Dw(e, t) : e === t)
    return !0;
  var a = Ww(e), o = Ww(t);
  if (a !== o)
    return !1;
  if (!e || !t || typeof e != "object" && typeof t != "object")
    return i.strict ? Dw(e, t) : e == t;
  var s = r.has(e), l = r.has(t), c;
  if (s && l) {
    if (r.get(e) === r.get(t))
      return !0;
  } else
    c = {};
  return s || r.set(e, c), l || r.set(t, c), r8(e, t, i, r);
}
function e0(e) {
  return !e || typeof e != "object" || typeof e.length != "number" || typeof e.copy != "function" || typeof e.slice != "function" || e.length > 0 && typeof e[0] != "number" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}
function t8(e, t, n, r) {
  if (jc(e) !== jc(t))
    return !1;
  for (var i = co(e), a = co(t), o, s, l; (o = i.next()) && !o.done; )
    if (o.value && typeof o.value == "object")
      l || (l = new ju()), Du(l, o.value);
    else if (!Mu(t, o.value)) {
      if (n.strict || !e8(e, t, o.value))
        return !1;
      l || (l = new ju()), Du(l, o.value);
    }
  if (l) {
    for (; (s = a.next()) && !s.done; )
      if (s.value && typeof s.value == "object") {
        if (!Xw(l, s.value, n.strict, r))
          return !1;
      } else if (!n.strict && !Mu(e, s.value) && !Xw(l, s.value, n.strict, r))
        return !1;
    return jc(l) === 0;
  }
  return !0;
}
function n8(e, t, n, r) {
  if (Jw(e) !== Jw(t))
    return !1;
  for (var i = co(e), a = co(t), o, s, l, c, u, f; (o = i.next()) && !o.done; )
    if (c = o.value[0], u = o.value[1], c && typeof c == "object")
      l || (l = new ju()), Du(l, c);
    else if (f = Nu(t, c), typeof f > "u" && !vm(t, c) || !lr(u, f, n, r)) {
      if (n.strict || !QV(e, t, c, u, n, r))
        return !1;
      l || (l = new ju()), Du(l, c);
    }
  if (l) {
    for (; (s = a.next()) && !s.done; )
      if (c = s.value[0], f = s.value[1], c && typeof c == "object") {
        if (!Qw(l, e, c, f, n, r))
          return !1;
      } else if (!n.strict && (!e.has(c) || !lr(Nu(e, c), f, n, r)) && !Qw(l, e, c, f, bO({}, n, { strict: !1 }), r))
        return !1;
    return jc(l) === 0;
  }
  return !0;
}
function r8(e, t, n, r) {
  var i, a;
  if (typeof e != typeof t || e == null || t == null || Yw(e) !== Yw(t) || Mw(e) !== Mw(t))
    return !1;
  var o = Lw(e), s = Lw(t);
  if (o !== s)
    return !1;
  var l = e instanceof Error, c = t instanceof Error;
  if (l !== c || (l || c) && (e.name !== t.name || e.message !== t.message))
    return !1;
  var u = zw(e), f = zw(t);
  if (u !== f || (u || f) && (e.source !== t.source || Nw(e) !== Nw(t)))
    return !1;
  var d = Bw(e), p = Bw(t);
  if (d !== p || (d || p) && Gw(e) !== Gw(t) || n.strict && Jd && Jd(e) !== Jd(t))
    return !1;
  var h = Vw(e), m = Vw(t);
  if (h !== m)
    return !1;
  if (h || m) {
    if (e.length !== t.length)
      return !1;
    for (i = 0; i < e.length; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  var y = e0(e), v = e0(t);
  if (y !== v)
    return !1;
  if (y || v) {
    if (e.length !== t.length)
      return !1;
    for (i = 0; i < e.length; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  var g = Fw(e), b = Fw(t);
  if (g !== b)
    return !1;
  if (g || b)
    return Zw(e) !== Zw(t) ? !1 : typeof Uint8Array == "function" && lr(new Uint8Array(e), new Uint8Array(t), n, r);
  var k = Uw(e), S = Uw(t);
  if (k !== S)
    return !1;
  if (k || S)
    return Kw(e) !== Kw(t) ? !1 : typeof Uint8Array == "function" && lr(new Uint8Array(e), new Uint8Array(t), n, r);
  if (typeof e != typeof t)
    return !1;
  var _ = qw(e), $ = qw(t);
  if (_.length !== $.length)
    return !1;
  for (_.sort(), $.sort(), i = _.length - 1; i >= 0; i--)
    if (_[i] != $[i])
      return !1;
  for (i = _.length - 1; i >= 0; i--)
    if (a = _[i], !lr(e[a], t[a], n, r))
      return !1;
  var j = Hw(e), B = Hw(t);
  return j !== B ? !1 : j === "Set" || B === "Set" ? t8(e, t, n, r) : j === "Map" ? n8(e, t, n, r) : !0;
}
var i8 = function(t, n, r) {
  return lr(t, n, r, XV());
};
const a8 = /* @__PURE__ */ Ze(i8), uhe = ({ children: e, ...t }) => {
  const n = Pt(), r = Pt(null), i = VU({ ...t, messageContainerRef: r });
  return n.current || (n.current = i), /* @__PURE__ */ C.jsx(m$.Provider, { value: { ...t.configuration }, children: /* @__PURE__ */ C.jsx(f$.Provider, { value: n.current, children: /* @__PURE__ */ C.jsx(o8, { children: e }) }) });
}, o8 = ({ children: e }) => {
  const t = De((b) => b.client), n = De((b) => b.addMessage), r = De((b) => b.setMessages), i = De((b) => b.configuration), a = De((b) => b.setConnected), o = De((b) => b.userData), s = De((b) => b.userName), l = De((b) => b.userPictureUrl), c = De((b) => b.setIsTyping), u = De((b) => b.getMessages), f = De((b) => b.setHeaderMessage), d = De((b) => b.setDisableComposer), p = Rn((b) => b.setConversationId), h = Rn((b) => b.user), m = Rn((b) => b.conversationId), y = Rn((b) => b.setUser), [v, g] = ht(0);
  return $t(() => {
    if (t)
      return t.on("messageSent", (b) => {
        const k = u(), S = k[k.length - 1];
        (k.length === 0 || !a8(S == null ? void 0 : S.block, cs(b).payload)) && n({
          direction: "outgoing",
          sender: { name: "You" },
          timestamp: /* @__PURE__ */ new Date(),
          block: cs(b).payload,
          disableInput: !1
        });
      });
  }, [m]), $t(() => {
    if (t)
      return t.on("message", (b) => {
        try {
          const { payload: k, disableInput: S, conversationId: _, sentOn: $, ...j } = b;
          if (m !== _)
            return;
          c(!1, 0), n({
            ...j,
            direction: "incoming",
            sender: { name: i.botName ?? "Bot", avatar: i.botAvatar },
            timestamp: new Date($),
            block: k,
            disableInput: S
          });
        } catch {
          console.error("Invalid message payload");
        }
      });
  }, [m]), $t(() => {
    if (t)
      return t.on("conversation", (b) => {
        p(b);
      });
  }, []), Gh(async () => {
    if (t)
      return t.on("error", (b) => {
        console.error("Connection Error", b), g((k) => k + 1);
      });
  }), Gh(async () => {
    if (!t || m && t.conversationId === m)
      return;
    let b;
    try {
      f("Connecting..."), d(!0), b = await Vq(
        () => t.connect(h, o, {
          name: s,
          pictureUrl: l
        }),
        { maxDelay: 1e4, numOfAttempts: 1 / 0 }
      ), f(void 0), d(!1), a(!0);
    } catch (S) {
      console.warn(S), f("Connection failed. Please try again later."), a(!1);
      return;
    }
    y(b), m && await t.conversationExists(m) ? await t.switchConversation(m) : await t.newConversation();
    const k = [];
    for (const S of await t.listMessages())
      try {
        const { payload: _, authorId: $, sentOn: j, disableInput: B, ...O } = S, N = $ === t.userId ? "outgoing" : "incoming";
        k.push({
          ...O,
          direction: N,
          sender: N === "outgoing" ? { name: "You" } : { name: i.botName ?? "Bot", avatar: i.botAvatar },
          timestamp: new Date(j),
          block: _,
          disableInput: B
        });
      } catch {
        console.error("Invalid message payload");
      }
    return r(k.reverse()), () => {
      t.disconnect();
    };
  }, [v, m]), /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
};
function Yr(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function s8(e, t) {
  const n = w.createContext(t), r = (a) => {
    const { children: o, ...s } = a, l = w.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ C.jsx(n.Provider, { value: l, children: o });
  };
  r.displayName = e + "Provider";
  function i(a) {
    const o = w.useContext(n);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function SO(e, t = []) {
  let n = [];
  function r(a, o) {
    const s = w.createContext(o), l = n.length;
    n = [...n, o];
    const c = (f) => {
      var v;
      const { scope: d, children: p, ...h } = f, m = ((v = d == null ? void 0 : d[e]) == null ? void 0 : v[l]) || s, y = w.useMemo(() => h, Object.values(h));
      return /* @__PURE__ */ C.jsx(m.Provider, { value: y, children: p });
    };
    c.displayName = a + "Provider";
    function u(f, d) {
      var m;
      const p = ((m = d == null ? void 0 : d[e]) == null ? void 0 : m[l]) || s, h = w.useContext(p);
      if (h) return h;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${a}\``);
    }
    return [c, u];
  }
  const i = () => {
    const a = n.map((o) => w.createContext(o));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || a;
      return w.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, l8(i, ...t)];
}
function l8(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const o = r.reduce((s, { useScope: l, scopeName: c }) => {
        const f = l(a)[`__scope${c}`];
        return { ...s, ...f };
      }, {});
      return w.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var c8 = w.useId || (() => {
}), u8 = 0;
function Nc(e) {
  const [t, n] = w.useState(c8());
  return Za(() => {
    e || n((r) => r ?? String(u8++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
function EO({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = f8({ defaultProp: t, onChange: n }), a = e !== void 0, o = a ? e : r, s = _i(n), l = w.useCallback(
    (c) => {
      if (a) {
        const f = typeof c == "function" ? c(e) : c;
        f !== e && s(f);
      } else
        i(c);
    },
    [a, e, i, s]
  );
  return [o, l];
}
function f8({
  defaultProp: e,
  onChange: t
}) {
  const n = w.useState(e), [r] = n, i = w.useRef(r), a = _i(t);
  return w.useEffect(() => {
    i.current !== r && (a(r), i.current = r);
  }, [r, i, a]), n;
}
function d8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e);
  w.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var p8 = "DismissableLayer", gm = "dismissableLayer.update", h8 = "dismissableLayer.pointerDownOutside", m8 = "dismissableLayer.focusOutside", t0, _O = w.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), kO = w.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: a,
      onInteractOutside: o,
      onDismiss: s,
      ...l
    } = e, c = w.useContext(_O), [u, f] = w.useState(null), d = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, p] = w.useState({}), h = ji(t, ($) => f($)), m = Array.from(c.layers), [y] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), v = m.indexOf(y), g = u ? m.indexOf(u) : -1, b = c.layersWithOutsidePointerEventsDisabled.size > 0, k = g >= v, S = y8(($) => {
      const j = $.target, B = [...c.branches].some((O) => O.contains(j));
      !k || B || (i == null || i($), o == null || o($), $.defaultPrevented || s == null || s());
    }, d), _ = b8(($) => {
      const j = $.target;
      [...c.branches].some((O) => O.contains(j)) || (a == null || a($), o == null || o($), $.defaultPrevented || s == null || s());
    }, d);
    return d8(($) => {
      g === c.layers.size - 1 && (r == null || r($), !$.defaultPrevented && s && ($.preventDefault(), s()));
    }, d), w.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (t0 = d.body.style.pointerEvents, d.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), n0(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = t0);
        };
    }, [u, d, n, c]), w.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), n0());
    }, [u, c]), w.useEffect(() => {
      const $ = () => p({});
      return document.addEventListener(gm, $), () => document.removeEventListener(gm, $);
    }, []), /* @__PURE__ */ C.jsx(
      kn.div,
      {
        ...l,
        ref: h,
        style: {
          pointerEvents: b ? k ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Yr(e.onFocusCapture, _.onFocusCapture),
        onBlurCapture: Yr(e.onBlurCapture, _.onBlurCapture),
        onPointerDownCapture: Yr(
          e.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
kO.displayName = p8;
var v8 = "DismissableLayerBranch", g8 = w.forwardRef((e, t) => {
  const n = w.useContext(_O), r = w.useRef(null), i = ji(t, r);
  return w.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ C.jsx(kn.div, { ...e, ref: i });
});
g8.displayName = v8;
function y8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = w.useRef(!1), i = w.useRef(() => {
  });
  return w.useEffect(() => {
    const a = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          $O(
            h8,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", a), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function b8(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = w.useRef(!1);
  return w.useEffect(() => {
    const i = (a) => {
      a.target && !r.current && $O(m8, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function n0() {
  const e = new CustomEvent(gm);
  document.dispatchEvent(e);
}
function $O(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? gI(i, a) : i.dispatchEvent(a);
}
var Xd = "focusScope.autoFocusOnMount", Qd = "focusScope.autoFocusOnUnmount", r0 = { bubbles: !1, cancelable: !0 }, x8 = "FocusScope", OO = w.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: a,
    ...o
  } = e, [s, l] = w.useState(null), c = _i(i), u = _i(a), f = w.useRef(null), d = ji(t, (m) => l(m)), p = w.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  w.useEffect(() => {
    if (r) {
      let m = function(b) {
        if (p.paused || !s) return;
        const k = b.target;
        s.contains(k) ? f.current = k : fi(f.current, { select: !0 });
      }, y = function(b) {
        if (p.paused || !s) return;
        const k = b.relatedTarget;
        k !== null && (s.contains(k) || fi(f.current, { select: !0 }));
      }, v = function(b) {
        if (document.activeElement === document.body)
          for (const S of b)
            S.removedNodes.length > 0 && fi(s);
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", y);
      const g = new MutationObserver(v);
      return s && g.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", y), g.disconnect();
      };
    }
  }, [r, s, p.paused]), w.useEffect(() => {
    if (s) {
      a0.add(p);
      const m = document.activeElement;
      if (!s.contains(m)) {
        const v = new CustomEvent(Xd, r0);
        s.addEventListener(Xd, c), s.dispatchEvent(v), v.defaultPrevented || (w8($8(TO(s)), { select: !0 }), document.activeElement === m && fi(s));
      }
      return () => {
        s.removeEventListener(Xd, c), setTimeout(() => {
          const v = new CustomEvent(Qd, r0);
          s.addEventListener(Qd, u), s.dispatchEvent(v), v.defaultPrevented || fi(m ?? document.body, { select: !0 }), s.removeEventListener(Qd, u), a0.remove(p);
        }, 0);
      };
    }
  }, [s, c, u, p]);
  const h = w.useCallback(
    (m) => {
      if (!n && !r || p.paused) return;
      const y = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, v = document.activeElement;
      if (y && v) {
        const g = m.currentTarget, [b, k] = S8(g);
        b && k ? !m.shiftKey && v === k ? (m.preventDefault(), n && fi(b, { select: !0 })) : m.shiftKey && v === b && (m.preventDefault(), n && fi(k, { select: !0 })) : v === g && m.preventDefault();
      }
    },
    [n, r, p.paused]
  );
  return /* @__PURE__ */ C.jsx(kn.div, { tabIndex: -1, ...o, ref: d, onKeyDown: h });
});
OO.displayName = x8;
function w8(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (fi(r, { select: t }), document.activeElement !== n) return;
}
function S8(e) {
  const t = TO(e), n = i0(t, e), r = i0(t.reverse(), e);
  return [n, r];
}
function TO(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function i0(e, t) {
  for (const n of e)
    if (!E8(n, { upTo: t })) return n;
}
function E8(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function _8(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function fi(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && _8(e) && t && e.select();
  }
}
var a0 = k8();
function k8() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = o0(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = o0(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function o0(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function $8(e) {
  return e.filter((t) => t.tagName !== "A");
}
function O8(e, t) {
  return w.useReducer((n, r) => t[n][r] ?? n, e);
}
var xf = (e) => {
  const { present: t, children: n } = e, r = T8(t), i = typeof n == "function" ? n({ present: r.isPresent }) : w.Children.only(n), a = ji(r.ref, C8(i));
  return typeof n == "function" || r.isPresent ? w.cloneElement(i, { ref: a }) : null;
};
xf.displayName = "Presence";
function T8(e) {
  const [t, n] = w.useState(), r = w.useRef({}), i = w.useRef(e), a = w.useRef("none"), o = e ? "mounted" : "unmounted", [s, l] = O8(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return w.useEffect(() => {
    const c = Kl(r.current);
    a.current = s === "mounted" ? c : "none";
  }, [s]), Za(() => {
    const c = r.current, u = i.current;
    if (u !== e) {
      const d = a.current, p = Kl(c);
      e ? l("MOUNT") : p === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && d !== p ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), Za(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, f = (p) => {
        const m = Kl(r.current).includes(p.animationName);
        if (p.target === t && m && (l("ANIMATION_END"), !i.current)) {
          const y = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = y);
          });
        }
      }, d = (p) => {
        p.target === t && (a.current = Kl(r.current));
      };
      return t.addEventListener("animationstart", d), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", d), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: w.useCallback((c) => {
      c && (r.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function Kl(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function C8(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var ep = 0;
function R8() {
  w.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? s0()), document.body.insertAdjacentElement("beforeend", e[1] ?? s0()), ep++, () => {
      ep === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), ep--;
    };
  }, []);
}
function s0() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Dc = "right-scroll-bar-position", Mc = "width-before-scroll-bar", I8 = "with-scroll-bars-hidden", A8 = "--removed-body-scroll-bar-size";
function tp(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function P8(e, t) {
  var n = ht(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var j8 = typeof window < "u" ? w.useLayoutEffect : w.useEffect, l0 = /* @__PURE__ */ new WeakMap();
function N8(e, t) {
  var n = P8(null, function(r) {
    return e.forEach(function(i) {
      return tp(i, r);
    });
  });
  return j8(function() {
    var r = l0.get(n);
    if (r) {
      var i = new Set(r), a = new Set(e), o = n.current;
      i.forEach(function(s) {
        a.has(s) || tp(s, null);
      }), a.forEach(function(s) {
        i.has(s) || tp(s, o);
      });
    }
    l0.set(n, e);
  }, [e]), n;
}
function D8(e) {
  return e;
}
function M8(e, t) {
  t === void 0 && (t = D8);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var o = t(a, r);
      return n.push(o), function() {
        n = n.filter(function(s) {
          return s !== o;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(a);
      }
      n = {
        push: function(s) {
          return a(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var o = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(a), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(a);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return i;
}
function L8(e) {
  e === void 0 && (e = {});
  var t = M8(null);
  return t.options = Un({ async: !0, ssr: !1 }, e), t;
}
var CO = function(e) {
  var t = e.sideCar, n = a$(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return w.createElement(r, Un({}, n));
};
CO.isSideCarExport = !0;
function F8(e, t) {
  return e.useMedium(t), CO;
}
var RO = L8(), np = function() {
}, wf = w.forwardRef(function(e, t) {
  var n = w.useRef(null), r = w.useState({
    onScrollCapture: np,
    onWheelCapture: np,
    onTouchMoveCapture: np
  }), i = r[0], a = r[1], o = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, f = e.shards, d = e.sideCar, p = e.noIsolation, h = e.inert, m = e.allowPinchZoom, y = e.as, v = y === void 0 ? "div" : y, g = e.gapMode, b = a$(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), k = d, S = N8([n, t]), _ = Un(Un({}, b), i);
  return w.createElement(
    w.Fragment,
    null,
    u && w.createElement(k, { sideCar: RO, removeScrollBar: c, shards: f, noIsolation: p, inert: h, setCallbacks: a, allowPinchZoom: !!m, lockRef: n, gapMode: g }),
    o ? w.cloneElement(w.Children.only(s), Un(Un({}, _), { ref: S })) : w.createElement(v, Un({}, _, { className: l, ref: S }), s)
  );
});
wf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
wf.classNames = {
  fullWidth: Mc,
  zeroRight: Dc
};
var B8 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function z8() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = B8();
  return t && e.setAttribute("nonce", t), e;
}
function U8(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function q8(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var W8 = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = z8()) && (U8(t, n), q8(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, H8 = function() {
  var e = W8();
  return function(t, n) {
    w.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, IO = function() {
  var e = H8(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, V8 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, rp = function(e) {
  return parseInt(e || "", 10) || 0;
}, Z8 = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [rp(n), rp(r), rp(i)];
}, K8 = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return V8;
  var t = Z8(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, G8 = IO(), Ha = "data-scroll-locked", Y8 = function(e, t, n, r) {
  var i = e.left, a = e.top, o = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(I8, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(Ha, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Dc, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Mc, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Dc, " .").concat(Dc, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Mc, " .").concat(Mc, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Ha, `] {
    `).concat(A8, ": ").concat(s, `px;
  }
`);
}, c0 = function() {
  var e = parseInt(document.body.getAttribute(Ha) || "0", 10);
  return isFinite(e) ? e : 0;
}, J8 = function() {
  w.useEffect(function() {
    return document.body.setAttribute(Ha, (c0() + 1).toString()), function() {
      var e = c0() - 1;
      e <= 0 ? document.body.removeAttribute(Ha) : document.body.setAttribute(Ha, e.toString());
    };
  }, []);
}, X8 = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  J8();
  var a = w.useMemo(function() {
    return K8(i);
  }, [i]);
  return w.createElement(G8, { styles: Y8(a, !t, i, n ? "" : "!important") });
}, ym = !1;
if (typeof window < "u")
  try {
    var Gl = Object.defineProperty({}, "passive", {
      get: function() {
        return ym = !0, !0;
      }
    });
    window.addEventListener("test", Gl, Gl), window.removeEventListener("test", Gl, Gl);
  } catch {
    ym = !1;
  }
var Ea = ym ? { passive: !1 } : !1, Q8 = function(e) {
  return e.tagName === "TEXTAREA";
}, AO = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Q8(e) && n[t] === "visible")
  );
}, eZ = function(e) {
  return AO(e, "overflowY");
}, tZ = function(e) {
  return AO(e, "overflowX");
}, u0 = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = PO(e, r);
    if (i) {
      var a = jO(e, r), o = a[1], s = a[2];
      if (o > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, nZ = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, rZ = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, PO = function(e, t) {
  return e === "v" ? eZ(t) : tZ(t);
}, jO = function(e, t) {
  return e === "v" ? nZ(t) : rZ(t);
}, iZ = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, aZ = function(e, t, n, r, i) {
  var a = iZ(e, window.getComputedStyle(t).direction), o = a * r, s = n.target, l = t.contains(s), c = !1, u = o > 0, f = 0, d = 0;
  do {
    var p = jO(e, s), h = p[0], m = p[1], y = p[2], v = m - y - a * h;
    (h || v) && PO(e, s) && (f += v, d += h), s instanceof ShadowRoot ? s = s.host : s = s.parentNode;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (u && (Math.abs(f) < 1 || !i) || !u && (Math.abs(d) < 1 || !i)) && (c = !0), c;
}, Yl = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, f0 = function(e) {
  return [e.deltaX, e.deltaY];
}, d0 = function(e) {
  return e && "current" in e ? e.current : e;
}, oZ = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, sZ = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, lZ = 0, _a = [];
function cZ(e) {
  var t = w.useRef([]), n = w.useRef([0, 0]), r = w.useRef(), i = w.useState(lZ++)[0], a = w.useState(IO)[0], o = w.useRef(e);
  w.useEffect(function() {
    o.current = e;
  }, [e]), w.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var m = yU([e.lockRef.current], (e.shards || []).map(d0), !0).filter(Boolean);
      return m.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), m.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = w.useCallback(function(m, y) {
    if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
      return !o.current.allowPinchZoom;
    var v = Yl(m), g = n.current, b = "deltaX" in m ? m.deltaX : g[0] - v[0], k = "deltaY" in m ? m.deltaY : g[1] - v[1], S, _ = m.target, $ = Math.abs(b) > Math.abs(k) ? "h" : "v";
    if ("touches" in m && $ === "h" && _.type === "range")
      return !1;
    var j = u0($, _);
    if (!j)
      return !0;
    if (j ? S = $ : (S = $ === "v" ? "h" : "v", j = u0($, _)), !j)
      return !1;
    if (!r.current && "changedTouches" in m && (b || k) && (r.current = S), !S)
      return !0;
    var B = r.current || S;
    return aZ(B, y, m, B === "h" ? b : k, !0);
  }, []), l = w.useCallback(function(m) {
    var y = m;
    if (!(!_a.length || _a[_a.length - 1] !== a)) {
      var v = "deltaY" in y ? f0(y) : Yl(y), g = t.current.filter(function(S) {
        return S.name === y.type && (S.target === y.target || y.target === S.shadowParent) && oZ(S.delta, v);
      })[0];
      if (g && g.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!g) {
        var b = (o.current.shards || []).map(d0).filter(Boolean).filter(function(S) {
          return S.contains(y.target);
        }), k = b.length > 0 ? s(y, b[0]) : !o.current.noIsolation;
        k && y.cancelable && y.preventDefault();
      }
    }
  }, []), c = w.useCallback(function(m, y, v, g) {
    var b = { name: m, delta: y, target: v, should: g, shadowParent: uZ(v) };
    t.current.push(b), setTimeout(function() {
      t.current = t.current.filter(function(k) {
        return k !== b;
      });
    }, 1);
  }, []), u = w.useCallback(function(m) {
    n.current = Yl(m), r.current = void 0;
  }, []), f = w.useCallback(function(m) {
    c(m.type, f0(m), m.target, s(m, e.lockRef.current));
  }, []), d = w.useCallback(function(m) {
    c(m.type, Yl(m), m.target, s(m, e.lockRef.current));
  }, []);
  w.useEffect(function() {
    return _a.push(a), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: d
    }), document.addEventListener("wheel", l, Ea), document.addEventListener("touchmove", l, Ea), document.addEventListener("touchstart", u, Ea), function() {
      _a = _a.filter(function(m) {
        return m !== a;
      }), document.removeEventListener("wheel", l, Ea), document.removeEventListener("touchmove", l, Ea), document.removeEventListener("touchstart", u, Ea);
    };
  }, []);
  var p = e.removeScrollBar, h = e.inert;
  return w.createElement(
    w.Fragment,
    null,
    h ? w.createElement(a, { styles: sZ(i) }) : null,
    p ? w.createElement(X8, { gapMode: e.gapMode }) : null
  );
}
function uZ(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const fZ = F8(RO, cZ);
var NO = w.forwardRef(function(e, t) {
  return w.createElement(wf, Un({}, e, { ref: t, sideCar: fZ }));
});
NO.classNames = wf.classNames;
var dZ = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, ka = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), Xl = {}, ip = 0, DO = function(e) {
  return e && (e.host || DO(e.parentNode));
}, pZ = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = DO(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, hZ = function(e, t, n, r) {
  var i = pZ(t, Array.isArray(e) ? e : [e]);
  Xl[n] || (Xl[n] = /* @__PURE__ */ new WeakMap());
  var a = Xl[n], o = [], s = /* @__PURE__ */ new Set(), l = new Set(i), c = function(f) {
    !f || s.has(f) || (s.add(f), c(f.parentNode));
  };
  i.forEach(c);
  var u = function(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, function(d) {
      if (s.has(d))
        u(d);
      else
        try {
          var p = d.getAttribute(r), h = p !== null && p !== "false", m = (ka.get(d) || 0) + 1, y = (a.get(d) || 0) + 1;
          ka.set(d, m), a.set(d, y), o.push(d), m === 1 && h && Jl.set(d, !0), y === 1 && d.setAttribute(n, "true"), h || d.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", d, v);
        }
    });
  };
  return u(t), s.clear(), ip++, function() {
    o.forEach(function(f) {
      var d = ka.get(f) - 1, p = a.get(f) - 1;
      ka.set(f, d), a.set(f, p), d || (Jl.has(f) || f.removeAttribute(r), Jl.delete(f)), p || f.removeAttribute(n);
    }), ip--, ip || (ka = /* @__PURE__ */ new WeakMap(), ka = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), Xl = {});
  };
}, mZ = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = dZ(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), hZ(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, cg = "Dialog", [MO, fhe] = SO(cg), [vZ, Lr] = MO(cg), LO = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: a,
    modal: o = !0
  } = e, s = w.useRef(null), l = w.useRef(null), [c = !1, u] = EO({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ C.jsx(
    vZ,
    {
      scope: t,
      triggerRef: s,
      contentRef: l,
      contentId: Nc(),
      titleId: Nc(),
      descriptionId: Nc(),
      open: c,
      onOpenChange: u,
      onOpenToggle: w.useCallback(() => u((f) => !f), [u]),
      modal: o,
      children: n
    }
  );
};
LO.displayName = cg;
var FO = "DialogTrigger", BO = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Lr(FO, n), a = ji(t, i.triggerRef);
    return /* @__PURE__ */ C.jsx(
      kn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": fg(i.open),
        ...r,
        ref: a,
        onClick: Yr(e.onClick, i.onOpenToggle)
      }
    );
  }
);
BO.displayName = FO;
var gZ = "DialogPortal", [dhe, zO] = MO(gZ, {
  forceMount: void 0
}), Lu = "DialogOverlay", UO = w.forwardRef(
  (e, t) => {
    const n = zO(Lu, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Lr(Lu, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ C.jsx(xf, { present: r || a.open, children: /* @__PURE__ */ C.jsx(yZ, { ...i, ref: t }) }) : null;
  }
);
UO.displayName = Lu;
var yZ = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Lr(Lu, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ C.jsx(NO, { as: Vm, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ C.jsx(
        kn.div,
        {
          "data-state": fg(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), sa = "DialogContent", qO = w.forwardRef(
  (e, t) => {
    const n = zO(sa, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Lr(sa, e.__scopeDialog);
    return /* @__PURE__ */ C.jsx(xf, { present: r || a.open, children: a.modal ? /* @__PURE__ */ C.jsx(bZ, { ...i, ref: t }) : /* @__PURE__ */ C.jsx(xZ, { ...i, ref: t }) });
  }
);
qO.displayName = sa;
var bZ = w.forwardRef(
  (e, t) => {
    const n = Lr(sa, e.__scopeDialog), r = w.useRef(null), i = ji(t, n.contentRef, r);
    return w.useEffect(() => {
      const a = r.current;
      if (a) return mZ(a);
    }, []), /* @__PURE__ */ C.jsx(
      WO,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Yr(e.onCloseAutoFocus, (a) => {
          var o;
          a.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Yr(e.onPointerDownOutside, (a) => {
          const o = a.detail.originalEvent, s = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || s) && a.preventDefault();
        }),
        onFocusOutside: Yr(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), xZ = w.forwardRef(
  (e, t) => {
    const n = Lr(sa, e.__scopeDialog), r = w.useRef(!1), i = w.useRef(!1);
    return /* @__PURE__ */ C.jsx(
      WO,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var o, s;
          (o = e.onCloseAutoFocus) == null || o.call(e, a), a.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), a.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (a) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = a.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
        }
      }
    );
  }
), WO = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: a, ...o } = e, s = Lr(sa, n), l = w.useRef(null), c = ji(t, l);
    return R8(), /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsx(
        OO,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ C.jsx(
            kO,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": fg(s.open),
              ...o,
              ref: c,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
        /* @__PURE__ */ C.jsx(SZ, { titleId: s.titleId }),
        /* @__PURE__ */ C.jsx(_Z, { contentRef: l, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), ug = "DialogTitle", HO = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Lr(ug, n);
    return /* @__PURE__ */ C.jsx(kn.h2, { id: i.titleId, ...r, ref: t });
  }
);
HO.displayName = ug;
var VO = "DialogDescription", wZ = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Lr(VO, n);
    return /* @__PURE__ */ C.jsx(kn.p, { id: i.descriptionId, ...r, ref: t });
  }
);
wZ.displayName = VO;
var ZO = "DialogClose", KO = w.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Lr(ZO, n);
    return /* @__PURE__ */ C.jsx(
      kn.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Yr(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
KO.displayName = ZO;
function fg(e) {
  return e ? "open" : "closed";
}
var GO = "DialogTitleWarning", [phe, YO] = s8(GO, {
  contentName: sa,
  titleName: ug,
  docsSlug: "dialog"
}), SZ = ({ titleId: e }) => {
  const t = YO(GO), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return w.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, EZ = "DialogDescriptionWarning", _Z = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${YO(EZ).contentName}}.`;
  return w.useEffect(() => {
    var a;
    const i = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, kZ = LO, $Z = BO, OZ = UO, TZ = qO, CZ = HO, JO = KO;
function RZ({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ w.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ w.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ w.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18 18 6M6 6l12 12"
  }));
}
const XO = /* @__PURE__ */ w.forwardRef(RZ);
function la({
  open: e,
  onOpenChange: t,
  children: n
}) {
  return /* @__PURE__ */ C.jsx(kZ, { open: e, onOpenChange: t, children: n });
}
function IZ({ title: e, children: t }) {
  var r, i, a, o, s, l, c, u;
  const { modal: n } = xt;
  return /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsx(OZ, { ...n == null ? void 0 : n.overlay }),
    /* @__PURE__ */ C.jsx("div", { ...n == null ? void 0 : n.container, children: /* @__PURE__ */ C.jsxs(TZ, { ...(r = n == null ? void 0 : n.dialog) == null ? void 0 : r.container, children: [
      /* @__PURE__ */ C.jsxs("div", { ...(a = (i = n == null ? void 0 : n.dialog) == null ? void 0 : i.title) == null ? void 0 : a.container, children: [
        /* @__PURE__ */ C.jsx(CZ, { ...(s = (o = n == null ? void 0 : n.dialog) == null ? void 0 : o.title) == null ? void 0 : s.text, children: e }),
        /* @__PURE__ */ C.jsx(JO, { children: /* @__PURE__ */ C.jsx(XO, { role: "button", tabIndex: 0, ...(c = (l = n == null ? void 0 : n.dialog) == null ? void 0 : l.title) == null ? void 0 : c.closeIcon }) })
      ] }),
      /* @__PURE__ */ C.jsx("div", { ...(u = n == null ? void 0 : n.dialog) == null ? void 0 : u.content, children: t })
    ] }) })
  ] });
}
la.Button = $Z;
la.Close = JO;
la.Content = IZ;
const AZ = _n(({ children: e, className: t, ...n }, r) => {
  const {
    container: { className: i }
  } = xt;
  return /* @__PURE__ */ C.jsxs("div", { ...n, className: Nv(i, t), ref: r, children: [
    /* @__PURE__ */ C.jsx(y6, {}),
    /* @__PURE__ */ C.jsxs(wq, { children: [
      /* @__PURE__ */ C.jsx(PZ, {}),
      e
    ] })
  ] });
}), PZ = () => {
  const { modal: e } = xt, t = De((r) => r.connected), { showModal: n } = h$();
  return $t(() => {
    var r, i, a, o;
    t || n({
      title: "Connection Error",
      content: /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
        /* @__PURE__ */ C.jsx("p", { ...(i = (r = e == null ? void 0 : e.dialog) == null ? void 0 : r.newConversation) == null ? void 0 : i.text, children: "There was an error connecting to the server. Please check your internet connection and try again." }),
        /* @__PURE__ */ C.jsx(la.Close, { asChild: !0, children: /* @__PURE__ */ C.jsx(
          "button",
          {
            type: "button",
            ...(o = (a = e == null ? void 0 : e.dialog) == null ? void 0 : a.newConversation) == null ? void 0 : o.button,
            onClick: () => window.location.reload(),
            children: "Restart"
          }
        ) })
      ] })
    });
  }, [t]), /* @__PURE__ */ C.jsx(C.Fragment, {});
}, hhe = _n(({ children: e, onClick: t, ...n }, r) => {
  const { fab: i } = xt, { container: a, icon: o } = i ?? {};
  return /* @__PURE__ */ C.jsx("div", { ...n, ...a, ref: r, onClick: t, children: /* @__PURE__ */ C.jsx("div", { ...o }) });
});
var dg = "Collapsible", [jZ, mhe] = SO(dg), [NZ, pg] = jZ(dg), QO = w.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: i,
      disabled: a,
      onOpenChange: o,
      ...s
    } = e, [l = !1, c] = EO({
      prop: r,
      defaultProp: i,
      onChange: o
    });
    return /* @__PURE__ */ C.jsx(
      NZ,
      {
        scope: n,
        disabled: a,
        contentId: Nc(),
        open: l,
        onOpenToggle: w.useCallback(() => c((u) => !u), [c]),
        children: /* @__PURE__ */ C.jsx(
          kn.div,
          {
            "data-state": mg(l),
            "data-disabled": a ? "" : void 0,
            ...s,
            ref: t
          }
        )
      }
    );
  }
);
QO.displayName = dg;
var eT = "CollapsibleTrigger", tT = w.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...r } = e, i = pg(eT, n);
    return /* @__PURE__ */ C.jsx(
      kn.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": mg(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...r,
        ref: t,
        onClick: Yr(e.onClick, i.onOpenToggle)
      }
    );
  }
);
tT.displayName = eT;
var hg = "CollapsibleContent", nT = w.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = pg(hg, e.__scopeCollapsible);
    return /* @__PURE__ */ C.jsx(xf, { present: n || i.open, children: ({ present: a }) => /* @__PURE__ */ C.jsx(DZ, { ...r, ref: t, present: a }) });
  }
);
nT.displayName = hg;
var DZ = w.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...a } = e, o = pg(hg, n), [s, l] = w.useState(r), c = w.useRef(null), u = ji(t, c), f = w.useRef(0), d = f.current, p = w.useRef(0), h = p.current, m = o.open || s, y = w.useRef(m), v = w.useRef();
  return w.useEffect(() => {
    const g = requestAnimationFrame(() => y.current = !1);
    return () => cancelAnimationFrame(g);
  }, []), Za(() => {
    const g = c.current;
    if (g) {
      v.current = v.current || {
        transitionDuration: g.style.transitionDuration,
        animationName: g.style.animationName
      }, g.style.transitionDuration = "0s", g.style.animationName = "none";
      const b = g.getBoundingClientRect();
      f.current = b.height, p.current = b.width, y.current || (g.style.transitionDuration = v.current.transitionDuration, g.style.animationName = v.current.animationName), l(r);
    }
  }, [o.open, r]), /* @__PURE__ */ C.jsx(
    kn.div,
    {
      "data-state": mg(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !m,
      ...a,
      ref: u,
      style: {
        "--radix-collapsible-content-height": d ? `${d}px` : void 0,
        "--radix-collapsible-content-width": h ? `${h}px` : void 0,
        ...e.style
      },
      children: m && i
    }
  );
});
function mg(e) {
  return e ? "open" : "closed";
}
var MZ = QO, LZ = nT;
const FZ = ({ ...e }) => {
  var o, s;
  const { header: t, modal: n } = xt, r = De((l) => l.restartConversation), { showModal: i } = h$(), a = (l) => {
    var c, u, f, d;
    l.stopPropagation(), i({
      title: "Restart Conversation",
      content: /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
        /* @__PURE__ */ C.jsx("p", { ...(u = (c = n == null ? void 0 : n.dialog) == null ? void 0 : c.newConversation) == null ? void 0 : u.text, children: "Are you sure you want to restart a new conversation?" }),
        /* @__PURE__ */ C.jsx(la.Close, { asChild: !0, children: /* @__PURE__ */ C.jsx("button", { type: "button", ...(d = (f = n == null ? void 0 : n.dialog) == null ? void 0 : f.newConversation) == null ? void 0 : d.button, onClick: r, children: "Restart" }) })
      ] })
    });
  };
  return /* @__PURE__ */ C.jsx(
    i7,
    {
      ...e,
      ...(s = (o = t == null ? void 0 : t.content) == null ? void 0 : o.actions) == null ? void 0 : s.icons,
      role: "button",
      tabIndex: 0,
      onClick: a,
      onKeyDown: (l) => {
        l.key === "Enter" && a(l);
      }
    }
  );
}, BZ = ({ ...e }) => {
  const { header: t } = xt, n = De((i) => i.closeWindow), r = (i) => {
    i.stopPropagation(), n == null || n();
  };
  return /* @__PURE__ */ C.jsx(
    XO,
    {
      ...e,
      ...t.content.actions.icons,
      role: "button",
      tabIndex: 0,
      onClick: r,
      onKeyDown: (i) => {
        i.key === "Enter" && r(i);
      }
    }
  );
}, Bo = ({ icon: e, title: t, link: n, ...r }) => {
  var o, s, l, c, u, f, d, p, h, m, y, v;
  const { header: i } = xt, a = e ?? V7;
  return t ? n ? /* @__PURE__ */ C.jsxs(
    "a",
    {
      ...r,
      ...(s = (o = i.expandedContent) == null ? void 0 : o.descriptionItems) == null ? void 0 : s.container,
      href: n,
      target: "_blank",
      rel: "noreferrer noopener",
      children: [
        /* @__PURE__ */ C.jsx(a, { ...(c = (l = i.expandedContent) == null ? void 0 : l.descriptionItems) == null ? void 0 : c.icon }),
        /* @__PURE__ */ C.jsx("p", { ...(f = (u = i.expandedContent) == null ? void 0 : u.descriptionItems) == null ? void 0 : f.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ C.jsxs("div", { ...r, ...(p = (d = i.expandedContent) == null ? void 0 : d.descriptionItems) == null ? void 0 : p.container, children: [
    /* @__PURE__ */ C.jsx(a, { ...(m = (h = i.expandedContent) == null ? void 0 : h.descriptionItems) == null ? void 0 : m.icon }),
    /* @__PURE__ */ C.jsx("p", { ...(v = (y = i.expandedContent) == null ? void 0 : y.descriptionItems) == null ? void 0 : v.text, children: t })
  ] }) : null;
}, zZ = ({ defaultOpen: e, disabled: t, onOpenChange: n, ...r }) => {
  var d, p, h, m, y, v, g, b, k, S, _, $, j, B, O, N, q, M, z, D, R, W;
  const { header: i } = xt, a = De((F) => F.configuration), o = De((F) => F.closeWindow), s = De((F) => F.getClientId)(), l = De((F) => !F.disableRestartConversation), [c, u] = ht(!!e), f = !!((d = a.email) != null && d.title) || !!((p = a.phone) != null && p.title) || !!((h = a.website) != null && h.title) || !!((m = a.termsOfService) != null && m.link) || !!((y = a.privacyPolicy) != null && y.link);
  return /* @__PURE__ */ C.jsxs(
    MZ,
    {
      open: f ? c : !1,
      onOpenChange: u,
      "data-disabled": f ? void 0 : "",
      ...i.container,
      ...r,
      children: [
        /* @__PURE__ */ C.jsxs(tT, { ...i.content.container, children: [
          /* @__PURE__ */ C.jsx(AE, { ...r, userId: s, src: a.botAvatar, ...i.content.avatar, children: a.botName || "Bot" }),
          /* @__PURE__ */ C.jsx("h2", { ...i.content.title, children: a.botName || "Bot" }),
          a.botDescription && /* @__PURE__ */ C.jsx("p", { ...i.content.description, children: a.botDescription }),
          /* @__PURE__ */ C.jsxs("div", { ...i.content.actions.container, children: [
            l && /* @__PURE__ */ C.jsx(FZ, {}),
            o && /* @__PURE__ */ C.jsx(BZ, {})
          ] })
        ] }),
        /* @__PURE__ */ C.jsxs(LZ, { ...i.expandedContent.container, children: [
          /* @__PURE__ */ C.jsxs("div", { "data-links": "", ...i.expandedContent.group, children: [
            /* @__PURE__ */ C.jsx(
              Bo,
              {
                "data-email": "",
                icon: e9,
                title: (v = a.email) == null ? void 0 : v.title,
                link: (b = (g = a.email) == null ? void 0 : g.link) != null && b.startsWith("mailto:") ? (k = a.email) == null ? void 0 : k.link : `mailto:${(S = a.email) == null ? void 0 : S.link}`
              }
            ),
            /* @__PURE__ */ C.jsx(
              Bo,
              {
                "data-phone": "",
                icon: o9,
                title: (_ = a.phone) == null ? void 0 : _.title,
                link: (j = ($ = a.phone) == null ? void 0 : $.link) != null && j.startsWith("tel:") ? (B = a.phone) == null ? void 0 : B.link : `tel:${(O = a.phone) == null ? void 0 : O.link}`
              }
            ),
            /* @__PURE__ */ C.jsx(
              Bo,
              {
                "data-website": "",
                link: (N = a.website) == null ? void 0 : N.link,
                icon: n9,
                title: (q = a.website) == null ? void 0 : q.title
              }
            )
          ] }),
          /* @__PURE__ */ C.jsxs("div", { "data-legal": "", ...(M = i.expandedContent) == null ? void 0 : M.group, children: [
            /* @__PURE__ */ C.jsx(
              Bo,
              {
                "data-terms": "",
                link: (z = a.termsOfService) == null ? void 0 : z.link,
                icon: X7,
                title: (D = a.termsOfService) == null ? void 0 : D.title
              }
            ),
            /* @__PURE__ */ C.jsx(
              Bo,
              {
                "data-privacy": "",
                link: (R = a.privacyPolicy) == null ? void 0 : R.link,
                icon: i9,
                title: (W = a.privacyPolicy) == null ? void 0 : W.title
              }
            )
          ] })
        ] })
      ]
    }
  );
}, UZ = Ju(({ ...e }) => {
  const { typingIndicator: t } = xt;
  return /* @__PURE__ */ C.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ C.jsx("div", { ...t == null ? void 0 : t.loader }) });
}), p0 = Ju(
  _n(
    ({ direction: e, block: t, scroll: n, disableInput: r, children: i, sender: a, id: o, metadata: s, ...l }, c) => {
      var v, g, b, k;
      const [u, f] = ht([]), { message: d } = xt, { botAvatar: p, botName: h } = De((S) => S.configuration), m = De((S) => S.getClientId)(), y = fE(m ?? "", 15);
      return /* @__PURE__ */ C.jsx(d$.Provider, { value: { isLoading: u, setIsLoading: f }, children: /* @__PURE__ */ C.jsxs(
        "div",
        {
          ...l,
          ...d == null ? void 0 : d.container,
          "data-loaded": u.length === 0,
          "data-disable-input": !!r,
          "data-direction": e,
          ref: c,
          children: [
            /* @__PURE__ */ C.jsxs(Km, { "data-color": y, ...(v = d == null ? void 0 : d.avatar) == null ? void 0 : v.container, children: [
              /* @__PURE__ */ C.jsx(Gm, { ...(g = d == null ? void 0 : d.avatar) == null ? void 0 : g.image, src: (a == null ? void 0 : a.avatar) ?? p }),
              /* @__PURE__ */ C.jsx(Ym, { ...(b = d == null ? void 0 : d.avatar) == null ? void 0 : b.fallback, children: (a == null ? void 0 : a.name[0]) ?? ((k = h ?? "Bot") == null ? void 0 : k[0]) })
            ] }),
            t && /* @__PURE__ */ C.jsx(hl, { block: t, direction: e, sender: a, timestamp: l.timestamp, messageId: o, metadata: s }),
            i
          ]
        }
      ) });
    }
  )
);
function qZ() {
  const e = De((r) => r.getClientId)(), t = De((r) => r.configuration), {
    messageList: { marquee: n }
  } = xt;
  return /* @__PURE__ */ C.jsxs("li", { ...n.container, children: [
    /* @__PURE__ */ C.jsx(AE, { userId: e, src: t.botAvatar, ...n.avatar, children: (t.botName || "Bot").slice(0, 1) }),
    /* @__PURE__ */ C.jsxs("div", { ...n.content, children: [
      /* @__PURE__ */ C.jsx("h1", { ...n.title, children: t.botName || "Bot" }),
      /* @__PURE__ */ C.jsx("p", { ...n.description, children: t.botDescription })
    ] })
  ] });
}
function WZ(e, t) {
  try {
    var n = global, r = n.document;
    if (typeof r < "u" && r.createElement && r.head && r.head.appendChild) {
      var i = r.querySelector('html meta[name="'.concat(encodeURI(e), '"]')) || r.createElement("meta");
      i.setAttribute("name", e), i.setAttribute("content", t), r.head.appendChild(i);
    }
  } catch {
  }
}
function HZ() {
  WZ("react-scroll-to-bottom:version", "4.2.0");
}
var zo = function(e) {
  return e && e.Math === Math && e;
}, Vt = (
  // eslint-disable-next-line es/no-global-this -- safe
  zo(typeof globalThis == "object" && globalThis) || zo(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  zo(typeof self == "object" && self) || zo(typeof ft == "object" && ft) || zo(typeof ft == "object" && ft) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), Zt = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, VZ = Zt, Sf = !VZ(function() {
  var e = (function() {
  }).bind();
  return typeof e != "function" || e.hasOwnProperty("prototype");
}), ZZ = Sf, rT = Function.prototype, h0 = rT.apply, m0 = rT.call, vg = typeof Reflect == "object" && Reflect.apply || (ZZ ? m0.bind(h0) : function() {
  return m0.apply(h0, arguments);
}), iT = Sf, aT = Function.prototype, bm = aT.call, KZ = iT && aT.bind.bind(bm, bm), Kt = iT ? KZ : function(e) {
  return function() {
    return bm.apply(e, arguments);
  };
}, oT = Kt, GZ = oT({}.toString), YZ = oT("".slice), pa = function(e) {
  return YZ(GZ(e), 8, -1);
}, JZ = pa, XZ = Kt, gg = function(e) {
  if (JZ(e) === "Function") return XZ(e);
}, ap = typeof document == "object" && document.all, un = typeof ap > "u" && ap !== void 0 ? function(e) {
  return typeof e == "function" || e === ap;
} : function(e) {
  return typeof e == "function";
}, ml = {}, QZ = Zt, $n = !QZ(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), eK = Sf, Ql = Function.prototype.call, Fr = eK ? Ql.bind(Ql) : function() {
  return Ql.apply(Ql, arguments);
}, yg = {}, sT = {}.propertyIsEnumerable, lT = Object.getOwnPropertyDescriptor, tK = lT && !sT.call({ 1: 2 }, 1);
yg.f = tK ? function(t) {
  var n = lT(this, t);
  return !!n && n.enumerable;
} : sT;
var vl = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, nK = Kt, rK = Zt, iK = pa, op = Object, aK = nK("".split), cT = rK(function() {
  return !op("z").propertyIsEnumerable(0);
}) ? function(e) {
  return iK(e) === "String" ? aK(e, "") : op(e);
} : op, bg = function(e) {
  return e == null;
}, oK = bg, sK = TypeError, xg = function(e) {
  if (oK(e)) throw new sK("Can't call method on " + e);
  return e;
}, lK = cT, cK = xg, Br = function(e) {
  return lK(cK(e));
}, uK = un, ii = function(e) {
  return typeof e == "object" ? e !== null : uK(e);
}, nn = {}, sp = nn, lp = Vt, fK = un, v0 = function(e) {
  return fK(e) ? e : void 0;
}, zr = function(e, t) {
  return arguments.length < 2 ? v0(sp[e]) || v0(lp[e]) : sp[e] && sp[e][t] || lp[e] && lp[e][t];
}, dK = Kt, ai = dK({}.isPrototypeOf), pK = Vt, g0 = pK.navigator, y0 = g0 && g0.userAgent, wg = y0 ? String(y0) : "", uT = Vt, cp = wg, b0 = uT.process, x0 = uT.Deno, w0 = b0 && b0.versions || x0 && x0.version, S0 = w0 && w0.v8, tr, Fu;
S0 && (tr = S0.split("."), Fu = tr[0] > 0 && tr[0] < 4 ? 1 : +(tr[0] + tr[1]));
!Fu && cp && (tr = cp.match(/Edge\/(\d+)/), (!tr || tr[1] >= 74) && (tr = cp.match(/Chrome\/(\d+)/), tr && (Fu = +tr[1])));
var Sg = Fu, E0 = Sg, hK = Zt, mK = Vt, vK = mK.String, Eo = !!Object.getOwnPropertySymbols && !hK(function() {
  var e = Symbol("symbol detection");
  return !vK(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && E0 && E0 < 41;
}), gK = Eo, fT = gK && !Symbol.sham && typeof Symbol.iterator == "symbol", yK = zr, bK = un, xK = ai, wK = fT, SK = Object, gl = wK ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = yK("Symbol");
  return bK(t) && xK(t.prototype, SK(e));
}, EK = String, Ef = function(e) {
  try {
    return EK(e);
  } catch {
    return "Object";
  }
}, _K = un, kK = Ef, $K = TypeError, Eg = function(e) {
  if (_K(e)) return e;
  throw new $K(kK(e) + " is not a function");
}, OK = Eg, TK = bg, _g = function(e, t) {
  var n = e[t];
  return TK(n) ? void 0 : OK(n);
}, up = Fr, fp = un, dp = ii, CK = TypeError, RK = function(e, t) {
  var n, r;
  if (t === "string" && fp(n = e.toString) && !dp(r = up(n, e)) || fp(n = e.valueOf) && !dp(r = up(n, e)) || t !== "string" && fp(n = e.toString) && !dp(r = up(n, e))) return r;
  throw new CK("Can't convert object to primitive value");
}, dT = { exports: {} }, _0 = Vt, IK = Object.defineProperty, AK = function(e, t) {
  try {
    IK(_0, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    _0[e] = t;
  }
  return t;
}, PK = Vt, jK = AK, k0 = "__core-js_shared__", $0 = dT.exports = PK[k0] || jK(k0, {});
($0.versions || ($0.versions = [])).push({
  version: "3.38.1",
  mode: "pure",
  copyright: " 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var kg = dT.exports, O0 = kg, _o = function(e, t) {
  return O0[e] || (O0[e] = t || {});
}, NK = xg, DK = Object, oi = function(e) {
  return DK(NK(e));
}, MK = Kt, LK = oi, FK = MK({}.hasOwnProperty), jn = Object.hasOwn || function(t, n) {
  return FK(LK(t), n);
}, BK = Kt, zK = 0, UK = Math.random(), qK = BK(1 .toString), $g = function(e) {
  return "Symbol(" + (e === void 0 ? "" : e) + ")_" + qK(++zK + UK, 36);
}, WK = Vt, HK = _o, T0 = jn, VK = $g, ZK = Eo, KK = fT, La = WK.Symbol, pp = HK("wks"), GK = KK ? La.for || La : La && La.withoutSetter || VK, Jt = function(e) {
  return T0(pp, e) || (pp[e] = ZK && T0(La, e) ? La[e] : GK("Symbol." + e)), pp[e];
}, YK = Fr, C0 = ii, R0 = gl, JK = _g, XK = RK, QK = Jt, eG = TypeError, tG = QK("toPrimitive"), nG = function(e, t) {
  if (!C0(e) || R0(e)) return e;
  var n = JK(e, tG), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = YK(n, e, t), !C0(r) || R0(r)) return r;
    throw new eG("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), XK(e, t);
}, rG = nG, iG = gl, Og = function(e) {
  var t = rG(e, "string");
  return iG(t) ? t : t + "";
}, aG = Vt, I0 = ii, xm = aG.document, oG = I0(xm) && I0(xm.createElement), pT = function(e) {
  return oG ? xm.createElement(e) : {};
}, sG = $n, lG = Zt, cG = pT, hT = !sG && !lG(function() {
  return Object.defineProperty(cG("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), uG = $n, fG = Fr, dG = yg, pG = vl, hG = Br, mG = Og, vG = jn, gG = hT, A0 = Object.getOwnPropertyDescriptor;
ml.f = uG ? A0 : function(t, n) {
  if (t = hG(t), n = mG(n), gG) try {
    return A0(t, n);
  } catch {
  }
  if (vG(t, n)) return pG(!fG(dG.f, t, n), t[n]);
};
var yG = Zt, bG = un, xG = /#|\.prototype\./, yl = function(e, t) {
  var n = SG[wG(e)];
  return n === _G ? !0 : n === EG ? !1 : bG(t) ? yG(t) : !!t;
}, wG = yl.normalize = function(e) {
  return String(e).replace(xG, ".").toLowerCase();
}, SG = yl.data = {}, EG = yl.NATIVE = "N", _G = yl.POLYFILL = "P", kG = yl, P0 = gg, $G = Eg, OG = Sf, TG = P0(P0.bind), Tg = function(e, t) {
  return $G(e), t === void 0 ? e : OG ? TG(e, t) : function() {
    return e.apply(t, arguments);
  };
}, pr = {}, CG = $n, RG = Zt, mT = CG && RG(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), IG = ii, AG = String, PG = TypeError, Fi = function(e) {
  if (IG(e)) return e;
  throw new PG(AG(e) + " is not an object");
}, jG = $n, NG = hT, DG = mT, ec = Fi, j0 = Og, MG = TypeError, hp = Object.defineProperty, LG = Object.getOwnPropertyDescriptor, mp = "enumerable", vp = "configurable", gp = "writable";
pr.f = jG ? DG ? function(t, n, r) {
  if (ec(t), n = j0(n), ec(r), typeof t == "function" && n === "prototype" && "value" in r && gp in r && !r[gp]) {
    var i = LG(t, n);
    i && i[gp] && (t[n] = r.value, r = {
      configurable: vp in r ? r[vp] : i[vp],
      enumerable: mp in r ? r[mp] : i[mp],
      writable: !1
    });
  }
  return hp(t, n, r);
} : hp : function(t, n, r) {
  if (ec(t), n = j0(n), ec(r), NG) try {
    return hp(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new MG("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var FG = $n, BG = pr, zG = vl, _f = FG ? function(e, t, n) {
  return BG.f(e, t, zG(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, Uo = Vt, UG = vg, qG = gg, WG = un, HG = ml.f, VG = kG, $a = nn, ZG = Tg, Oa = _f, N0 = jn, KG = function(e) {
  var t = function(n, r, i) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e();
        case 1:
          return new e(n);
        case 2:
          return new e(n, r);
      }
      return new e(n, r, i);
    }
    return UG(e, this, arguments);
  };
  return t.prototype = e.prototype, t;
}, mt = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, a = e.proto, o = r ? Uo : i ? Uo[n] : Uo[n] && Uo[n].prototype, s = r ? $a : $a[n] || Oa($a, n, {})[n], l = s.prototype, c, u, f, d, p, h, m, y, v;
  for (d in t)
    c = VG(r ? d : n + (i ? "." : "#") + d, e.forced), u = !c && o && N0(o, d), h = s[d], u && (e.dontCallGetSet ? (v = HG(o, d), m = v && v.value) : m = o[d]), p = u && m ? m : t[d], !(!c && !a && typeof h == typeof p) && (e.bind && u ? y = ZG(p, Uo) : e.wrap && u ? y = KG(p) : a && WG(p) ? y = qG(p) : y = p, (e.sham || p && p.sham || h && h.sham) && Oa(y, "sham", !0), Oa(s, d, y), a && (f = n + "Prototype", N0($a, f) || Oa($a, f, {}), Oa($a[f], d, p), e.real && l && (c || !l[d]) && Oa(l, d, p)));
}, GG = pa, ko = Array.isArray || function(t) {
  return GG(t) === "Array";
}, YG = mt, JG = ko;
YG({ target: "Array", stat: !0 }, {
  isArray: JG
});
var XG = nn, QG = XG.Array.isArray, eY = QG, vT = eY, tY = vT, nY = tY, rY = nY, iY = rY, aY = iY;
const gT = /* @__PURE__ */ Ze(aY);
function oY(e) {
  if (gT(e)) return e;
}
var sY = Math.ceil, lY = Math.floor, cY = Math.trunc || function(t) {
  var n = +t;
  return (n > 0 ? lY : sY)(n);
}, uY = cY, kf = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : uY(t);
}, fY = kf, dY = Math.min, pY = function(e) {
  var t = fY(e);
  return t > 0 ? dY(t, 9007199254740991) : 0;
}, hY = pY, ha = function(e) {
  return hY(e.length);
}, mY = TypeError, vY = 9007199254740991, Cg = function(e) {
  if (e > vY) throw mY("Maximum allowed index exceeded");
  return e;
}, gY = $n, yY = pr, bY = vl, bl = function(e, t, n) {
  gY ? yY.f(e, t, bY(0, n)) : e[t] = n;
}, xY = Jt, wY = xY("toStringTag"), yT = {};
yT[wY] = "z";
var Rg = String(yT) === "[object z]", SY = Rg, EY = un, Lc = pa, _Y = Jt, kY = _Y("toStringTag"), $Y = Object, OY = Lc(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", TY = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, xl = SY ? Lc : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = TY(t = $Y(e), kY)) == "string" ? n : OY ? Lc(t) : (r = Lc(t)) === "Object" && EY(t.callee) ? "Arguments" : r;
}, CY = Kt, RY = un, wm = kg, IY = CY(Function.toString);
RY(wm.inspectSource) || (wm.inspectSource = function(e) {
  return IY(e);
});
var AY = wm.inspectSource, PY = Kt, jY = Zt, bT = un, NY = xl, DY = zr, MY = AY, xT = function() {
}, wT = DY("Reflect", "construct"), Ig = /^\s*(?:class|function)\b/, LY = PY(Ig.exec), FY = !Ig.test(xT), qo = function(t) {
  if (!bT(t)) return !1;
  try {
    return wT(xT, [], t), !0;
  } catch {
    return !1;
  }
}, ST = function(t) {
  if (!bT(t)) return !1;
  switch (NY(t)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return FY || !!LY(Ig, MY(t));
  } catch {
    return !0;
  }
};
ST.sham = !0;
var Ag = !wT || jY(function() {
  var e;
  return qo(qo.call) || !qo(Object) || !qo(function() {
    e = !0;
  }) || e;
}) ? ST : qo, D0 = ko, BY = Ag, zY = ii, UY = Jt, qY = UY("species"), M0 = Array, WY = function(e) {
  var t;
  return D0(e) && (t = e.constructor, BY(t) && (t === M0 || D0(t.prototype)) ? t = void 0 : zY(t) && (t = t[qY], t === null && (t = void 0))), t === void 0 ? M0 : t;
}, HY = WY, Pg = function(e, t) {
  return new (HY(e))(t === 0 ? 0 : t);
}, VY = Zt, ZY = Jt, KY = Sg, GY = ZY("species"), $f = function(e) {
  return KY >= 51 || !VY(function() {
    var t = [], n = t.constructor = {};
    return n[GY] = function() {
      return { foo: 1 };
    }, t[e](Boolean).foo !== 1;
  });
}, YY = mt, JY = Zt, XY = ko, QY = ii, eJ = oi, tJ = ha, L0 = Cg, F0 = bl, nJ = Pg, rJ = $f, iJ = Jt, aJ = Sg, ET = iJ("isConcatSpreadable"), oJ = aJ >= 51 || !JY(function() {
  var e = [];
  return e[ET] = !1, e.concat()[0] !== e;
}), sJ = function(e) {
  if (!QY(e)) return !1;
  var t = e[ET];
  return t !== void 0 ? !!t : XY(e);
}, lJ = !oJ || !rJ("concat");
YY({ target: "Array", proto: !0, arity: 1, forced: lJ }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function(t) {
    var n = eJ(this), r = nJ(n, 0), i = 0, a, o, s, l, c;
    for (a = -1, s = arguments.length; a < s; a++)
      if (c = a === -1 ? n : arguments[a], sJ(c))
        for (l = tJ(c), L0(i + l), o = 0; o < l; o++, i++) o in c && F0(r, i, c[o]);
      else
        L0(i + 1), F0(r, i++, c);
    return r.length = i, r;
  }
});
var cJ = xl, uJ = String, wl = function(e) {
  if (cJ(e) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return uJ(e);
}, Of = {}, fJ = kf, dJ = Math.max, pJ = Math.min, jg = function(e, t) {
  var n = fJ(e);
  return n < 0 ? dJ(n + t, 0) : pJ(n, t);
}, hJ = Br, mJ = jg, vJ = ha, B0 = function(e) {
  return function(t, n, r) {
    var i = hJ(t), a = vJ(i);
    if (a === 0) return !e && -1;
    var o = mJ(r, a), s;
    if (e && n !== n) {
      for (; a > o; )
        if (s = i[o++], s !== s) return !0;
    } else for (; a > o; o++)
      if ((e || o in i) && i[o] === n) return e || o || 0;
    return !e && -1;
  };
}, _T = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: B0(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: B0(!1)
}, Tf = {}, gJ = Kt, yp = jn, yJ = Br, bJ = _T.indexOf, xJ = Tf, z0 = gJ([].push), kT = function(e, t) {
  var n = yJ(e), r = 0, i = [], a;
  for (a in n) !yp(xJ, a) && yp(n, a) && z0(i, a);
  for (; t.length > r; ) yp(n, a = t[r++]) && (~bJ(i, a) || z0(i, a));
  return i;
}, Ng = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], wJ = kT, SJ = Ng, Dg = Object.keys || function(t) {
  return wJ(t, SJ);
}, EJ = $n, _J = mT, kJ = pr, $J = Fi, OJ = Br, TJ = Dg;
Of.f = EJ && !_J ? Object.defineProperties : function(t, n) {
  $J(t);
  for (var r = OJ(n), i = TJ(n), a = i.length, o = 0, s; a > o; ) kJ.f(t, s = i[o++], r[s]);
  return t;
};
var CJ = zr, RJ = CJ("document", "documentElement"), IJ = _o, AJ = $g, U0 = IJ("keys"), Cf = function(e) {
  return U0[e] || (U0[e] = AJ(e));
}, PJ = Fi, jJ = Of, q0 = Ng, NJ = Tf, DJ = RJ, MJ = pT, LJ = Cf, W0 = ">", H0 = "<", Sm = "prototype", Em = "script", $T = LJ("IE_PROTO"), bp = function() {
}, OT = function(e) {
  return H0 + Em + W0 + e + H0 + "/" + Em + W0;
}, V0 = function(e) {
  e.write(OT("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, FJ = function() {
  var e = MJ("iframe"), t = "java" + Em + ":", n;
  return e.style.display = "none", DJ.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(OT("document.F=Object")), n.close(), n.F;
}, tc, Fc = function() {
  try {
    tc = new ActiveXObject("htmlfile");
  } catch {
  }
  Fc = typeof document < "u" ? document.domain && tc ? V0(tc) : FJ() : V0(tc);
  for (var e = q0.length; e--; ) delete Fc[Sm][q0[e]];
  return Fc();
};
NJ[$T] = !0;
var Mg = Object.create || function(t, n) {
  var r;
  return t !== null ? (bp[Sm] = PJ(t), r = new bp(), bp[Sm] = null, r[$T] = t) : r = Fc(), n === void 0 ? r : jJ.f(r, n);
}, Rf = {}, BJ = kT, zJ = Ng, UJ = zJ.concat("length", "prototype");
Rf.f = Object.getOwnPropertyNames || function(t) {
  return BJ(t, UJ);
};
var TT = {}, qJ = Kt, If = qJ([].slice), WJ = pa, HJ = Br, CT = Rf.f, VJ = If, RT = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], ZJ = function(e) {
  try {
    return CT(e);
  } catch {
    return VJ(RT);
  }
};
TT.f = function(t) {
  return RT && WJ(t) === "Window" ? ZJ(t) : CT(HJ(t));
};
var Af = {};
Af.f = Object.getOwnPropertySymbols;
var KJ = _f, Pf = function(e, t, n, r) {
  return r && r.enumerable ? e[t] = n : KJ(e, t, n), e;
}, GJ = pr, YJ = function(e, t, n) {
  return GJ.f(e, t, n);
}, Sl = {}, JJ = Jt;
Sl.f = JJ;
var Z0 = nn, XJ = jn, QJ = Sl, eX = pr.f, Ot = function(e) {
  var t = Z0.Symbol || (Z0.Symbol = {});
  XJ(t, e) || eX(t, e, {
    value: QJ.f(e)
  });
}, tX = Fr, nX = zr, rX = Jt, iX = Pf, IT = function() {
  var e = nX("Symbol"), t = e && e.prototype, n = t && t.valueOf, r = rX("toPrimitive");
  t && !t[r] && iX(t, r, function(i) {
    return tX(n, this);
  }, { arity: 1 });
}, aX = Rg, oX = xl, sX = aX ? {}.toString : function() {
  return "[object " + oX(this) + "]";
}, lX = Rg, cX = pr.f, uX = _f, fX = jn, dX = sX, pX = Jt, K0 = pX("toStringTag"), $o = function(e, t, n, r) {
  var i = n ? e : e && e.prototype;
  i && (fX(i, K0) || cX(i, K0, { configurable: !0, value: t }), r && !lX && uX(i, "toString", dX));
}, hX = Vt, mX = un, G0 = hX.WeakMap, vX = mX(G0) && /native code/.test(String(G0)), gX = vX, AT = Vt, yX = ii, bX = _f, xp = jn, wp = kg, xX = Cf, wX = Tf, Y0 = "Object already initialized", _m = AT.TypeError, SX = AT.WeakMap, Bu, Zs, zu, EX = function(e) {
  return zu(e) ? Zs(e) : Bu(e, {});
}, _X = function(e) {
  return function(t) {
    var n;
    if (!yX(t) || (n = Zs(t)).type !== e)
      throw new _m("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (gX || wp.state) {
  var br = wp.state || (wp.state = new SX());
  br.get = br.get, br.has = br.has, br.set = br.set, Bu = function(e, t) {
    if (br.has(e)) throw new _m(Y0);
    return t.facade = e, br.set(e, t), t;
  }, Zs = function(e) {
    return br.get(e) || {};
  }, zu = function(e) {
    return br.has(e);
  };
} else {
  var Ta = xX("state");
  wX[Ta] = !0, Bu = function(e, t) {
    if (xp(e, Ta)) throw new _m(Y0);
    return t.facade = e, bX(e, Ta, t), t;
  }, Zs = function(e) {
    return xp(e, Ta) ? e[Ta] : {};
  }, zu = function(e) {
    return xp(e, Ta);
  };
}
var Lg = {
  set: Bu,
  get: Zs,
  has: zu,
  enforce: EX,
  getterFor: _X
}, kX = Tg, $X = Kt, OX = cT, TX = oi, CX = ha, RX = Pg, J0 = $X([].push), ui = function(e) {
  var t = e === 1, n = e === 2, r = e === 3, i = e === 4, a = e === 6, o = e === 7, s = e === 5 || a;
  return function(l, c, u, f) {
    for (var d = TX(l), p = OX(d), h = CX(p), m = kX(c, u), y = 0, v = f || RX, g = t ? v(l, h) : n || o ? v(l, 0) : void 0, b, k; h > y; y++) if ((s || y in p) && (b = p[y], k = m(b, y, d), e))
      if (t) g[y] = k;
      else if (k) switch (e) {
        case 3:
          return !0;
        case 5:
          return b;
        case 6:
          return y;
        case 2:
          J0(g, b);
      }
      else switch (e) {
        case 4:
          return !1;
        case 7:
          J0(g, b);
      }
    return a ? -1 : r || i ? i : g;
  };
}, Fg = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: ui(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: ui(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: ui(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: ui(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: ui(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: ui(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: ui(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: ui(7)
}, jf = mt, El = Vt, Bg = Fr, IX = Kt, uo = $n, fo = Eo, AX = Zt, Yt = jn, PX = ai, km = Fi, Nf = Br, zg = Og, jX = wl, $m = vl, po = Mg, PT = Dg, NX = Rf, jT = TT, DX = Af, NT = ml, DT = pr, MX = Of, MT = yg, X0 = Pf, LX = YJ, Ug = _o, FX = Cf, LT = Tf, Q0 = $g, BX = Jt, zX = Sl, UX = Ot, qX = IT, WX = $o, FT = Lg, Df = Fg.forEach, wn = FX("hidden"), Mf = "Symbol", Ks = "prototype", HX = FT.set, e1 = FT.getterFor(Mf), ir = Object[Ks], Xi = El.Symbol, Xo = Xi && Xi[Ks], VX = El.RangeError, ZX = El.TypeError, Sp = El.QObject, BT = NT.f, Qi = DT.f, zT = jT.f, KX = MT.f, UT = IX([].push), ti = Ug("symbols"), _l = Ug("op-symbols"), GX = Ug("wks"), Om = !Sp || !Sp[Ks] || !Sp[Ks].findChild, qT = function(e, t, n) {
  var r = BT(ir, t);
  r && delete ir[t], Qi(e, t, n), r && e !== ir && Qi(ir, t, r);
}, Tm = uo && AX(function() {
  return po(Qi({}, "a", {
    get: function() {
      return Qi(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? qT : Qi, Ep = function(e, t) {
  var n = ti[e] = po(Xo);
  return HX(n, {
    type: Mf,
    tag: e,
    description: t
  }), uo || (n.description = t), n;
}, Lf = function(t, n, r) {
  t === ir && Lf(_l, n, r), km(t);
  var i = zg(n);
  return km(r), Yt(ti, i) ? (r.enumerable ? (Yt(t, wn) && t[wn][i] && (t[wn][i] = !1), r = po(r, { enumerable: $m(0, !1) })) : (Yt(t, wn) || Qi(t, wn, $m(1, po(null))), t[wn][i] = !0), Tm(t, i, r)) : Qi(t, i, r);
}, qg = function(t, n) {
  km(t);
  var r = Nf(n), i = PT(r).concat(ZT(r));
  return Df(i, function(a) {
    (!uo || Bg(WT, r, a)) && Lf(t, a, r[a]);
  }), t;
}, YX = function(t, n) {
  return n === void 0 ? po(t) : qg(po(t), n);
}, WT = function(t) {
  var n = zg(t), r = Bg(KX, this, n);
  return this === ir && Yt(ti, n) && !Yt(_l, n) ? !1 : r || !Yt(this, n) || !Yt(ti, n) || Yt(this, wn) && this[wn][n] ? r : !0;
}, HT = function(t, n) {
  var r = Nf(t), i = zg(n);
  if (!(r === ir && Yt(ti, i) && !Yt(_l, i))) {
    var a = BT(r, i);
    return a && Yt(ti, i) && !(Yt(r, wn) && r[wn][i]) && (a.enumerable = !0), a;
  }
}, VT = function(t) {
  var n = zT(Nf(t)), r = [];
  return Df(n, function(i) {
    !Yt(ti, i) && !Yt(LT, i) && UT(r, i);
  }), r;
}, ZT = function(e) {
  var t = e === ir, n = zT(t ? _l : Nf(e)), r = [];
  return Df(n, function(i) {
    Yt(ti, i) && (!t || Yt(ir, i)) && UT(r, ti[i]);
  }), r;
};
fo || (Xi = function() {
  if (PX(Xo, this)) throw new ZX("Symbol is not a constructor");
  var t = !arguments.length || arguments[0] === void 0 ? void 0 : jX(arguments[0]), n = Q0(t), r = function(i) {
    var a = this === void 0 ? El : this;
    a === ir && Bg(r, _l, i), Yt(a, wn) && Yt(a[wn], n) && (a[wn][n] = !1);
    var o = $m(1, i);
    try {
      Tm(a, n, o);
    } catch (s) {
      if (!(s instanceof VX)) throw s;
      qT(a, n, o);
    }
  };
  return uo && Om && Tm(ir, n, { configurable: !0, set: r }), Ep(n, t);
}, Xo = Xi[Ks], X0(Xo, "toString", function() {
  return e1(this).tag;
}), X0(Xi, "withoutSetter", function(e) {
  return Ep(Q0(e), e);
}), MT.f = WT, DT.f = Lf, MX.f = qg, NT.f = HT, NX.f = jT.f = VT, DX.f = ZT, zX.f = function(e) {
  return Ep(BX(e), e);
}, uo && LX(Xo, "description", {
  configurable: !0,
  get: function() {
    return e1(this).description;
  }
}));
jf({ global: !0, constructor: !0, wrap: !0, forced: !fo, sham: !fo }, {
  Symbol: Xi
});
Df(PT(GX), function(e) {
  UX(e);
});
jf({ target: Mf, stat: !0, forced: !fo }, {
  useSetter: function() {
    Om = !0;
  },
  useSimple: function() {
    Om = !1;
  }
});
jf({ target: "Object", stat: !0, forced: !fo, sham: !uo }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: YX,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: Lf,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: qg,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: HT
});
jf({ target: "Object", stat: !0, forced: !fo }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: VT
});
qX();
WX(Xi, Mf);
LT[wn] = !0;
var JX = Eo, KT = JX && !!Symbol.for && !!Symbol.keyFor, XX = mt, QX = zr, eQ = jn, tQ = wl, GT = _o, nQ = KT, _p = GT("string-to-symbol-registry"), rQ = GT("symbol-to-string-registry");
XX({ target: "Symbol", stat: !0, forced: !nQ }, {
  for: function(e) {
    var t = tQ(e);
    if (eQ(_p, t)) return _p[t];
    var n = QX("Symbol")(t);
    return _p[t] = n, rQ[n] = t, n;
  }
});
var iQ = mt, aQ = jn, oQ = gl, sQ = Ef, lQ = _o, cQ = KT, t1 = lQ("symbol-to-string-registry");
iQ({ target: "Symbol", stat: !0, forced: !cQ }, {
  keyFor: function(t) {
    if (!oQ(t)) throw new TypeError(sQ(t) + " is not a symbol");
    if (aQ(t1, t)) return t1[t];
  }
});
var uQ = Kt, n1 = ko, fQ = un, r1 = pa, dQ = wl, i1 = uQ([].push), pQ = function(e) {
  if (fQ(e)) return e;
  if (n1(e)) {
    for (var t = e.length, n = [], r = 0; r < t; r++) {
      var i = e[r];
      typeof i == "string" ? i1(n, i) : (typeof i == "number" || r1(i) === "Number" || r1(i) === "String") && i1(n, dQ(i));
    }
    var a = n.length, o = !0;
    return function(s, l) {
      if (o)
        return o = !1, l;
      if (n1(this)) return l;
      for (var c = 0; c < a; c++) if (n[c] === s) return l;
    };
  }
}, hQ = mt, YT = zr, JT = vg, mQ = Fr, kl = Kt, XT = Zt, a1 = un, o1 = gl, QT = If, vQ = pQ, gQ = Eo, yQ = String, Si = YT("JSON", "stringify"), nc = kl(/./.exec), s1 = kl("".charAt), bQ = kl("".charCodeAt), xQ = kl("".replace), wQ = kl(1 .toString), SQ = /[\uD800-\uDFFF]/g, l1 = /^[\uD800-\uDBFF]$/, c1 = /^[\uDC00-\uDFFF]$/, u1 = !gQ || XT(function() {
  var e = YT("Symbol")("stringify detection");
  return Si([e]) !== "[null]" || Si({ a: e }) !== "{}" || Si(Object(e)) !== "{}";
}), f1 = XT(function() {
  return Si("\uDF06\uD834") !== '"\\udf06\\ud834"' || Si("\uDEAD") !== '"\\udead"';
}), EQ = function(e, t) {
  var n = QT(arguments), r = vQ(t);
  if (!(!a1(r) && (e === void 0 || o1(e))))
    return n[1] = function(i, a) {
      if (a1(r) && (a = mQ(r, this, yQ(i), a)), !o1(a)) return a;
    }, JT(Si, null, n);
}, _Q = function(e, t, n) {
  var r = s1(n, t - 1), i = s1(n, t + 1);
  return nc(l1, e) && !nc(c1, i) || nc(c1, e) && !nc(l1, r) ? "\\u" + wQ(bQ(e, 0), 16) : e;
};
Si && hQ({ target: "JSON", stat: !0, arity: 3, forced: u1 || f1 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  stringify: function(t, n, r) {
    var i = QT(arguments), a = JT(u1 ? EQ : Si, null, i);
    return f1 && typeof a == "string" ? xQ(a, SQ, _Q) : a;
  }
});
var kQ = mt, $Q = Eo, OQ = Zt, eC = Af, TQ = oi, CQ = !$Q || OQ(function() {
  eC.f(1);
});
kQ({ target: "Object", stat: !0, forced: CQ }, {
  getOwnPropertySymbols: function(t) {
    var n = eC.f;
    return n ? n(TQ(t)) : [];
  }
});
var RQ = Ot;
RQ("asyncIterator");
var IQ = Ot;
IQ("hasInstance");
var AQ = Ot;
AQ("isConcatSpreadable");
var PQ = Ot;
PQ("iterator");
var jQ = Ot;
jQ("match");
var NQ = Ot;
NQ("matchAll");
var DQ = Ot;
DQ("replace");
var MQ = Ot;
MQ("search");
var LQ = Ot;
LQ("species");
var FQ = Ot;
FQ("split");
var BQ = Ot, zQ = IT;
BQ("toPrimitive");
zQ();
var UQ = zr, qQ = Ot, WQ = $o;
qQ("toStringTag");
WQ(UQ("Symbol"), "Symbol");
var HQ = Ot;
HQ("unscopables");
var VQ = Vt, ZQ = $o;
ZQ(VQ.JSON, "JSON", !0);
var KQ = nn, GQ = KQ.Symbol, Oo = {}, Cm = $n, YQ = jn, tC = Function.prototype, JQ = Cm && Object.getOwnPropertyDescriptor, Wg = YQ(tC, "name"), XQ = Wg && (function() {
}).name === "something", QQ = Wg && (!Cm || Cm && JQ(tC, "name").configurable), eee = {
  EXISTS: Wg,
  PROPER: XQ,
  CONFIGURABLE: QQ
}, tee = Zt, nee = !tee(function() {
  function e() {
  }
  return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
}), ree = jn, iee = un, aee = oi, oee = Cf, see = nee, d1 = oee("IE_PROTO"), Rm = Object, lee = Rm.prototype, nC = see ? Rm.getPrototypeOf : function(e) {
  var t = aee(e);
  if (ree(t, d1)) return t[d1];
  var n = t.constructor;
  return iee(n) && t instanceof n ? n.prototype : t instanceof Rm ? lee : null;
}, cee = Zt, uee = un, fee = ii, dee = Mg, p1 = nC, pee = Pf, hee = Jt, Im = hee("iterator"), rC = !1, Jr, kp, $p;
[].keys && ($p = [].keys(), "next" in $p ? (kp = p1(p1($p)), kp !== Object.prototype && (Jr = kp)) : rC = !0);
var mee = !fee(Jr) || cee(function() {
  var e = {};
  return Jr[Im].call(e) !== e;
});
mee ? Jr = {} : Jr = dee(Jr);
uee(Jr[Im]) || pee(Jr, Im, function() {
  return this;
});
var iC = {
  IteratorPrototype: Jr,
  BUGGY_SAFARI_ITERATORS: rC
}, vee = iC.IteratorPrototype, gee = Mg, yee = vl, bee = $o, xee = Oo, wee = function() {
  return this;
}, See = function(e, t, n, r) {
  var i = t + " Iterator";
  return e.prototype = gee(vee, { next: yee(+!r, n) }), bee(e, i, !1, !0), xee[i] = wee, e;
}, Eee = mt, _ee = Fr, aC = eee, kee = See, $ee = nC, Oee = $o, h1 = Pf, Tee = Jt, m1 = Oo, oC = iC, Cee = aC.PROPER;
aC.CONFIGURABLE;
oC.IteratorPrototype;
var rc = oC.BUGGY_SAFARI_ITERATORS, Op = Tee("iterator"), v1 = "keys", ic = "values", g1 = "entries", Ree = function() {
  return this;
}, sC = function(e, t, n, r, i, a, o) {
  kee(n, t, r);
  var s = function(v) {
    if (v === i && d) return d;
    if (!rc && v && v in u) return u[v];
    switch (v) {
      case v1:
        return function() {
          return new n(this, v);
        };
      case ic:
        return function() {
          return new n(this, v);
        };
      case g1:
        return function() {
          return new n(this, v);
        };
    }
    return function() {
      return new n(this);
    };
  }, l = t + " Iterator", c = !1, u = e.prototype, f = u[Op] || u["@@iterator"] || i && u[i], d = !rc && f || s(i), p = t === "Array" && u.entries || f, h, m, y;
  if (p && (h = $ee(p.call(new e())), h !== Object.prototype && h.next && (Oee(h, l, !0, !0), m1[l] = Ree)), Cee && i === ic && f && f.name !== ic && (c = !0, d = function() {
    return _ee(f, this);
  }), i)
    if (m = {
      values: s(ic),
      keys: a ? d : s(v1),
      entries: s(g1)
    }, o) for (y in m)
      (rc || c || !(y in u)) && h1(u, y, m[y]);
    else Eee({ target: t, proto: !0, forced: rc || c }, m);
  return o && u[Op] !== d && h1(u, Op, d, { name: i }), m1[t] = d, m;
}, lC = function(e, t) {
  return { value: e, done: t };
}, Iee = Br, y1 = Oo, cC = Lg;
pr.f;
var Aee = sC, ac = lC, uC = "Array Iterator", Pee = cC.set, jee = cC.getterFor(uC);
Aee(Array, "Array", function(e, t) {
  Pee(this, {
    type: uC,
    target: Iee(e),
    // target
    index: 0,
    // next index
    kind: t
    // kind
  });
}, function() {
  var e = jee(this), t = e.target, n = e.index++;
  if (!t || n >= t.length)
    return e.target = null, ac(void 0, !0);
  switch (e.kind) {
    case "keys":
      return ac(n, !1);
    case "values":
      return ac(t[n], !1);
  }
  return ac([n, t[n]], !1);
}, "values");
y1.Arguments = y1.Array;
var Nee = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, Dee = Nee, Mee = Vt, Lee = $o, b1 = Oo;
for (var Tp in Dee)
  Lee(Mee[Tp], Tp), b1[Tp] = b1.Array;
var Fee = GQ, Bee = Fee, zee = Jt, Uee = pr.f, x1 = zee("metadata"), w1 = Function.prototype;
w1[x1] === void 0 && Uee(w1, x1, {
  value: null
});
var qee = Ot;
qee("asyncDispose");
var Wee = Ot;
Wee("dispose");
var Hee = Ot;
Hee("metadata");
var Vee = Bee, Zee = Vee, Kee = zr, Gee = Kt, Hg = Kee("Symbol"), Yee = Hg.keyFor, Jee = Gee(Hg.prototype.valueOf), fC = Hg.isRegisteredSymbol || function(t) {
  try {
    return Yee(Jee(t)) !== void 0;
  } catch {
    return !1;
  }
}, Xee = mt, Qee = fC;
Xee({ target: "Symbol", stat: !0 }, {
  isRegisteredSymbol: Qee
});
var ete = _o, dC = zr, tte = Kt, nte = gl, rte = Jt, Uu = dC("Symbol"), S1 = Uu.isWellKnownSymbol, pC = dC("Object", "getOwnPropertyNames"), ite = tte(Uu.prototype.valueOf), E1 = ete("wks");
for (var Cp = 0, _1 = pC(Uu), ate = _1.length; Cp < ate; Cp++)
  try {
    var k1 = _1[Cp];
    nte(Uu[k1]) && rte(k1);
  } catch {
  }
var hC = function(t) {
  if (S1 && S1(t)) return !0;
  try {
    for (var n = ite(t), r = 0, i = pC(E1), a = i.length; r < a; r++)
      if (E1[i[r]] == n) return !0;
  } catch {
  }
  return !1;
}, ote = mt, ste = hC;
ote({ target: "Symbol", stat: !0, forced: !0 }, {
  isWellKnownSymbol: ste
});
var lte = Ot;
lte("customMatcher");
var cte = Ot;
cte("observable");
var ute = mt, fte = fC;
ute({ target: "Symbol", stat: !0, name: "isRegisteredSymbol" }, {
  isRegistered: fte
});
var dte = mt, pte = hC;
dte({ target: "Symbol", stat: !0, name: "isWellKnownSymbol", forced: !0 }, {
  isWellKnown: pte
});
var hte = Ot;
hte("matcher");
var mte = Ot;
mte("metadataKey");
var vte = Ot;
vte("patternMatch");
var gte = Ot;
gte("replaceAll");
var yte = Zee, bte = yte, xte = bte;
const Fa = /* @__PURE__ */ Ze(xte);
var Vg = Kt, wte = kf, Ste = wl, Ete = xg, _te = Vg("".charAt), $1 = Vg("".charCodeAt), kte = Vg("".slice), O1 = function(e) {
  return function(t, n) {
    var r = Ste(Ete(t)), i = wte(n), a = r.length, o, s;
    return i < 0 || i >= a ? e ? "" : void 0 : (o = $1(r, i), o < 55296 || o > 56319 || i + 1 === a || (s = $1(r, i + 1)) < 56320 || s > 57343 ? e ? _te(r, i) : o : e ? kte(r, i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);
  };
}, $te = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: O1(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: O1(!0)
}, Ote = $te.charAt, Tte = wl, mC = Lg, Cte = sC, T1 = lC, vC = "String Iterator", Rte = mC.set, Ite = mC.getterFor(vC);
Cte(String, "String", function(e) {
  Rte(this, {
    type: vC,
    string: Tte(e),
    index: 0
  });
}, function() {
  var t = Ite(this), n = t.string, r = t.index, i;
  return r >= n.length ? T1(void 0, !0) : (i = Ote(n, r), t.index += i.length, T1(i, !1));
});
var Ate = xl, C1 = _g, Pte = bg, jte = Oo, Nte = Jt, Dte = Nte("iterator"), Zg = function(e) {
  if (!Pte(e)) return C1(e, Dte) || C1(e, "@@iterator") || jte[Ate(e)];
}, Mte = Zg, Lte = Mte, Fte = Lte, Bte = Fte, zte = Bte, Ute = zte, qte = Ute, Wte = qte, Hte = Wte;
const gC = /* @__PURE__ */ Ze(Hte);
var Vte = $n, Zte = ko, Kte = TypeError, Gte = Object.getOwnPropertyDescriptor, Yte = Vte && !function() {
  if (this !== void 0) return !0;
  try {
    Object.defineProperty([], "length", { writable: !1 }).length = 1;
  } catch (e) {
    return e instanceof TypeError;
  }
}(), yC = Yte ? function(e, t) {
  if (Zte(e) && !Gte(e, "length").writable)
    throw new Kte("Cannot set read only .length");
  return e.length = t;
} : function(e, t) {
  return e.length = t;
}, Jte = mt, Xte = oi, Qte = ha, ene = yC, tne = Cg, nne = Zt, rne = nne(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
}), ine = function() {
  try {
    Object.defineProperty([], "length", { writable: !1 }).push();
  } catch (e) {
    return e instanceof TypeError;
  }
}, ane = rne || !ine();
Jte({ target: "Array", proto: !0, arity: 1, forced: ane }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function(t) {
    var n = Xte(this), r = Qte(n), i = arguments.length;
    tne(r + i);
    for (var a = 0; a < i; a++)
      n[r] = arguments[a], r++;
    return ene(n, r), r;
  }
});
var one = Vt, sne = nn, ma = function(e, t) {
  var n = sne[e + "Prototype"], r = n && n[t];
  if (r) return r;
  var i = one[e], a = i && i.prototype;
  return a && a[t];
}, lne = ma, cne = lne("Array", "push"), une = ai, fne = cne, Rp = Array.prototype, dne = function(e) {
  var t = e.push;
  return e === Rp || une(Rp, e) && t === Rp.push ? fne : t;
}, pne = dne, hne = pne, mne = hne, vne = mne, gne = vne, yne = gne, bne = yne;
const xne = /* @__PURE__ */ Ze(bne);
function wne(e, t) {
  var n = e == null ? null : typeof Fa < "u" && gC(e) || e["@@iterator"];
  if (n != null) {
    var r, i, a, o, s = [], l = !0, c = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        l = !1;
      } else for (; !(l = (r = a.call(n)).done) && (xne(s).call(s, r.value), s.length !== t); l = !0) ;
    } catch (u) {
      c = !0, i = u;
    } finally {
      try {
        if (!l && n.return != null && (o = n.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw i;
      }
    }
    return s;
  }
}
var Sne = mt, R1 = ko, Ene = Ag, _ne = ii, I1 = jg, kne = ha, $ne = Br, One = bl, Tne = Jt, Cne = $f, Rne = If, Ine = Cne("slice"), Ane = Tne("species"), Ip = Array, Pne = Math.max;
Sne({ target: "Array", proto: !0, forced: !Ine }, {
  slice: function(t, n) {
    var r = $ne(this), i = kne(r), a = I1(t, i), o = I1(n === void 0 ? i : n, i), s, l, c;
    if (R1(r) && (s = r.constructor, Ene(s) && (s === Ip || R1(s.prototype)) ? s = void 0 : _ne(s) && (s = s[Ane], s === null && (s = void 0)), s === Ip || s === void 0))
      return Rne(r, a, o);
    for (l = new (s === void 0 ? Ip : s)(Pne(o - a, 0)), c = 0; a < o; a++, c++) a in r && One(l, c, r[a]);
    return l.length = c, l;
  }
});
var jne = ma, Nne = jne("Array", "slice"), Dne = ai, Mne = Nne, Ap = Array.prototype, Lne = function(e) {
  var t = e.slice;
  return e === Ap || Dne(Ap, e) && t === Ap.slice ? Mne : t;
}, Fne = Lne, Bne = Fne, zne = Bne, Une = zne, qne = Une, Wne = qne, Hne = Wne;
const Vne = /* @__PURE__ */ Ze(Hne);
var Zne = Fr, A1 = Fi, Kne = _g, Gne = function(e, t, n) {
  var r, i;
  A1(e);
  try {
    if (r = Kne(e, "return"), !r) {
      if (t === "throw") throw n;
      return n;
    }
    r = Zne(r, e);
  } catch (a) {
    i = !0, r = a;
  }
  if (t === "throw") throw n;
  if (i) throw r;
  return A1(r), n;
}, Yne = Fi, Jne = Gne, Xne = function(e, t, n, r) {
  try {
    return r ? t(Yne(n)[0], n[1]) : t(n);
  } catch (i) {
    Jne(e, "throw", i);
  }
}, Qne = Jt, ere = Oo, tre = Qne("iterator"), nre = Array.prototype, rre = function(e) {
  return e !== void 0 && (ere.Array === e || nre[tre] === e);
}, ire = Fr, are = Eg, ore = Fi, sre = Ef, lre = Zg, cre = TypeError, ure = function(e, t) {
  var n = arguments.length < 2 ? lre(e) : t;
  if (are(n)) return ore(ire(n, e));
  throw new cre(sre(e) + " is not iterable");
}, fre = Tg, dre = Fr, pre = oi, hre = Xne, mre = rre, vre = Ag, gre = ha, P1 = bl, yre = ure, bre = Zg, j1 = Array, xre = function(t) {
  var n = pre(t), r = vre(this), i = arguments.length, a = i > 1 ? arguments[1] : void 0, o = a !== void 0;
  o && (a = fre(a, i > 2 ? arguments[2] : void 0));
  var s = bre(n), l = 0, c, u, f, d, p, h;
  if (s && !(this === j1 && mre(s)))
    for (u = r ? new this() : [], d = yre(n, s), p = d.next; !(f = dre(p, d)).done; l++)
      h = o ? hre(d, a, [f.value, l], !0) : f.value, P1(u, l, h);
  else
    for (c = gre(n), u = r ? new this(c) : j1(c); c > l; l++)
      h = o ? a(n[l], l) : n[l], P1(u, l, h);
  return u.length = l, u;
}, wre = Jt, bC = wre("iterator"), xC = !1;
try {
  var Sre = 0, N1 = {
    next: function() {
      return { done: !!Sre++ };
    },
    return: function() {
      xC = !0;
    }
  };
  N1[bC] = function() {
    return this;
  }, Array.from(N1, function() {
    throw 2;
  });
} catch {
}
var Ere = function(e, t) {
  try {
    if (!t && !xC) return !1;
  } catch {
    return !1;
  }
  var n = !1;
  try {
    var r = {};
    r[bC] = function() {
      return {
        next: function() {
          return { done: n = !0 };
        }
      };
    }, e(r);
  } catch {
  }
  return n;
}, _re = mt, kre = xre, $re = Ere, Ore = !$re(function(e) {
  Array.from(e);
});
_re({ target: "Array", stat: !0, forced: Ore }, {
  from: kre
});
var Tre = nn, Cre = Tre.Array.from, Rre = Cre, Ire = Rre, Are = Ire, Pre = Are, jre = Pre, Nre = jre, Dre = Nre;
const wC = /* @__PURE__ */ Ze(Dre);
function Am(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function SC(e, t) {
  if (e) {
    var n;
    if (typeof e == "string") return Am(e, t);
    var r = Vne(n = {}.toString.call(e)).call(n, 8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? wC(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Am(e, t) : void 0;
  }
}
function Mre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _r(e, t) {
  return oY(e) || wne(e, t) || SC(e, t) || Mre();
}
var EC = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var a = arguments[i];
        if (a) {
          var o = typeof a;
          if (o === "string" || o === "number")
            r.push(a);
          else if (Array.isArray(a)) {
            if (a.length) {
              var s = n.apply(null, a);
              s && r.push(s);
            }
          } else if (o === "object")
            if (a.toString === Object.prototype.toString)
              for (var l in a)
                t.call(a, l) && a[l] && r.push(l);
            else
              r.push(a.toString());
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(EC);
var Lre = EC.exports;
const Kg = /* @__PURE__ */ Ze(Lre);
var Pm = { exports: {} }, oc = { exports: {} }, ct = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D1;
function Fre() {
  if (D1) return ct;
  D1 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, g = e ? Symbol.for("react.scope") : 60119;
  function b(S) {
    if (typeof S == "object" && S !== null) {
      var _ = S.$$typeof;
      switch (_) {
        case t:
          switch (S = S.type, S) {
            case l:
            case c:
            case r:
            case a:
            case i:
            case f:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case s:
                case u:
                case h:
                case p:
                case o:
                  return S;
                default:
                  return _;
              }
          }
        case n:
          return _;
      }
    }
  }
  function k(S) {
    return b(S) === c;
  }
  return ct.AsyncMode = l, ct.ConcurrentMode = c, ct.ContextConsumer = s, ct.ContextProvider = o, ct.Element = t, ct.ForwardRef = u, ct.Fragment = r, ct.Lazy = h, ct.Memo = p, ct.Portal = n, ct.Profiler = a, ct.StrictMode = i, ct.Suspense = f, ct.isAsyncMode = function(S) {
    return k(S) || b(S) === l;
  }, ct.isConcurrentMode = k, ct.isContextConsumer = function(S) {
    return b(S) === s;
  }, ct.isContextProvider = function(S) {
    return b(S) === o;
  }, ct.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === t;
  }, ct.isForwardRef = function(S) {
    return b(S) === u;
  }, ct.isFragment = function(S) {
    return b(S) === r;
  }, ct.isLazy = function(S) {
    return b(S) === h;
  }, ct.isMemo = function(S) {
    return b(S) === p;
  }, ct.isPortal = function(S) {
    return b(S) === n;
  }, ct.isProfiler = function(S) {
    return b(S) === a;
  }, ct.isStrictMode = function(S) {
    return b(S) === i;
  }, ct.isSuspense = function(S) {
    return b(S) === f;
  }, ct.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === c || S === a || S === i || S === f || S === d || typeof S == "object" && S !== null && (S.$$typeof === h || S.$$typeof === p || S.$$typeof === o || S.$$typeof === s || S.$$typeof === u || S.$$typeof === y || S.$$typeof === v || S.$$typeof === g || S.$$typeof === m);
  }, ct.typeOf = b, ct;
}
var ut = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var M1;
function Bre() {
  return M1 || (M1 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, g = e ? Symbol.for("react.scope") : 60119;
    function b(V) {
      return typeof V == "string" || typeof V == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      V === r || V === c || V === a || V === i || V === f || V === d || typeof V == "object" && V !== null && (V.$$typeof === h || V.$$typeof === p || V.$$typeof === o || V.$$typeof === s || V.$$typeof === u || V.$$typeof === y || V.$$typeof === v || V.$$typeof === g || V.$$typeof === m);
    }
    function k(V) {
      if (typeof V == "object" && V !== null) {
        var fe = V.$$typeof;
        switch (fe) {
          case t:
            var me = V.type;
            switch (me) {
              case l:
              case c:
              case r:
              case a:
              case i:
              case f:
                return me;
              default:
                var Oe = me && me.$$typeof;
                switch (Oe) {
                  case s:
                  case u:
                  case h:
                  case p:
                  case o:
                    return Oe;
                  default:
                    return fe;
                }
            }
          case n:
            return fe;
        }
      }
    }
    var S = l, _ = c, $ = s, j = o, B = t, O = u, N = r, q = h, M = p, z = n, D = a, R = i, W = f, F = !1;
    function A(V) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), x(V) || k(V) === l;
    }
    function x(V) {
      return k(V) === c;
    }
    function U(V) {
      return k(V) === s;
    }
    function Z(V) {
      return k(V) === o;
    }
    function E(V) {
      return typeof V == "object" && V !== null && V.$$typeof === t;
    }
    function X(V) {
      return k(V) === u;
    }
    function ae(V) {
      return k(V) === r;
    }
    function te(V) {
      return k(V) === h;
    }
    function se(V) {
      return k(V) === p;
    }
    function de(V) {
      return k(V) === n;
    }
    function pe(V) {
      return k(V) === a;
    }
    function le(V) {
      return k(V) === i;
    }
    function J(V) {
      return k(V) === f;
    }
    ut.AsyncMode = S, ut.ConcurrentMode = _, ut.ContextConsumer = $, ut.ContextProvider = j, ut.Element = B, ut.ForwardRef = O, ut.Fragment = N, ut.Lazy = q, ut.Memo = M, ut.Portal = z, ut.Profiler = D, ut.StrictMode = R, ut.Suspense = W, ut.isAsyncMode = A, ut.isConcurrentMode = x, ut.isContextConsumer = U, ut.isContextProvider = Z, ut.isElement = E, ut.isForwardRef = X, ut.isFragment = ae, ut.isLazy = te, ut.isMemo = se, ut.isPortal = de, ut.isProfiler = pe, ut.isStrictMode = le, ut.isSuspense = J, ut.isValidElementType = b, ut.typeOf = k;
  }()), ut;
}
var L1;
function _C() {
  return L1 || (L1 = 1, process.env.NODE_ENV === "production" ? oc.exports = Fre() : oc.exports = Bre()), oc.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Pp, F1;
function zre() {
  if (F1) return Pp;
  F1 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, s = 0; s < 10; s++)
        o["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(o).map(function(u) {
        return o[u];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        c[u] = u;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Pp = i() ? Object.assign : function(a, o) {
    for (var s, l = r(a), c, u = 1; u < arguments.length; u++) {
      s = Object(arguments[u]);
      for (var f in s)
        t.call(s, f) && (l[f] = s[f]);
      if (e) {
        c = e(s);
        for (var d = 0; d < c.length; d++)
          n.call(s, c[d]) && (l[c[d]] = s[c[d]]);
      }
    }
    return l;
  }, Pp;
}
var jp, B1;
function Gg() {
  if (B1) return jp;
  B1 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jp = e, jp;
}
var Np, z1;
function Ure() {
  if (z1) return Np;
  z1 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Gg(), n = {}, r = Function.call.bind(Object.prototype.hasOwnProperty);
    e = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(a, o, s, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in a)
        if (r(a, u)) {
          var f;
          try {
            if (typeof a[u] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[u] + "`."
              );
              throw d.name = "Invariant Violation", d;
            }
            f = a[u](o, u, l, s, null, t);
          } catch (h) {
            f = h;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var p = c ? c() : "";
            e(
              "Failed " + s + " type: " + f.message + (p ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Np = i, Np;
}
var Dp, U1;
function qre() {
  if (U1) return Dp;
  U1 = 1;
  var e = _C(), t = zre(), n = Gg(), r = Ure(), i = Function.call.bind(Object.prototype.hasOwnProperty), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return Dp = function(s, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function f(A) {
      var x = A && (c && A[c] || A[u]);
      if (typeof x == "function")
        return x;
    }
    var d = "<<anonymous>>", p = {
      array: v("array"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: g(),
      arrayOf: b,
      element: k(),
      elementType: S(),
      instanceOf: _,
      node: O(),
      objectOf: j,
      oneOf: $,
      oneOfType: B,
      shape: N,
      exact: q
    };
    function h(A, x) {
      return A === x ? A !== 0 || 1 / A === 1 / x : A !== A && x !== x;
    }
    function m(A) {
      this.message = A, this.stack = "";
    }
    m.prototype = Error.prototype;
    function y(A) {
      if (process.env.NODE_ENV !== "production")
        var x = {}, U = 0;
      function Z(X, ae, te, se, de, pe, le) {
        if (se = se || d, pe = pe || te, le !== n) {
          if (l) {
            var J = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw J.name = "Invariant Violation", J;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var V = se + ":" + te;
            !x[V] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + pe + "` prop on `" + se + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), x[V] = !0, U++);
          }
        }
        return ae[te] == null ? X ? ae[te] === null ? new m("The " + de + " `" + pe + "` is marked as required " + ("in `" + se + "`, but its value is `null`.")) : new m("The " + de + " `" + pe + "` is marked as required in " + ("`" + se + "`, but its value is `undefined`.")) : null : A(ae, te, se, de, pe);
      }
      var E = Z.bind(null, !1);
      return E.isRequired = Z.bind(null, !0), E;
    }
    function v(A) {
      function x(U, Z, E, X, ae, te) {
        var se = U[Z], de = D(se);
        if (de !== A) {
          var pe = R(se);
          return new m("Invalid " + X + " `" + ae + "` of type " + ("`" + pe + "` supplied to `" + E + "`, expected ") + ("`" + A + "`."));
        }
        return null;
      }
      return y(x);
    }
    function g() {
      return y(o);
    }
    function b(A) {
      function x(U, Z, E, X, ae) {
        if (typeof A != "function")
          return new m("Property `" + ae + "` of component `" + E + "` has invalid PropType notation inside arrayOf.");
        var te = U[Z];
        if (!Array.isArray(te)) {
          var se = D(te);
          return new m("Invalid " + X + " `" + ae + "` of type " + ("`" + se + "` supplied to `" + E + "`, expected an array."));
        }
        for (var de = 0; de < te.length; de++) {
          var pe = A(te, de, E, X, ae + "[" + de + "]", n);
          if (pe instanceof Error)
            return pe;
        }
        return null;
      }
      return y(x);
    }
    function k() {
      function A(x, U, Z, E, X) {
        var ae = x[U];
        if (!s(ae)) {
          var te = D(ae);
          return new m("Invalid " + E + " `" + X + "` of type " + ("`" + te + "` supplied to `" + Z + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(A);
    }
    function S() {
      function A(x, U, Z, E, X) {
        var ae = x[U];
        if (!e.isValidElementType(ae)) {
          var te = D(ae);
          return new m("Invalid " + E + " `" + X + "` of type " + ("`" + te + "` supplied to `" + Z + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(A);
    }
    function _(A) {
      function x(U, Z, E, X, ae) {
        if (!(U[Z] instanceof A)) {
          var te = A.name || d, se = F(U[Z]);
          return new m("Invalid " + X + " `" + ae + "` of type " + ("`" + se + "` supplied to `" + E + "`, expected ") + ("instance of `" + te + "`."));
        }
        return null;
      }
      return y(x);
    }
    function $(A) {
      if (!Array.isArray(A))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function x(U, Z, E, X, ae) {
        for (var te = U[Z], se = 0; se < A.length; se++)
          if (h(te, A[se]))
            return null;
        var de = JSON.stringify(A, function(le, J) {
          var V = R(J);
          return V === "symbol" ? String(J) : J;
        });
        return new m("Invalid " + X + " `" + ae + "` of value `" + String(te) + "` " + ("supplied to `" + E + "`, expected one of " + de + "."));
      }
      return y(x);
    }
    function j(A) {
      function x(U, Z, E, X, ae) {
        if (typeof A != "function")
          return new m("Property `" + ae + "` of component `" + E + "` has invalid PropType notation inside objectOf.");
        var te = U[Z], se = D(te);
        if (se !== "object")
          return new m("Invalid " + X + " `" + ae + "` of type " + ("`" + se + "` supplied to `" + E + "`, expected an object."));
        for (var de in te)
          if (i(te, de)) {
            var pe = A(te, de, E, X, ae + "." + de, n);
            if (pe instanceof Error)
              return pe;
          }
        return null;
      }
      return y(x);
    }
    function B(A) {
      if (!Array.isArray(A))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var x = 0; x < A.length; x++) {
        var U = A[x];
        if (typeof U != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + W(U) + " at index " + x + "."
          ), o;
      }
      function Z(E, X, ae, te, se) {
        for (var de = 0; de < A.length; de++) {
          var pe = A[de];
          if (pe(E, X, ae, te, se, n) == null)
            return null;
        }
        return new m("Invalid " + te + " `" + se + "` supplied to " + ("`" + ae + "`."));
      }
      return y(Z);
    }
    function O() {
      function A(x, U, Z, E, X) {
        return M(x[U]) ? null : new m("Invalid " + E + " `" + X + "` supplied to " + ("`" + Z + "`, expected a ReactNode."));
      }
      return y(A);
    }
    function N(A) {
      function x(U, Z, E, X, ae) {
        var te = U[Z], se = D(te);
        if (se !== "object")
          return new m("Invalid " + X + " `" + ae + "` of type `" + se + "` " + ("supplied to `" + E + "`, expected `object`."));
        for (var de in A) {
          var pe = A[de];
          if (pe) {
            var le = pe(te, de, E, X, ae + "." + de, n);
            if (le)
              return le;
          }
        }
        return null;
      }
      return y(x);
    }
    function q(A) {
      function x(U, Z, E, X, ae) {
        var te = U[Z], se = D(te);
        if (se !== "object")
          return new m("Invalid " + X + " `" + ae + "` of type `" + se + "` " + ("supplied to `" + E + "`, expected `object`."));
        var de = t({}, U[Z], A);
        for (var pe in de) {
          var le = A[pe];
          if (!le)
            return new m(
              "Invalid " + X + " `" + ae + "` key `" + pe + "` supplied to `" + E + "`.\nBad object: " + JSON.stringify(U[Z], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(A), null, "  ")
            );
          var J = le(te, pe, E, X, ae + "." + pe, n);
          if (J)
            return J;
        }
        return null;
      }
      return y(x);
    }
    function M(A) {
      switch (typeof A) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !A;
        case "object":
          if (Array.isArray(A))
            return A.every(M);
          if (A === null || s(A))
            return !0;
          var x = f(A);
          if (x) {
            var U = x.call(A), Z;
            if (x !== A.entries) {
              for (; !(Z = U.next()).done; )
                if (!M(Z.value))
                  return !1;
            } else
              for (; !(Z = U.next()).done; ) {
                var E = Z.value;
                if (E && !M(E[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function z(A, x) {
      return A === "symbol" ? !0 : x ? x["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && x instanceof Symbol : !1;
    }
    function D(A) {
      var x = typeof A;
      return Array.isArray(A) ? "array" : A instanceof RegExp ? "object" : z(x, A) ? "symbol" : x;
    }
    function R(A) {
      if (typeof A > "u" || A === null)
        return "" + A;
      var x = D(A);
      if (x === "object") {
        if (A instanceof Date)
          return "date";
        if (A instanceof RegExp)
          return "regexp";
      }
      return x;
    }
    function W(A) {
      var x = R(A);
      switch (x) {
        case "array":
        case "object":
          return "an " + x;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + x;
        default:
          return x;
      }
    }
    function F(A) {
      return !A.constructor || !A.constructor.name ? d : A.constructor.name;
    }
    return p.checkPropTypes = r, p.resetWarningCache = r.resetWarningCache, p.PropTypes = p, p;
  }, Dp;
}
var Mp, q1;
function Wre() {
  if (q1) return Mp;
  q1 = 1;
  var e = Gg();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mp = function() {
    function r(o, s, l, c, u, f) {
      if (f !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var a = {
      array: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, Mp;
}
if (process.env.NODE_ENV !== "production") {
  var Hre = _C(), Vre = !0;
  Pm.exports = qre()(Hre.isElement, Vre);
} else
  Pm.exports = Wre()();
var Zre = Pm.exports;
const nt = /* @__PURE__ */ Ze(Zre);
var Yg = /* @__PURE__ */ bt.createContext({
  scrollTo: function() {
    return 0;
  },
  scrollToBottom: function() {
    return 0;
  },
  scrollToEnd: function() {
    return 0;
  },
  scrollToStart: function() {
    return 0;
  },
  scrollToTop: function() {
    return 0;
  }
});
Yg.displayName = "ScrollToBottomFunctionContext";
function kC() {
  return Pi(Yg);
}
function Kre() {
  var e = kC(), t = e.scrollToEnd;
  return t;
}
var Jg = /* @__PURE__ */ bt.createContext({
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom"
});
Jg.displayName = "ScrollToBottomState1Context";
var Xg = /* @__PURE__ */ bt.createContext({
  animating: !1,
  animatingToEnd: !1,
  sticky: !0
});
Xg.displayName = "ScrollToBottomState2Context";
var Qg = /* @__PURE__ */ bt.createContext({
  animating: !1,
  animatingToEnd: !1,
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom",
  sticky: !0
});
Qg.displayName = "ScrollToBottomStateContext";
var W1 = [Qg, Jg, Xg];
function Gre(e) {
  return Pi(W1[e] || W1[0]);
}
function $C() {
  var e = Gre(2), t = e.sticky;
  return [t];
}
var Ff = /* @__PURE__ */ bt.createContext({
  offsetHeight: 0,
  scrollHeight: 0,
  setTarget: function() {
    return 0;
  },
  styleToClassName: function() {
    return "";
  }
});
Ff.displayName = "ScrollToBottomInternalContext";
function Yre() {
  return Pi(Ff);
}
function ey() {
  var e = Yre(), t = e.styleToClassName;
  return t;
}
var Jre = {
  backgroundColor: "rgba(0, 0, 0, .2)",
  borderRadius: 10,
  borderWidth: 0,
  bottom: 5,
  cursor: "pointer",
  height: 20,
  outline: 0,
  position: "absolute",
  right: 20,
  width: 20,
  "&:hover": {
    backgroundColor: "rgba(0, 0, 0, .4)"
  },
  "&:active": {
    backgroundColor: "rgba(0, 0, 0, .6)"
  }
}, ty = function(t) {
  var n = t.children, r = t.className, i = $C(), a = _r(i, 1), o = a[0], s = ey()(Jre), l = Kre();
  return !o && /* @__PURE__ */ bt.createElement("button", {
    className: Kg(s, (r || "") + ""),
    onClick: l,
    type: "button"
  }, n);
};
ty.defaultProps = {
  children: void 0,
  className: ""
};
ty.propTypes = {
  children: nt.any,
  className: nt.string
};
var OC = { exports: {} }, Xre = mt, Qre = $n, H1 = pr.f;
Xre({ target: "Object", stat: !0, forced: Object.defineProperty !== H1, sham: !Qre }, {
  defineProperty: H1
});
var eie = nn, TC = eie.Object, tie = OC.exports = function(t, n, r) {
  return TC.defineProperty(t, n, r);
};
TC.defineProperty.sham && (tie.sham = !0);
var nie = OC.exports, rie = nie, CC = rie, iie = CC, aie = iie, oie = aie, sie = oie, lie = sie;
const cie = /* @__PURE__ */ Ze(lie);
var uie = Sl, fie = uie.f("iterator"), die = fie, pie = die, hie = pie, mie = hie, vie = mie, gie = vie, yie = gie;
const bie = /* @__PURE__ */ Ze(yie);
function Gs(e) {
  "@babel/helpers - typeof";
  return Gs = typeof Fa == "function" && typeof bie == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Fa == "function" && t.constructor === Fa && t !== Fa.prototype ? "symbol" : typeof t;
  }, Gs(e);
}
var xie = Sl, wie = xie.f("toPrimitive"), Sie = wie, Eie = Sie, _ie = Eie, kie = _ie, $ie = kie, Oie = $ie, Tie = Oie;
const Cie = /* @__PURE__ */ Ze(Tie);
function Rie(e, t) {
  if (Gs(e) != "object" || !e) return e;
  var n = e[Cie];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Gs(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Iie(e) {
  var t = Rie(e, "string");
  return Gs(t) == "symbol" ? t : t + "";
}
function Aie(e, t, n) {
  return (t = Iie(t)) in e ? cie(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Pie(e) {
  if (gT(e)) return Am(e);
}
function jie(e) {
  if (typeof Fa < "u" && gC(e) != null || e["@@iterator"] != null) return wC(e);
}
function Nie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Qe(e) {
  return Pie(e) || jie(e) || SC(e) || Nie();
}
var sc = function(e) {
  return e && e.Math == Math && e;
}, Nn = (
  // eslint-disable-next-line es/no-global-this -- safe
  sc(typeof globalThis == "object" && globalThis) || sc(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  sc(typeof self == "object" && self) || sc(typeof ft == "object" && ft) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), ny = {}, hr = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, Die = hr, va = !Die(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), RC = {}, IC = {}.propertyIsEnumerable, AC = Object.getOwnPropertyDescriptor, Mie = AC && !IC.call({ 1: 2 }, 1);
RC.f = Mie ? function(t) {
  var n = AC(this, t);
  return !!n && n.enumerable;
} : IC;
var PC = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, Lie = {}.toString, ry = function(e) {
  return Lie.call(e).slice(8, -1);
}, Fie = hr, Bie = ry, zie = "".split, Uie = Fie(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e) {
  return Bie(e) == "String" ? zie.call(e, "") : Object(e);
} : Object, Bf = function(e) {
  if (e == null) throw TypeError("Can't call method on " + e);
  return e;
}, qie = Uie, Wie = Bf, iy = function(e) {
  return qie(Wie(e));
}, Gn = function(e) {
  return typeof e == "function";
}, Hie = Gn, $l = function(e) {
  return typeof e == "object" ? e !== null : Hie(e);
}, Lp = Nn, Vie = Gn, Zie = function(e) {
  return Vie(e) ? e : void 0;
}, zf = function(e, t) {
  return arguments.length < 2 ? Zie(Lp[e]) : Lp[e] && Lp[e][t];
}, Kie = zf, Gie = Kie("navigator", "userAgent") || "", jC = Nn, Fp = Gie, V1 = jC.process, Z1 = jC.Deno, K1 = V1 && V1.versions || Z1 && Z1.version, G1 = K1 && K1.v8, xr, qu;
G1 ? (xr = G1.split("."), qu = xr[0] < 4 ? 1 : xr[0] + xr[1]) : Fp && (xr = Fp.match(/Edge\/(\d+)/), (!xr || xr[1] >= 74) && (xr = Fp.match(/Chrome\/(\d+)/), xr && (qu = xr[1])));
var Yie = qu && +qu, Y1 = Yie, Jie = hr, NC = !!Object.getOwnPropertySymbols && !Jie(function() {
  var e = Symbol();
  return !String(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && Y1 && Y1 < 41;
}), Xie = NC, DC = Xie && !Symbol.sham && typeof Symbol.iterator == "symbol", Qie = Gn, eae = zf, tae = DC, MC = tae ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = eae("Symbol");
  return Qie(t) && Object(e) instanceof t;
}, nae = function(e) {
  try {
    return String(e);
  } catch {
    return "Object";
  }
}, rae = Gn, iae = nae, aae = function(e) {
  if (rae(e)) return e;
  throw TypeError(iae(e) + " is not a function");
}, oae = aae, LC = function(e, t) {
  var n = e[t];
  return n == null ? void 0 : oae(n);
}, Bp = Gn, zp = $l, sae = function(e, t) {
  var n, r;
  if (t === "string" && Bp(n = e.toString) && !zp(r = n.call(e)) || Bp(n = e.valueOf) && !zp(r = n.call(e)) || t !== "string" && Bp(n = e.toString) && !zp(r = n.call(e))) return r;
  throw TypeError("Can't convert object to primitive value");
}, FC = { exports: {} }, J1 = Nn, ay = function(e, t) {
  try {
    Object.defineProperty(J1, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    J1[e] = t;
  }
  return t;
}, lae = Nn, cae = ay, X1 = "__core-js_shared__", uae = lae[X1] || cae(X1, {}), oy = uae, Q1 = oy;
(FC.exports = function(e, t) {
  return Q1[e] || (Q1[e] = t !== void 0 ? t : {});
})("versions", []).push({
  version: "3.18.3",
  mode: "global",
  copyright: " 2021 Denis Pushkarev (zloirock.ru)"
});
var sy = FC.exports, fae = Bf, BC = function(e) {
  return Object(fae(e));
}, dae = BC, pae = {}.hasOwnProperty, ga = Object.hasOwn || function(t, n) {
  return pae.call(dae(t), n);
}, hae = 0, mae = Math.random(), zC = function(e) {
  return "Symbol(" + String(e === void 0 ? "" : e) + ")_" + (++hae + mae).toString(36);
}, vae = Nn, gae = sy, eS = ga, yae = zC, tS = NC, bae = DC, Wo = gae("wks"), ls = vae.Symbol, xae = bae ? ls : ls && ls.withoutSetter || yae, Ol = function(e) {
  return (!eS(Wo, e) || !(tS || typeof Wo[e] == "string")) && (tS && eS(ls, e) ? Wo[e] = ls[e] : Wo[e] = xae("Symbol." + e)), Wo[e];
}, nS = $l, rS = MC, wae = LC, Sae = sae, Eae = Ol, _ae = Eae("toPrimitive"), kae = function(e, t) {
  if (!nS(e) || rS(e)) return e;
  var n = wae(e, _ae), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = n.call(e, t), !nS(r) || rS(r)) return r;
    throw TypeError("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), Sae(e, t);
}, $ae = kae, Oae = MC, UC = function(e) {
  var t = $ae(e, "string");
  return Oae(t) ? t : String(t);
}, Tae = Nn, iS = $l, jm = Tae.document, Cae = iS(jm) && iS(jm.createElement), qC = function(e) {
  return Cae ? jm.createElement(e) : {};
}, Rae = va, Iae = hr, Aae = qC, WC = !Rae && !Iae(function() {
  return Object.defineProperty(Aae("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), Pae = va, jae = RC, Nae = PC, Dae = iy, Mae = UC, Lae = ga, Fae = WC, aS = Object.getOwnPropertyDescriptor;
ny.f = Pae ? aS : function(t, n) {
  if (t = Dae(t), n = Mae(n), Fae) try {
    return aS(t, n);
  } catch {
  }
  if (Lae(t, n)) return Nae(!jae.f.call(t, n), t[n]);
};
var Tl = {}, Bae = $l, Bi = function(e) {
  if (Bae(e)) return e;
  throw TypeError(String(e) + " is not an object");
}, zae = va, Uae = WC, oS = Bi, qae = UC, sS = Object.defineProperty;
Tl.f = zae ? sS : function(t, n, r) {
  if (oS(t), n = qae(n), oS(r), Uae) try {
    return sS(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw TypeError("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var Wae = va, Hae = Tl, Vae = PC, Uf = Wae ? function(e, t, n) {
  return Hae.f(e, t, Vae(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, HC = { exports: {} }, Zae = Gn, Nm = oy, Kae = Function.toString;
Zae(Nm.inspectSource) || (Nm.inspectSource = function(e) {
  return Kae.call(e);
});
var VC = Nm.inspectSource, Gae = Nn, Yae = Gn, Jae = VC, lS = Gae.WeakMap, Xae = Yae(lS) && /native code/.test(Jae(lS)), Qae = sy, eoe = zC, cS = Qae("keys"), ZC = function(e) {
  return cS[e] || (cS[e] = eoe(e));
}, ly = {}, toe = Xae, noe = Nn, roe = $l, ioe = Uf, Up = ga, qp = oy, aoe = ZC, ooe = ly, uS = "Object already initialized", soe = noe.WeakMap, Wu, Ys, Hu, loe = function(e) {
  return Hu(e) ? Ys(e) : Wu(e, {});
}, coe = function(e) {
  return function(t) {
    var n;
    if (!roe(t) || (n = Ys(t)).type !== e)
      throw TypeError("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (toe || qp.state) {
  var qi = qp.state || (qp.state = new soe()), uoe = qi.get, fS = qi.has, foe = qi.set;
  Wu = function(e, t) {
    if (fS.call(qi, e)) throw new TypeError(uS);
    return t.facade = e, foe.call(qi, e, t), t;
  }, Ys = function(e) {
    return uoe.call(qi, e) || {};
  }, Hu = function(e) {
    return fS.call(qi, e);
  };
} else {
  var Ca = aoe("state");
  ooe[Ca] = !0, Wu = function(e, t) {
    if (Up(e, Ca)) throw new TypeError(uS);
    return t.facade = e, ioe(e, Ca, t), t;
  }, Ys = function(e) {
    return Up(e, Ca) ? e[Ca] : {};
  }, Hu = function(e) {
    return Up(e, Ca);
  };
}
var KC = {
  set: Wu,
  get: Ys,
  has: Hu,
  enforce: loe,
  getterFor: coe
}, Dm = va, doe = ga, GC = Function.prototype, poe = Dm && Object.getOwnPropertyDescriptor, cy = doe(GC, "name"), hoe = cy && (function() {
}).name === "something", moe = cy && (!Dm || Dm && poe(GC, "name").configurable), uy = {
  EXISTS: cy,
  PROPER: hoe,
  CONFIGURABLE: moe
}, voe = Nn, dS = Gn, goe = ga, pS = Uf, yoe = ay, boe = VC, YC = KC, xoe = uy.CONFIGURABLE, woe = YC.get, Soe = YC.enforce, Eoe = String(String).split("String");
(HC.exports = function(e, t, n, r) {
  var i = r ? !!r.unsafe : !1, a = r ? !!r.enumerable : !1, o = r ? !!r.noTargetGet : !1, s = r && r.name !== void 0 ? r.name : t, l;
  if (dS(n) && (String(s).slice(0, 7) === "Symbol(" && (s = "[" + String(s).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!goe(n, "name") || xoe && n.name !== s) && pS(n, "name", s), l = Soe(n), l.source || (l.source = Eoe.join(typeof s == "string" ? s : ""))), e === voe) {
    a ? e[t] = n : yoe(t, n);
    return;
  } else i ? !o && e[t] && (a = !0) : delete e[t];
  a ? e[t] = n : pS(e, t, n);
})(Function.prototype, "toString", function() {
  return dS(this) && woe(this).source || boe(this);
});
var Cl = HC.exports, JC = {}, _oe = Math.ceil, koe = Math.floor, qf = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : (t > 0 ? koe : _oe)(t);
}, $oe = qf, Ooe = Math.max, Toe = Math.min, Coe = function(e, t) {
  var n = $oe(e);
  return n < 0 ? Ooe(n + t, 0) : Toe(n, t);
}, Roe = qf, Ioe = Math.min, XC = function(e) {
  return e > 0 ? Ioe(Roe(e), 9007199254740991) : 0;
}, Aoe = XC, Poe = function(e) {
  return Aoe(e.length);
}, joe = iy, Noe = Coe, Doe = Poe, hS = function(e) {
  return function(t, n, r) {
    var i = joe(t), a = Doe(i), o = Noe(r, a), s;
    if (e && n != n) {
      for (; a > o; )
        if (s = i[o++], s != s) return !0;
    } else for (; a > o; o++)
      if ((e || o in i) && i[o] === n) return e || o || 0;
    return !e && -1;
  };
}, Moe = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: hS(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: hS(!1)
}, Wp = ga, Loe = iy, Foe = Moe.indexOf, Boe = ly, QC = function(e, t) {
  var n = Loe(e), r = 0, i = [], a;
  for (a in n) !Wp(Boe, a) && Wp(n, a) && i.push(a);
  for (; t.length > r; ) Wp(n, a = t[r++]) && (~Foe(i, a) || i.push(a));
  return i;
}, fy = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], zoe = QC, Uoe = fy, qoe = Uoe.concat("length", "prototype");
JC.f = Object.getOwnPropertyNames || function(t) {
  return zoe(t, qoe);
};
var eR = {};
eR.f = Object.getOwnPropertySymbols;
var Woe = zf, Hoe = JC, Voe = eR, Zoe = Bi, Koe = Woe("Reflect", "ownKeys") || function(t) {
  var n = Hoe.f(Zoe(t)), r = Voe.f;
  return r ? n.concat(r(t)) : n;
}, Goe = ga, Yoe = Koe, Joe = ny, Xoe = Tl, Qoe = function(e, t) {
  for (var n = Yoe(t), r = Xoe.f, i = Joe.f, a = 0; a < n.length; a++) {
    var o = n[a];
    Goe(e, o) || r(e, o, i(t, o));
  }
}, ese = hr, tse = Gn, nse = /#|\.prototype\./, Rl = function(e, t) {
  var n = ise[rse(e)];
  return n == ose ? !0 : n == ase ? !1 : tse(t) ? ese(t) : !!t;
}, rse = Rl.normalize = function(e) {
  return String(e).replace(nse, ".").toLowerCase();
}, ise = Rl.data = {}, ase = Rl.NATIVE = "N", ose = Rl.POLYFILL = "P", sse = Rl, Hp = Nn, lse = ny.f, cse = Uf, use = Cl, fse = ay, dse = Qoe, pse = sse, hse = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, a, o, s, l, c, u;
  if (r ? o = Hp : i ? o = Hp[n] || fse(n, {}) : o = (Hp[n] || {}).prototype, o) for (s in t) {
    if (c = t[s], e.noTargetGet ? (u = lse(o, s), l = u && u.value) : l = o[s], a = pse(r ? s : n + (i ? "." : "#") + s, e.forced), !a && l !== void 0) {
      if (typeof c == typeof l) continue;
      dse(c, l);
    }
    (e.sham || l && l.sham) && cse(c, "sham", !0), use(o, s, c, e);
  }
}, mse = Ol, vse = mse("toStringTag"), tR = {};
tR[vse] = "z";
var dy = String(tR) === "[object z]", gse = dy, yse = Gn, Bc = ry, bse = Ol, xse = bse("toStringTag"), wse = Bc(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments", Sse = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, nR = gse ? Bc : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = Sse(t = Object(e), xse)) == "string" ? n : wse ? Bc(t) : (r = Bc(t)) == "Object" && yse(t.callee) ? "Arguments" : r;
}, Ese = nR, Wf = function(e) {
  if (Ese(e) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
  return String(e);
}, _se = Bi, rR = function() {
  var e = _se(this), t = "";
  return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t;
}, py = {}, iR = hr, kse = Nn, aR = kse.RegExp;
py.UNSUPPORTED_Y = iR(function() {
  var e = aR("a", "y");
  return e.lastIndex = 2, e.exec("abcd") != null;
});
py.BROKEN_CARET = iR(function() {
  var e = aR("^r", "gy");
  return e.lastIndex = 2, e.exec("str") != null;
});
var $se = QC, Ose = fy, Tse = Object.keys || function(t) {
  return $se(t, Ose);
}, Cse = va, Rse = Tl, Ise = Bi, Ase = Tse, Pse = Cse ? Object.defineProperties : function(t, n) {
  Ise(t);
  for (var r = Ase(n), i = r.length, a = 0, o; i > a; ) Rse.f(t, o = r[a++], n[o]);
  return t;
}, jse = zf, Nse = jse("document", "documentElement"), Dse = Bi, Mse = Pse, mS = fy, Lse = ly, Fse = Nse, Bse = qC, zse = ZC, vS = ">", gS = "<", Mm = "prototype", Lm = "script", oR = zse("IE_PROTO"), Vp = function() {
}, sR = function(e) {
  return gS + Lm + vS + e + gS + "/" + Lm + vS;
}, yS = function(e) {
  e.write(sR("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, Use = function() {
  var e = Bse("iframe"), t = "java" + Lm + ":", n;
  return e.style.display = "none", Fse.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(sR("document.F=Object")), n.close(), n.F;
}, lc, zc = function() {
  try {
    lc = new ActiveXObject("htmlfile");
  } catch {
  }
  zc = typeof document < "u" ? document.domain && lc ? yS(lc) : Use() : yS(lc);
  for (var e = mS.length; e--; ) delete zc[Mm][mS[e]];
  return zc();
};
Lse[oR] = !0;
var qse = Object.create || function(t, n) {
  var r;
  return t !== null ? (Vp[Mm] = Dse(t), r = new Vp(), Vp[Mm] = null, r[oR] = t) : r = zc(), n === void 0 ? r : Mse(r, n);
}, Wse = hr, Hse = Nn, Vse = Hse.RegExp, Zse = Wse(function() {
  var e = Vse(".", "s");
  return !(e.dotAll && e.exec(`
`) && e.flags === "s");
}), Kse = hr, Gse = Nn, Yse = Gse.RegExp, Jse = Kse(function() {
  var e = Yse("(?<a>b)", "g");
  return e.exec("b").groups.a !== "b" || "b".replace(e, "$<a>c") !== "bc";
}), Xse = Wf, Qse = rR, bS = py, ele = sy, tle = qse, nle = KC.get, rle = Zse, ile = Jse, Vu = RegExp.prototype.exec, ale = ele("native-string-replace", String.prototype.replace), Fm = Vu, Bm = function() {
  var e = /a/, t = /b*/g;
  return Vu.call(e, "a"), Vu.call(t, "a"), e.lastIndex !== 0 || t.lastIndex !== 0;
}(), lR = bS.UNSUPPORTED_Y || bS.BROKEN_CARET, zm = /()??/.exec("")[1] !== void 0, ole = Bm || zm || lR || rle || ile;
ole && (Fm = function(t) {
  var n = this, r = nle(n), i = Xse(t), a = r.raw, o, s, l, c, u, f, d;
  if (a)
    return a.lastIndex = n.lastIndex, o = Fm.call(a, i), n.lastIndex = a.lastIndex, o;
  var p = r.groups, h = lR && n.sticky, m = Qse.call(n), y = n.source, v = 0, g = i;
  if (h && (m = m.replace("y", ""), m.indexOf("g") === -1 && (m += "g"), g = i.slice(n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && i.charAt(n.lastIndex - 1) !== `
`) && (y = "(?: " + y + ")", g = " " + g, v++), s = new RegExp("^(?:" + y + ")", m)), zm && (s = new RegExp("^" + y + "$(?!\\s)", m)), Bm && (l = n.lastIndex), c = Vu.call(h ? s : n, g), h ? c ? (c.input = c.input.slice(v), c[0] = c[0].slice(v), c.index = n.lastIndex, n.lastIndex += c[0].length) : n.lastIndex = 0 : Bm && c && (n.lastIndex = n.global ? c.index + c[0].length : l), zm && c && c.length > 1 && ale.call(c[0], s, function() {
    for (u = 1; u < arguments.length - 2; u++)
      arguments[u] === void 0 && (c[u] = void 0);
  }), c && p)
    for (c.groups = f = tle(null), u = 0; u < p.length; u++)
      d = p[u], f[d[0]] = c[d[1]];
  return c;
});
var hy = Fm, sle = hse, xS = hy;
sle({ target: "RegExp", proto: !0, forced: /./.exec !== xS }, {
  exec: xS
});
var wS = Cl, lle = hy, SS = hr, cR = Ol, cle = Uf, ule = cR("species"), Zp = RegExp.prototype, fle = function(e, t, n, r) {
  var i = cR(e), a = !SS(function() {
    var c = {};
    return c[i] = function() {
      return 7;
    }, ""[e](c) != 7;
  }), o = a && !SS(function() {
    var c = !1, u = /a/;
    return e === "split" && (u = {}, u.constructor = {}, u.constructor[ule] = function() {
      return u;
    }, u.flags = "", u[i] = /./[i]), u.exec = function() {
      return c = !0, null;
    }, u[i](""), !c;
  });
  if (!a || !o || n) {
    var s = /./[i], l = t(i, ""[e], function(c, u, f, d, p) {
      var h = u.exec;
      return h === lle || h === Zp.exec ? a && !p ? { done: !0, value: s.call(u, f, d) } : { done: !0, value: c.call(f, u, d) } : { done: !1 };
    });
    wS(String.prototype, e, l[0]), wS(Zp, i, l[1]);
  }
  r && cle(Zp[i], "sham", !0);
}, dle = qf, ple = Wf, hle = Bf, ES = function(e) {
  return function(t, n) {
    var r = ple(hle(t)), i = dle(n), a = r.length, o, s;
    return i < 0 || i >= a ? e ? "" : void 0 : (o = r.charCodeAt(i), o < 55296 || o > 56319 || i + 1 === a || (s = r.charCodeAt(i + 1)) < 56320 || s > 57343 ? e ? r.charAt(i) : o : e ? r.slice(i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);
  };
}, mle = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: ES(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: ES(!0)
}, vle = mle.charAt, gle = function(e, t, n) {
  return t + (n ? vle(e, t).length : 1);
}, yle = BC, ble = Math.floor, xle = "".replace, wle = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Sle = /\$([$&'`]|\d{1,2})/g, Ele = function(e, t, n, r, i, a) {
  var o = n + e.length, s = r.length, l = Sle;
  return i !== void 0 && (i = yle(i), l = wle), xle.call(a, l, function(c, u) {
    var f;
    switch (u.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return e;
      case "`":
        return t.slice(0, n);
      case "'":
        return t.slice(o);
      case "<":
        f = i[u.slice(1, -1)];
        break;
      default:
        var d = +u;
        if (d === 0) return c;
        if (d > s) {
          var p = ble(d / 10);
          return p === 0 ? c : p <= s ? r[p - 1] === void 0 ? u.charAt(1) : r[p - 1] + u.charAt(1) : c;
        }
        f = r[d - 1];
    }
    return f === void 0 ? "" : f;
  });
}, _le = Bi, kle = Gn, $le = ry, Ole = hy, Tle = function(e, t) {
  var n = e.exec;
  if (kle(n)) {
    var r = n.call(e, t);
    return r !== null && _le(r), r;
  }
  if ($le(e) === "RegExp") return Ole.call(e, t);
  throw TypeError("RegExp#exec called on incompatible receiver");
}, Cle = fle, Rle = hr, Ile = Bi, Ale = Gn, Ple = qf, jle = XC, Ra = Wf, Nle = Bf, Dle = gle, Mle = LC, Lle = Ele, Fle = Tle, Ble = Ol, Um = Ble("replace"), zle = Math.max, Ule = Math.min, qle = function(e) {
  return e === void 0 ? e : String(e);
}, Wle = function() {
  return "a".replace(/./, "$0") === "$0";
}(), _S = function() {
  return /./[Um] ? /./[Um]("a", "$0") === "" : !1;
}(), Hle = !Rle(function() {
  var e = /./;
  return e.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(e, "$<a>") !== "7";
});
Cle("replace", function(e, t, n) {
  var r = _S ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(a, o) {
      var s = Nle(this), l = a == null ? void 0 : Mle(a, Um);
      return l ? l.call(a, s, o) : t.call(Ra(s), a, o);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, a) {
      var o = Ile(this), s = Ra(i);
      if (typeof a == "string" && a.indexOf(r) === -1 && a.indexOf("$<") === -1) {
        var l = n(t, o, s, a);
        if (l.done) return l.value;
      }
      var c = Ale(a);
      c || (a = Ra(a));
      var u = o.global;
      if (u) {
        var f = o.unicode;
        o.lastIndex = 0;
      }
      for (var d = []; ; ) {
        var p = Fle(o, s);
        if (p === null || (d.push(p), !u)) break;
        var h = Ra(p[0]);
        h === "" && (o.lastIndex = Dle(s, jle(o.lastIndex), f));
      }
      for (var m = "", y = 0, v = 0; v < d.length; v++) {
        p = d[v];
        for (var g = Ra(p[0]), b = zle(Ule(Ple(p.index), s.length), 0), k = [], S = 1; S < p.length; S++) k.push(qle(p[S]));
        var _ = p.groups;
        if (c) {
          var $ = [g].concat(k, b, s);
          _ !== void 0 && $.push(_);
          var j = Ra(a.apply(void 0, $));
        } else
          j = Lle(g, s, b, k, _, a);
        b >= y && (m += s.slice(y, b) + j, y = b + g.length);
      }
      return m + s.slice(y);
    }
  ];
}, !Hle || !Wle || _S);
var Ho = Vt, Vle = wg, Zle = pa, cc = function(e) {
  return Vle.slice(0, e.length) === e;
}, Kle = function() {
  return cc("Bun/") ? "BUN" : cc("Cloudflare-Workers") ? "CLOUDFLARE" : cc("Deno/") ? "DENO" : cc("Node.js/") ? "NODE" : Ho.Bun && typeof Bun.version == "string" ? "BUN" : Ho.Deno && typeof Deno.version == "object" ? "DENO" : Zle(Ho.process) === "process" ? "NODE" : Ho.window && Ho.document ? "BROWSER" : "REST";
}(), Gle = TypeError, Yle = function(e, t) {
  if (e < t) throw new Gle("Not enough arguments");
  return e;
}, uR = Vt, Jle = vg, Xle = un, Qle = Kle, ece = wg, tce = If, nce = Yle, rce = uR.Function, ice = /MSIE .\./.test(ece) || Qle === "BUN" && function() {
  var e = uR.Bun.version.split(".");
  return e.length < 3 || e[0] === "0" && (e[1] < 3 || e[1] === "3" && e[2] === "0");
}(), fR = function(e, t) {
  var n = t ? 2 : 1;
  return ice ? function(r, i) {
    var a = nce(arguments.length, 1) > n, o = Xle(r) ? r : rce(r), s = a ? tce(arguments, n) : [], l = a ? function() {
      Jle(o, this, s);
    } : o;
    return t ? e(l, i) : e(l);
  } : e;
}, ace = mt, dR = Vt, oce = fR, kS = oce(dR.setInterval, !0);
ace({ global: !0, bind: !0, forced: dR.setInterval !== kS }, {
  setInterval: kS
});
var sce = mt, pR = Vt, lce = fR, $S = lce(pR.setTimeout, !0);
sce({ global: !0, bind: !0, forced: pR.setTimeout !== $S }, {
  setTimeout: $S
});
var cce = nn, uce = cce.setInterval, fce = uce;
const dce = /* @__PURE__ */ Ze(fce);
var pce = Zt, hR = function(e, t) {
  var n = [][e];
  return !!n && pce(function() {
    n.call(null, t || function() {
      return 1;
    }, 1);
  });
}, hce = mt, mce = gg, vce = _T.indexOf, gce = hR, qm = mce([].indexOf), mR = !!qm && 1 / qm([1], 1, -0) < 0, yce = mR || !gce("indexOf");
hce({ target: "Array", proto: !0, forced: yce }, {
  indexOf: function(t) {
    var n = arguments.length > 1 ? arguments[1] : void 0;
    return mR ? qm(this, t, n) || 0 : vce(this, t, n);
  }
});
var bce = ma, xce = bce("Array", "indexOf"), wce = ai, Sce = xce, Kp = Array.prototype, Ece = function(e) {
  var t = e.indexOf;
  return e === Kp || wce(Kp, e) && t === Kp.indexOf ? Sce : t;
}, _ce = Ece, kce = _ce, $ce = kce;
const Oce = /* @__PURE__ */ Ze($ce);
var OS = Ef, Tce = TypeError, Cce = function(e, t) {
  if (!delete e[t]) throw new Tce("Cannot delete property " + OS(t) + " of " + OS(e));
}, Rce = mt, Ice = oi, Ace = jg, Pce = kf, jce = ha, Nce = yC, Dce = Cg, Mce = Pg, Lce = bl, Gp = Cce, Fce = $f, Bce = Fce("splice"), zce = Math.max, Uce = Math.min;
Rce({ target: "Array", proto: !0, forced: !Bce }, {
  splice: function(t, n) {
    var r = Ice(this), i = jce(r), a = Ace(t, i), o = arguments.length, s, l, c, u, f, d;
    for (o === 0 ? s = l = 0 : o === 1 ? (s = 0, l = i - a) : (s = o - 2, l = Uce(zce(Pce(n), 0), i - a)), Dce(i + s - l), c = Mce(r, l), u = 0; u < l; u++)
      f = a + u, f in r && Lce(c, u, r[f]);
    if (c.length = l, s < l) {
      for (u = a; u < i - l; u++)
        f = u + l, d = u + s, f in r ? r[d] = r[f] : Gp(r, d);
      for (u = i; u > i - l + s; u--) Gp(r, u - 1);
    } else if (s > l)
      for (u = i - l; u > a; u--)
        f = u + l - 1, d = u + s - 1, f in r ? r[d] = r[f] : Gp(r, d);
    for (u = 0; u < s; u++)
      r[u + a] = arguments[u + 2];
    return Nce(r, i - l + s), c;
  }
});
var qce = ma, Wce = qce("Array", "splice"), Hce = ai, Vce = Wce, Yp = Array.prototype, Zce = function(e) {
  var t = e.splice;
  return e === Yp || Hce(Yp, e) && t === Yp.splice ? Vce : t;
}, Kce = Zce, Gce = Kce, Yce = Gce;
const Jce = /* @__PURE__ */ Ze(Yce);
var Xce = ma, Qce = Xce("Array", "concat"), eue = ai, tue = Qce, Jp = Array.prototype, nue = function(e) {
  var t = e.concat;
  return e === Jp || eue(Jp, e) && t === Jp.concat ? tue : t;
}, rue = nue, iue = rue, aue = iue;
const _t = /* @__PURE__ */ Ze(aue);
var oue = mt, sue = Kt, vR = Date, lue = sue(vR.prototype.getTime);
oue({ target: "Date", stat: !0 }, {
  now: function() {
    return lue(new vR());
  }
});
var cue = nn, uue = cue.Date.now, fue = uue, due = fue, pue = due;
const Ei = /* @__PURE__ */ Ze(pue);
var hue = Fg.forEach, mue = hR, vue = mue("forEach"), gue = vue ? [].forEach : function(t) {
  return hue(this, t, arguments.length > 1 ? arguments[1] : void 0);
}, yue = mt, TS = gue;
yue({ target: "Array", proto: !0, forced: [].forEach !== TS }, {
  forEach: TS
});
var bue = ma, xue = bue("Array", "forEach"), wue = xue, Sue = wue, Eue = xl, _ue = jn, kue = ai, $ue = Sue, Xp = Array.prototype, Oue = {
  DOMTokenList: !0,
  NodeList: !0
}, Tue = function(e) {
  var t = e.forEach;
  return e === Xp || kue(Xp, e) && t === Xp.forEach || _ue(Oue, Eue(e)) ? $ue : t;
}, Cue = Tue;
const Zu = /* @__PURE__ */ Ze(Cue);
var Rue = mt, Iue = oi, gR = Dg, Aue = Zt, Pue = Aue(function() {
  gR(1);
});
Rue({ target: "Object", stat: !0, forced: Pue }, {
  keys: function(t) {
    return gR(Iue(t));
  }
});
var jue = nn, Nue = jue.Object.keys, Due = Nue, Mue = Due, Lue = Mue;
const Fue = /* @__PURE__ */ Ze(Lue);
var Bue = nn, zue = Bue.Object.getOwnPropertySymbols, Uue = zue, que = Uue, Wue = que;
const CS = /* @__PURE__ */ Ze(Wue);
var Hue = mt, Vue = Fg.filter, Zue = $f, Kue = Zue("filter");
Hue({ target: "Array", proto: !0, forced: !Kue }, {
  filter: function(t) {
    return Vue(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var Gue = ma, Yue = Gue("Array", "filter"), Jue = ai, Xue = Yue, Qp = Array.prototype, Que = function(e) {
  var t = e.filter;
  return e === Qp || Jue(Qp, e) && t === Qp.filter ? Xue : t;
}, efe = Que, tfe = efe, nfe = tfe;
const rfe = /* @__PURE__ */ Ze(nfe);
var yR = { exports: {} }, ife = mt, afe = Zt, ofe = Br, bR = ml.f, xR = $n, sfe = !xR || afe(function() {
  bR(1);
});
ife({ target: "Object", stat: !0, forced: sfe, sham: !xR }, {
  getOwnPropertyDescriptor: function(t, n) {
    return bR(ofe(t), n);
  }
});
var lfe = nn, wR = lfe.Object, cfe = yR.exports = function(t, n) {
  return wR.getOwnPropertyDescriptor(t, n);
};
wR.getOwnPropertyDescriptor.sham && (cfe.sham = !0);
var ufe = yR.exports, ffe = ufe, dfe = ffe, pfe = dfe;
const SR = /* @__PURE__ */ Ze(pfe);
var hfe = zr, mfe = Kt, vfe = Rf, gfe = Af, yfe = Fi, bfe = mfe([].concat), xfe = hfe("Reflect", "ownKeys") || function(t) {
  var n = vfe.f(yfe(t)), r = gfe.f;
  return r ? bfe(n, r(t)) : n;
}, wfe = mt, Sfe = $n, Efe = xfe, _fe = Br, kfe = ml, $fe = bl;
wfe({ target: "Object", stat: !0, sham: !Sfe }, {
  getOwnPropertyDescriptors: function(t) {
    for (var n = _fe(t), r = kfe.f, i = Efe(n), a = {}, o = 0, s, l; i.length > o; )
      l = r(n, s = i[o++]), l !== void 0 && $fe(a, s, l);
    return a;
  }
});
var Ofe = nn, Tfe = Ofe.Object.getOwnPropertyDescriptors, Cfe = Tfe, Rfe = Cfe, Ife = Rfe;
const RS = /* @__PURE__ */ Ze(Ife);
var ER = { exports: {} }, Afe = mt, Pfe = $n, IS = Of.f;
Afe({ target: "Object", stat: !0, forced: Object.defineProperties !== IS, sham: !Pfe }, {
  defineProperties: IS
});
var jfe = nn, _R = jfe.Object, Nfe = ER.exports = function(t, n) {
  return _R.defineProperties(t, n);
};
_R.defineProperties.sham && (Nfe.sham = !0);
var Dfe = ER.exports, Mfe = Dfe, Lfe = Mfe, Ffe = Lfe;
const Bfe = /* @__PURE__ */ Ze(Ffe);
var zfe = CC;
const Ufe = /* @__PURE__ */ Ze(zfe);
var qfe = !1;
function Wfe(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Hfe(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var Vfe = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, a), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !qfe : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Hfe(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = Wfe(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), rn = "-ms-", Ku = "-moz-", ot = "-webkit-", kR = "comm", my = "rule", vy = "decl", Zfe = "@import", $R = "@keyframes", Kfe = "@layer", Gfe = Math.abs, Hf = String.fromCharCode, Yfe = Object.assign;
function Jfe(e, t) {
  return tn(e, 0) ^ 45 ? (((t << 2 ^ tn(e, 0)) << 2 ^ tn(e, 1)) << 2 ^ tn(e, 2)) << 2 ^ tn(e, 3) : 0;
}
function OR(e) {
  return e.trim();
}
function Xfe(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function st(e, t, n) {
  return e.replace(t, n);
}
function Wm(e, t) {
  return e.indexOf(t);
}
function tn(e, t) {
  return e.charCodeAt(t) | 0;
}
function Js(e, t, n) {
  return e.slice(t, n);
}
function $r(e) {
  return e.length;
}
function gy(e) {
  return e.length;
}
function uc(e, t) {
  return t.push(e), e;
}
function Qfe(e, t) {
  return e.map(t).join("");
}
var Vf = 1, ho = 1, TR = 0, En = 0, Lt = 0, To = "";
function Zf(e, t, n, r, i, a, o) {
  return { value: e, root: t, parent: n, type: r, props: i, children: a, line: Vf, column: ho, length: o, return: "" };
}
function Vo(e, t) {
  return Yfe(Zf("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function ede() {
  return Lt;
}
function tde() {
  return Lt = En > 0 ? tn(To, --En) : 0, ho--, Lt === 10 && (ho = 1, Vf--), Lt;
}
function Pn() {
  return Lt = En < TR ? tn(To, En++) : 0, ho++, Lt === 10 && (ho = 1, Vf++), Lt;
}
function Cr() {
  return tn(To, En);
}
function Uc() {
  return En;
}
function Il(e, t) {
  return Js(To, e, t);
}
function Xs(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function CR(e) {
  return Vf = ho = 1, TR = $r(To = e), En = 0, [];
}
function RR(e) {
  return To = "", e;
}
function qc(e) {
  return OR(Il(En - 1, Hm(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function nde(e) {
  for (; (Lt = Cr()) && Lt < 33; )
    Pn();
  return Xs(e) > 2 || Xs(Lt) > 3 ? "" : " ";
}
function rde(e, t) {
  for (; --t && Pn() && !(Lt < 48 || Lt > 102 || Lt > 57 && Lt < 65 || Lt > 70 && Lt < 97); )
    ;
  return Il(e, Uc() + (t < 6 && Cr() == 32 && Pn() == 32));
}
function Hm(e) {
  for (; Pn(); )
    switch (Lt) {
      case e:
        return En;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Hm(Lt);
        break;
      case 40:
        e === 41 && Hm(e);
        break;
      case 92:
        Pn();
        break;
    }
  return En;
}
function ide(e, t) {
  for (; Pn() && e + Lt !== 57; )
    if (e + Lt === 84 && Cr() === 47)
      break;
  return "/*" + Il(t, En - 1) + "*" + Hf(e === 47 ? e : Pn());
}
function ade(e) {
  for (; !Xs(Cr()); )
    Pn();
  return Il(e, En);
}
function ode(e) {
  return RR(Wc("", null, null, null, [""], e = CR(e), 0, [0], e));
}
function Wc(e, t, n, r, i, a, o, s, l) {
  for (var c = 0, u = 0, f = o, d = 0, p = 0, h = 0, m = 1, y = 1, v = 1, g = 0, b = "", k = i, S = a, _ = r, $ = b; y; )
    switch (h = g, g = Pn()) {
      case 40:
        if (h != 108 && tn($, f - 1) == 58) {
          Wm($ += st(qc(g), "&", "&\f"), "&\f") != -1 && (v = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        $ += qc(g);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        $ += nde(h);
        break;
      case 92:
        $ += rde(Uc() - 1, 7);
        continue;
      case 47:
        switch (Cr()) {
          case 42:
          case 47:
            uc(sde(ide(Pn(), Uc()), t, n), l);
            break;
          default:
            $ += "/";
        }
        break;
      case 123 * m:
        s[c++] = $r($) * v;
      case 125 * m:
      case 59:
      case 0:
        switch (g) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            v == -1 && ($ = st($, /\f/g, "")), p > 0 && $r($) - f && uc(p > 32 ? PS($ + ";", r, n, f - 1) : PS(st($, " ", "") + ";", r, n, f - 2), l);
            break;
          case 59:
            $ += ";";
          default:
            if (uc(_ = AS($, t, n, c, u, i, s, b, k = [], S = [], f), a), g === 123)
              if (u === 0)
                Wc($, t, _, _, k, a, f, s, S);
              else
                switch (d === 99 && tn($, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Wc(e, _, _, r && uc(AS(e, _, _, 0, 0, i, s, b, i, k = [], f), S), i, S, f, s, r ? k : S);
                    break;
                  default:
                    Wc($, _, _, _, [""], S, 0, s, S);
                }
        }
        c = u = p = 0, m = v = 1, b = $ = "", f = o;
        break;
      case 58:
        f = 1 + $r($), p = h;
      default:
        if (m < 1) {
          if (g == 123)
            --m;
          else if (g == 125 && m++ == 0 && tde() == 125)
            continue;
        }
        switch ($ += Hf(g), g * m) {
          case 38:
            v = u > 0 ? 1 : ($ += "\f", -1);
            break;
          case 44:
            s[c++] = ($r($) - 1) * v, v = 1;
            break;
          case 64:
            Cr() === 45 && ($ += qc(Pn())), d = Cr(), u = f = $r(b = $ += ade(Uc())), g++;
            break;
          case 45:
            h === 45 && $r($) == 2 && (m = 0);
        }
    }
  return a;
}
function AS(e, t, n, r, i, a, o, s, l, c, u) {
  for (var f = i - 1, d = i === 0 ? a : [""], p = gy(d), h = 0, m = 0, y = 0; h < r; ++h)
    for (var v = 0, g = Js(e, f + 1, f = Gfe(m = o[h])), b = e; v < p; ++v)
      (b = OR(m > 0 ? d[v] + " " + g : st(g, /&\f/g, d[v]))) && (l[y++] = b);
  return Zf(e, t, n, i === 0 ? my : s, l, c, u);
}
function sde(e, t, n) {
  return Zf(e, t, n, kR, Hf(ede()), Js(e, 2, -2), 0);
}
function PS(e, t, n, r) {
  return Zf(e, t, n, vy, Js(e, 0, r), Js(e, r + 1, -1), r);
}
function Va(e, t) {
  for (var n = "", r = gy(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function lde(e, t, n, r) {
  switch (e.type) {
    case Kfe:
      if (e.children.length) break;
    case Zfe:
    case vy:
      return e.return = e.return || e.value;
    case kR:
      return "";
    case $R:
      return e.return = e.value + "{" + Va(e.children, r) + "}";
    case my:
      e.value = e.props.join(",");
  }
  return $r(n = Va(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function cde(e) {
  var t = gy(e);
  return function(n, r, i, a) {
    for (var o = "", s = 0; s < t; s++)
      o += e[s](n, r, i, a) || "";
    return o;
  };
}
function ude(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function fde(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var dde = function(t, n, r) {
  for (var i = 0, a = 0; i = a, a = Cr(), i === 38 && a === 12 && (n[r] = 1), !Xs(a); )
    Pn();
  return Il(t, En);
}, pde = function(t, n) {
  var r = -1, i = 44;
  do
    switch (Xs(i)) {
      case 0:
        i === 38 && Cr() === 12 && (n[r] = 1), t[r] += dde(En - 1, n, r);
        break;
      case 2:
        t[r] += qc(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Cr() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += Hf(i);
    }
  while (i = Pn());
  return t;
}, hde = function(t, n) {
  return RR(pde(CR(t), n));
}, jS = /* @__PURE__ */ new WeakMap(), mde = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !jS.get(r)) && !i) {
      jS.set(t, !0);
      for (var a = [], o = hde(n, a), s = r.props, l = 0, c = 0; l < o.length; l++)
        for (var u = 0; u < s.length; u++, c++)
          t.props[c] = a[l] ? o[l].replace(/&\f/g, s[u]) : s[u] + " " + o[l];
    }
  }
}, vde = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function IR(e, t) {
  switch (Jfe(e, t)) {
    case 5103:
      return ot + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ot + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ot + e + Ku + e + rn + e + e;
    case 6828:
    case 4268:
      return ot + e + rn + e + e;
    case 6165:
      return ot + e + rn + "flex-" + e + e;
    case 5187:
      return ot + e + st(e, /(\w+).+(:[^]+)/, ot + "box-$1$2" + rn + "flex-$1$2") + e;
    case 5443:
      return ot + e + rn + "flex-item-" + st(e, /flex-|-self/, "") + e;
    case 4675:
      return ot + e + rn + "flex-line-pack" + st(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return ot + e + rn + st(e, "shrink", "negative") + e;
    case 5292:
      return ot + e + rn + st(e, "basis", "preferred-size") + e;
    case 6060:
      return ot + "box-" + st(e, "-grow", "") + ot + e + rn + st(e, "grow", "positive") + e;
    case 4554:
      return ot + st(e, /([^-])(transform)/g, "$1" + ot + "$2") + e;
    case 6187:
      return st(st(st(e, /(zoom-|grab)/, ot + "$1"), /(image-set)/, ot + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return st(e, /(image-set\([^]*)/, ot + "$1$`$1");
    case 4968:
      return st(st(e, /(.+:)(flex-)?(.*)/, ot + "box-pack:$3" + rn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ot + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return st(e, /(.+)-inline(.+)/, ot + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if ($r(e) - 1 - t > 6) switch (tn(e, t + 1)) {
        case 109:
          if (tn(e, t + 4) !== 45) break;
        case 102:
          return st(e, /(.+:)(.+)-([^]+)/, "$1" + ot + "$2-$3$1" + Ku + (tn(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~Wm(e, "stretch") ? IR(st(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (tn(e, t + 1) !== 115) break;
    case 6444:
      switch (tn(e, $r(e) - 3 - (~Wm(e, "!important") && 10))) {
        case 107:
          return st(e, ":", ":" + ot) + e;
        case 101:
          return st(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ot + (tn(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ot + "$2$3$1" + rn + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (tn(e, t + 11)) {
        case 114:
          return ot + e + rn + st(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return ot + e + rn + st(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return ot + e + rn + st(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ot + e + rn + e + e;
  }
  return e;
}
var gde = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case vy:
      t.return = IR(t.value, t.length);
      break;
    case $R:
      return Va([Vo(t, {
        value: st(t.value, "@", "@" + ot)
      })], i);
    case my:
      if (t.length) return Qfe(t.props, function(a) {
        switch (Xfe(a, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return Va([Vo(t, {
              props: [st(a, /:(read-\w+)/, ":" + Ku + "$1")]
            })], i);
          case "::placeholder":
            return Va([Vo(t, {
              props: [st(a, /:(plac\w+)/, ":" + ot + "input-$1")]
            }), Vo(t, {
              props: [st(a, /:(plac\w+)/, ":" + Ku + "$1")]
            }), Vo(t, {
              props: [st(a, /:(plac\w+)/, rn + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, yde = [gde], bde = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(m) {
      var y = m.getAttribute("data-emotion");
      y.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || yde, a = {}, o, s = [];
  o = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(m) {
      for (var y = m.getAttribute("data-emotion").split(" "), v = 1; v < y.length; v++)
        a[y[v]] = !0;
      s.push(m);
    }
  );
  var l, c = [mde, vde];
  {
    var u, f = [lde, ude(function(m) {
      u.insert(m);
    })], d = cde(c.concat(i, f)), p = function(y) {
      return Va(ode(y), d);
    };
    l = function(y, v, g, b) {
      u = g, p(y ? y + "{" + v.styles + "}" : v.styles), b && (h.inserted[v.name] = !0);
    };
  }
  var h = {
    key: n,
    sheet: new Vfe({
      key: n,
      container: o,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: l
  };
  return h.sheet.hydrate(s), h;
};
function xde(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var wde = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Sde = !1, Ede = /[A-Z]|^ms/g, _de = /_EMO_([^_]+?)_([^]*?)_EMO_/g, AR = function(t) {
  return t.charCodeAt(1) === 45;
}, NS = function(t) {
  return t != null && typeof t != "boolean";
}, eh = /* @__PURE__ */ fde(function(e) {
  return AR(e) ? e : e.replace(Ede, "-$&").toLowerCase();
}), DS = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(_de, function(r, i, a) {
          return yi = {
            name: i,
            styles: a,
            next: yi
          }, i;
        });
  }
  return wde[t] !== 1 && !AR(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, kde = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function Gu(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return yi = {
          name: i.name,
          styles: i.styles,
          next: yi
        }, i.name;
      var a = n;
      if (a.styles !== void 0) {
        var o = a.next;
        if (o !== void 0)
          for (; o !== void 0; )
            yi = {
              name: o.name,
              styles: o.styles,
              next: yi
            }, o = o.next;
        var s = a.styles + ";";
        return s;
      }
      return $de(e, t, n);
    }
  }
  var l = n;
  if (t == null)
    return l;
  var c = t[l];
  return c !== void 0 ? c : l;
}
function $de(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Gu(e, t, n[i]) + ";";
  else
    for (var a in n) {
      var o = n[a];
      if (typeof o != "object") {
        var s = o;
        t != null && t[s] !== void 0 ? r += a + "{" + t[s] + "}" : NS(s) && (r += eh(a) + ":" + DS(a, s) + ";");
      } else {
        if (a === "NO_COMPONENT_SELECTOR" && Sde)
          throw new Error(kde);
        if (Array.isArray(o) && typeof o[0] == "string" && (t == null || t[o[0]] === void 0))
          for (var l = 0; l < o.length; l++)
            NS(o[l]) && (r += eh(a) + ":" + DS(a, o[l]) + ";");
        else {
          var c = Gu(e, t, o);
          switch (a) {
            case "animation":
            case "animationName": {
              r += eh(a) + ":" + c + ";";
              break;
            }
            default:
              r += a + "{" + c + "}";
          }
        }
      }
    }
  return r;
}
var MS = /label:\s*([^\s;{]+)\s*(;|$)/g, yi;
function th(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  yi = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, i += Gu(n, t, a);
  else {
    var o = a;
    i += o[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += Gu(n, t, e[s]), r) {
      var l = a;
      i += l[s];
    }
  MS.lastIndex = 0;
  for (var c = "", u; (u = MS.exec(i)) !== null; )
    c += "-" + u[1];
  var f = xde(i) + c;
  return {
    name: f,
    styles: i,
    next: yi
  };
}
function PR(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Ode = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, Tde = function(t, n, r) {
  Ode(t, n);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + i : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function LS(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function FS(e, t, n) {
  var r = [], i = PR(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var Cde = function(t) {
  var n = bde(t);
  n.sheet.speedy = function(s) {
    if (process.env.NODE_ENV !== "production" && this.ctr !== 0)
      throw new Error("speedy must be changed before any rules are inserted");
    this.isSpeedy = s;
  }, n.compat = !0;
  var r = function() {
    for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
      c[u] = arguments[u];
    var f = th(c, n.registered, void 0);
    return Tde(n, f), n.key + "-" + f.name;
  }, i = function() {
    for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
      c[u] = arguments[u];
    var f = th(c, n.registered), d = "animation-" + f.name;
    return LS(n, {
      name: f.name,
      styles: "@keyframes " + d + "{" + f.styles + "}"
    }), d;
  }, a = function() {
    for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
      c[u] = arguments[u];
    var f = th(c, n.registered);
    LS(n, f);
  }, o = function() {
    for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
      c[u] = arguments[u];
    return FS(n.registered, r, Rde(c));
  };
  return {
    css: r,
    cx: o,
    injectGlobal: a,
    keyframes: i,
    hydrate: function(l) {
      l.forEach(function(c) {
        n.inserted[c] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    // $FlowFixMe
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: PR.bind(null, n.registered),
    merge: FS.bind(null, n.registered, r)
  };
}, Rde = function e(t) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    if (i != null) {
      var a = void 0;
      switch (typeof i) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(i))
            a = e(i);
          else {
            a = "";
            for (var o in i)
              i[o] && o && (a && (a += " "), a += o);
          }
          break;
        }
        default:
          a = i;
      }
      a && (n && (n += " "), n += a);
    }
  }
  return n;
}, Ide = Cl, yy = Date.prototype, BS = "Invalid Date", jR = "toString", Ade = yy[jR], Pde = yy.getTime;
String(/* @__PURE__ */ new Date(NaN)) != BS && Ide(yy, jR, function() {
  var t = Pde.call(this);
  return t === t ? Ade.call(this) : BS;
});
var jde = dy, Nde = nR, Dde = jde ? {}.toString : function() {
  return "[object " + Nde(this) + "]";
}, Mde = dy, Lde = Cl, Fde = Dde;
Mde || Lde(Object.prototype, "toString", Fde, { unsafe: !0 });
var Bde = uy.PROPER, zde = Cl, Ude = Bi, zS = Wf, qde = hr, Wde = rR, by = "toString", NR = RegExp.prototype, DR = NR[by], Hde = qde(function() {
  return DR.call({ source: "a", flags: "b" }) != "/a/b";
}), Vde = Bde && DR.name != by;
(Hde || Vde) && zde(RegExp.prototype, by, function() {
  var t = Ude(this), n = zS(t.source), r = t.flags, i = zS(r === void 0 && t instanceof RegExp && !("flags" in NR) ? Wde.call(t) : r);
  return "/" + n + "/" + i;
}, { unsafe: !0 });
var US = typeof window < "u" ? window : self, Zde = US.crypto || US.msCrypto, Kde = function(e) {
  if (!e) return Math.random;
  var t = Math.pow(2, 32), n = new Uint32Array(1);
  return function() {
    return e.getRandomValues(n)[0] / t;
  };
}(Zde);
const Gde = /* @__PURE__ */ Ze(Kde);
function Yde() {
  return Gde().toString(26).substr(2, 5).replace(/[0-9]/g, function(e) {
    return String.fromCharCode(e.charCodeAt(0) + 65);
  });
}
var Jde = vT;
const qS = /* @__PURE__ */ Ze(Jde);
function pt(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "white", n = "background-color: ".concat(e, "; border-radius: 4px; padding: 2px 4px;");
  return t && (n += " color: ".concat(t, ";")), [n, ""];
}
function WS(e, t) {
  for (var n, r, i = arguments.length, a = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)
    a[o - 2] = arguments[o];
  return _t(n = [_t(r = "%c".concat(e, "%c ")).call(r, t)]).call(n, Qe(pt("green", "white")), a);
}
function Xde(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.force, r = n === void 0 ? !1 : n;
  return r ? function() {
    for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    if (a.length) {
      var s = a, l = _r(s, 1), c = l[0];
      typeof c == "function" && (a = c());
      var u = qS(a[0]) ? a : [a], f = u.length === 1;
      Zu(u).call(u, function(d, p) {
        if (f) {
          var h, m;
          (h = console).log.apply(h, Qe(WS.apply(void 0, _t(m = [e]).call(m, Qe(d)))));
        } else if (p) {
          var y;
          (y = console).log.apply(y, Qe(qS(d) ? d : [d]));
        } else {
          var v, g;
          (v = console).groupCollapsed.apply(v, Qe(WS.apply(void 0, _t(g = [e]).call(g, Qe(d)))));
        }
      }), f || console.groupEnd();
    }
  } : function() {
    return 0;
  };
}
var Qde = va, epe = uy.EXISTS, tpe = Tl.f, MR = Function.prototype, npe = MR.toString, rpe = /^\s*function ([^ (]*)/, ipe = "name";
Qde && !epe && tpe(MR, ipe, {
  configurable: !0,
  get: function() {
    try {
      return npe.call(this).match(rpe)[1];
    } catch {
      return "";
    }
  }
});
var ape = nn, ope = ape.setTimeout, spe = ope;
const lpe = /* @__PURE__ */ Ze(spe);
function cpe(e, t) {
  if (!t)
    return e;
  var n = 0, r = null;
  return function() {
    for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    var s = Ei();
    s - n > t ? (e.apply(void 0, a), n = s) : (clearTimeout(r), r = lpe(function() {
      e.apply(void 0, a), n = Ei();
    }, Math.max(0, t - s + n)));
  };
}
var LR = function(t) {
  var n = t.debounce, r = t.name, i = t.onEvent, a = t.target, o = Pt();
  o.current = i;
  var s = Sr(function() {
    return cpe(function(c) {
      var u = o.current;
      u && u(c);
    }, n);
  }, [n, o]), l = Et(function(c) {
    c.timeStampLow = Ei(), s(c);
  }, [s]);
  return mo(function() {
    return a.addEventListener(r, l, {
      passive: !0
    }), l({
      target: a,
      type: r
    }), function() {
      return a.removeEventListener(r, l);
    };
  }, [r, l, a]), !1;
};
LR.defaultProps = {
  debounce: 200
};
var upe = Math.sign || function(t) {
  var n = +t;
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
}, fpe = mt, dpe = upe;
fpe({ target: "Math", stat: !0 }, {
  sign: dpe
});
var ppe = nn, hpe = ppe.Math.sign, mpe = hpe, vpe = mpe, gpe = vpe;
const ype = /* @__PURE__ */ Ze(gpe);
function bpe(e, t) {
  var n = ype(t - e), r = Math.sqrt(Math.abs(t - e)), i = e + r * n;
  return n > 0 ? Math.min(t, i) : Math.max(t, i);
}
function xpe(e, t, n, r) {
  for (var i = e, a = 0; a < r; a++)
    i = n(i, t);
  return i;
}
var FR = function(t) {
  var n = t.name, r = t.onEnd, i = t.target, a = t.value, o = Pt(), s = Et(function(c, u, f, d) {
    var p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Ei();
    (f === "100%" || typeof f == "number") && (cancelAnimationFrame(o.current), o.current = requestAnimationFrame(function() {
      if (i) {
        var h = f === "100%" ? i.scrollHeight - i.offsetHeight : f, m = xpe(u, h, bpe, (Ei() - p) / 5);
        Math.abs(h - m) < 1.5 && (m = h), i[c] = m, h === m ? r && r(!0) : s(c, u, f, d + 1, p);
      }
    }));
  }, [o, r, i]), l = Et(function() {
    cancelAnimationFrame(o.current), r && r(!1);
  }, [r]);
  return mo(function() {
    return s(n, i[n], a, 1), i ? (i.addEventListener("pointerdown", l, {
      passive: !0
    }), i.addEventListener("wheel", l, {
      passive: !0
    }), function() {
      i.removeEventListener("pointerdown", l), i.removeEventListener("wheel", l), cancelAnimationFrame(o.current);
    }) : function() {
      return cancelAnimationFrame(o.current);
    };
  }, [s, o, l, n, i, a]), !1;
};
FR.propTypes = {
  name: nt.string.isRequired,
  onEnd: nt.func,
  target: nt.any.isRequired,
  value: nt.oneOfType([nt.number, nt.oneOf(["100%"])]).isRequired
};
function nh(e) {
  var t = ht(e), n = _r(t, 2), r = n[0], i = n[1], a = Pt(), o = Et(function(s) {
    typeof s == "function" ? o(function(l) {
      return s = s(l), a.current = s, s;
    }) : (a.current = s, o(s));
  }, [a]);
  return a.current = r, [r, i, a];
}
function HS(e, t) {
  var n = Fue(e);
  if (CS) {
    var r = CS(e);
    t && (r = rfe(r).call(r, function(i) {
      return SR(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    if (t % 2) {
      var r;
      Zu(r = HS(Object(n), !0)).call(r, function(a) {
        Aie(e, a, n[a]);
      });
    } else if (RS)
      Bfe(e, RS(n));
    else {
      var i;
      Zu(i = HS(Object(n))).call(i, function(a) {
        Ufe(e, a, SR(n, a));
      });
    }
  }
  return e;
}
var wpe = function() {
  return 1 / 0;
}, ZS = 17, Spe = "bottom", er = "top", KS = 1, Epe = 34, GS = {};
function _pe(e, t) {
  return e(), dce(e, t);
}
function YS(e) {
  var t = e.mode, n = e.target, r = n.offsetHeight, i = n.scrollHeight, a = n.scrollTop, o = i - a - r < KS, s = a < KS, l = t === er ? s : o, c = t !== er ? s : o;
  return {
    atBottom: o,
    atEnd: l,
    atStart: c,
    atTop: s
  };
}
function Zo(e, t) {
  return e === (t === er ? 0 : "100%");
}
var xy = function(t) {
  var n = t.checkInterval, r = t.children, i = t.debounce, a = t.debug, o = t.initialScrollBehavior, s = t.mode, l = t.nonce, c = t.scroller, u = Sr(function() {
    return Xde("<ScrollToBottom>", {
      force: a
    });
  }, [a]);
  s = s === er ? er : Spe;
  var f = Pt(0), d = Pt(o), p = nh(s === er ? 0 : "100%"), h = _r(p, 3), m = h[0], y = h[1], v = h[2], g = nh(null), b = _r(g, 3), k = b[0], S = b[1], _ = b[2], $ = Pt(0), j = Pt(0), B = Pt(0), O = ht(!0), N = _r(O, 2), q = N[0], M = N[1], z = ht(!0), D = _r(z, 2), R = D[0], W = D[1], F = ht(!0), A = _r(F, 2), x = A[0], U = A[1], Z = ht(!1), E = _r(Z, 2), X = E[0], ae = E[1], te = nh(!0), se = _r(te, 3), de = se[0], pe = se[1], le = se[2], J = Pt([]), V = Et(function(P) {
    var Y = _.current;
    return J.current.push(P), Y && P({
      scrollTop: Y.scrollTop
    }), function() {
      var ce = J.current, Ee = Oce(ce).call(ce, P);
      ~Ee && Jce(ce).call(ce, Ee, 1);
    };
  }, [J, _]), fe = Et(function() {
    var P = v.current;
    u(function() {
      var Y;
      return _t(Y = ["%cSpineTo%c: %conEnd%c is fired."]).call(Y, Qe(pt("magenta")), Qe(pt("orange")), [{
        animateTo: P
      }]);
    }), f.current = Ei(), Zo(P, s) || pe(!1), y(null);
  }, [v, u, f, s, y, pe]), me = Et(function(P) {
    var Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ce = Y.behavior, Ee = _.current;
    if (typeof P != "number" && P !== "100%")
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    u(function() {
      var $e;
      return [_t($e = ["%cscrollTo%c: Will scroll to %c".concat(typeof P == "number" ? P + "px" : P.replace(/%/g, "%%"), "%c")]).call($e, Qe(pt("lime", "")), Qe(pt("purple"))), {
        behavior: ce,
        nextAnimateTo: P,
        target: Ee
      }];
    }), ce === "auto" ? (fe(), Ee && (Ee.scrollTop = P === "100%" ? Ee.scrollHeight - Ee.offsetHeight : P)) : (ce !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), y(P)), Zo(P, s) && (u(function() {
      var $e;
      return [_t($e = ["%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c."]).call($e, Qe(pt("lime", "")), Qe(pt("purple"))), [{
        mode: s,
        nextAnimateTo: P
      }]];
    }), pe(!0));
  }, [u, fe, s, y, pe, _]), Oe = Et(function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Y = P.behavior;
    u(function() {
      var ce;
      return _t(ce = ["%cscrollToBottom%c: Called"]).call(ce, Qe(pt("yellow", "")));
    }), Y !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), me("100%", {
      behavior: Y || "smooth"
    });
  }, [u, me]), I = Et(function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Y = P.behavior;
    u(function() {
      var ce;
      return _t(ce = ["%cscrollToTop%c: Called"]).call(ce, Qe(pt("yellow", "")));
    }), Y !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), me(0, {
      behavior: Y || "smooth"
    });
  }, [u, me]), G = Et(function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Y = P.behavior;
    u(function() {
      var Ee;
      return _t(Ee = ["%cscrollToEnd%c: Called"]).call(Ee, Qe(pt("yellow", "")));
    }), Y !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ce = {
      behavior: Y || "smooth"
    };
    s === er ? I(ce) : Oe(ce);
  }, [u, s, Oe, I]), re = Et(function() {
    var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Y = P.behavior;
    u(function() {
      var Ee;
      return _t(Ee = ["%cscrollToStart%c: Called"]).call(Ee, Qe(pt("yellow", "")));
    }), Y !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ce = {
      behavior: Y || "smooth"
    };
    s === er ? Oe(ce) : I(ce);
  }, [u, s, Oe, I]), Q = Et(function() {
    var P = _.current;
    if (P) {
      if (d.current === "auto") {
        u(function() {
          var It;
          return _t(It = ["%ctarget changed%c: Initial scroll"]).call(It, Qe(pt("blue")));
        }), P.scrollTop = s === er ? 0 : P.scrollHeight - P.offsetHeight, d.current = !1;
        return;
      }
      var Y = $.current, ce = P.offsetHeight, Ee = P.scrollHeight, $e = P.scrollTop, Ye = s === er ? 0 : Math.max(0, Ee - ce - $e), at = Math.max(0, Y - $e), Bt = c({
        maxValue: Ye,
        minValue: at,
        offsetHeight: ce,
        scrollHeight: Ee,
        scrollTop: $e
      }), Rt = Math.max(0, Math.min(Ye, Bt)), He;
      s === er || Rt !== Ye ? He = $e + Rt : He = "100%", u(function() {
        var It, Je, vn;
        return [_t(It = [_t(Je = _t(vn = "%cscrollToSticky%c: Will animate from %c".concat(Y, "px%c to %c")).call(vn, typeof He == "number" ? He + "px" : He.replace(/%/g, "%%"), "%c (%c")).call(Je, (He === "100%" ? Ye : He) + Y, "px%c)")]).call(It, Qe(pt("orange")), Qe(pt("purple")), Qe(pt("purple")), Qe(pt("purple"))), {
          animateFrom: Y,
          maxValue: Ye,
          minValue: at,
          nextAnimateTo: He,
          nextValue: Rt,
          offsetHeight: ce,
          rawNextValue: Bt,
          scrollHeight: Ee,
          scrollTop: $e
        }];
      }), me(He, {
        behavior: "smooth"
      });
    }
  }, [$, u, s, c, me, _]), _e = Et(function(P) {
    var Y, ce = P.timeStampLow, Ee = v.current, $e = _.current, Ye = Ee !== null;
    if (!(ce <= f.current || !$e)) {
      var at = YS({
        mode: s,
        target: $e
      }), Bt = at.atBottom, Rt = at.atEnd, He = at.atStart, It = at.atTop;
      M(Bt), W(Rt), ae(He), U(It);
      var Je = $e.offsetHeight, vn = $e.scrollHeight, On = j.current, Yn = B.current, Ur = Je !== On, mr = vn !== Yn;
      if (Ur && (j.current = Je), mr && (B.current = vn), !Ur && !mr) {
        var Jn = Ye && Zo(Ee, s) || Rt;
        le.current !== Jn && (u(function() {
          var dt, St, zt, Ut;
          return [_t(dt = ["%conScroll%c: %csetSticky%c(%c".concat(Jn, "%c)")]).call(dt, Qe(pt("red")), Qe(pt("red")), Qe(pt("purple"))), _t(St = [_t(zt = _t(Ut = "(animating = %c".concat(Ye, "%c && isEnd = %c")).call(Ut, Zo(Ee, s), "%c) || atEnd = %c")).call(zt, Rt, "%c")]).call(St, Qe(pt("purple")), Qe(pt("purple")), Qe(pt("purple")), [{
            animating: Ye,
            animateTo: Ee,
            atEnd: Rt,
            mode: s,
            offsetHeight: $e.offsetHeight,
            scrollHeight: $e.scrollHeight,
            sticky: le.current,
            nextSticky: Jn
          }])];
        }), pe(Jn));
      } else le.current && (u(function() {
        var dt;
        return [_t(dt = ["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"]).call(dt, Qe(pt("red")), Qe(pt("orange")), [{
          offsetHeightChanged: Ur,
          scrollHeightChanged: mr
        }]), {
          nextOffsetHeight: Je,
          prevOffsetHeight: On,
          nextScrollHeight: vn,
          prevScrollHeight: Yn
        }];
      }), Q());
      var qr = $e.scrollTop;
      Zu(Y = J.current).call(Y, function(dt) {
        return dt({
          scrollTop: qr
        });
      });
    }
  }, [v, u, f, s, j, B, J, Q, M, W, ae, U, pe, le, _]);
  $t(function() {
    if (k) {
      var P = !1, Y = _pe(function() {
        var ce = _.current, Ee = v.current !== null;
        le.current ? YS({
          mode: s,
          target: ce
        }).atEnd ? P = !1 : P ? Ei() - P > Epe && (Ee || ($.current = ce.scrollTop, u(function() {
          var $e;
          return _t($e = ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"]).call($e, Qe(pt("navy")), Qe(pt("orange")));
        }), Q()), P = !1) : P = Ei() : ce.scrollHeight <= ce.offsetHeight && !le.current && (u(function() {
          var $e;
          return [_t($e = ["%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c"]).call($e, Qe(pt("navy")), Qe(pt("purple"))), [{
            offsetHeight: ce.offsetHeight,
            scrollHeight: ce.scrollHeight,
            sticky: le.current
          }]];
        }), pe(!0));
      }, Math.max(ZS, n) || ZS);
      return function() {
        return clearInterval(Y);
      };
    }
  }, [v, n, u, s, Q, pe, le, k, _]);
  var xe = Sr(function() {
    var P = GS[l] || (GS[l] = Cde({
      key: "react-scroll-to-bottom--css-" + Yde(),
      nonce: l
    }));
    return function(Y) {
      return P.css(Y) + "";
    };
  }, [l]), Ce = Sr(function() {
    return {
      observeScrollPosition: V,
      setTarget: S,
      styleToClassName: xe
    };
  }, [V, S, xe]), We = Sr(function() {
    return {
      atBottom: q,
      atEnd: R,
      atStart: X,
      atTop: x,
      mode: s
    };
  }, [q, R, X, x, s]), Ie = Sr(function() {
    var P = m !== null;
    return {
      animating: P,
      animatingToEnd: P && Zo(m, s),
      sticky: de
    };
  }, [m, s, de]), Me = Sr(function() {
    return VS(VS({}, We), Ie);
  }, [We, Ie]), L = Sr(function() {
    return {
      scrollTo: me,
      scrollToBottom: Oe,
      scrollToEnd: G,
      scrollToStart: re,
      scrollToTop: I
    };
  }, [me, Oe, G, re, I]);
  return $t(function() {
    if (k) {
      var P = function() {
        B.current = k.scrollHeight;
      };
      return k.addEventListener("focus", P, {
        capture: !0,
        passive: !0
      }), function() {
        return k.removeEventListener("focus", P);
      };
    }
  }, [k]), u(function() {
    var P;
    return [_t(P = ["%cRender%c: Render"]).call(P, Qe(pt("cyan", ""))), {
      animateTo: m,
      animating: m !== null,
      sticky: de,
      target: k
    }];
  }), /* @__PURE__ */ bt.createElement(Ff.Provider, {
    value: Ce
  }, /* @__PURE__ */ bt.createElement(Yg.Provider, {
    value: L
  }, /* @__PURE__ */ bt.createElement(Qg.Provider, {
    value: Me
  }, /* @__PURE__ */ bt.createElement(Jg.Provider, {
    value: We
  }, /* @__PURE__ */ bt.createElement(Xg.Provider, {
    value: Ie
  }, r, k && /* @__PURE__ */ bt.createElement(LR, {
    debounce: i,
    name: "scroll",
    onEvent: _e,
    target: k
  }), k && m !== null && /* @__PURE__ */ bt.createElement(FR, {
    name: "scrollTop",
    onEnd: fe,
    target: k,
    value: m
  }))))));
};
xy.defaultProps = {
  checkInterval: 100,
  children: void 0,
  debounce: 17,
  debug: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: wpe
};
xy.propTypes = {
  checkInterval: nt.number,
  children: nt.any,
  debounce: nt.number,
  debug: nt.bool,
  initialScrollBehavior: nt.oneOf(["auto", "smooth"]),
  mode: nt.oneOf(["bottom", "top"]),
  nonce: nt.string,
  scroller: nt.func
};
var kpe = {
  height: "100%",
  overflowY: "auto",
  width: "100%"
}, wy = function(t) {
  var n = t.children, r = t.className, i = Pi(Ff), a = i.setTarget, o = ey()(kpe);
  return /* @__PURE__ */ bt.createElement("div", {
    className: Kg(o, (r || "") + ""),
    ref: a
  }, n);
};
wy.defaultProps = {
  children: void 0,
  className: void 0
};
wy.propTypes = {
  children: nt.any,
  className: nt.string
};
var $pe = {
  position: "relative"
}, Sy = function(t) {
  var n = t.children, r = t.className, i = t.followButtonClassName, a = t.scrollViewClassName, o = ey()($pe);
  return /* @__PURE__ */ bt.createElement("div", {
    className: Kg(o, (r || "") + "")
  }, /* @__PURE__ */ bt.createElement(wy, {
    className: (a || "") + ""
  }, n), /* @__PURE__ */ bt.createElement(ty, {
    className: (i || "") + ""
  }));
};
Sy.defaultProps = {
  children: void 0,
  className: void 0,
  followButtonClassName: void 0,
  scrollViewClassName: void 0
};
Sy.propTypes = {
  children: nt.any,
  className: nt.string,
  followButtonClassName: nt.string,
  scrollViewClassName: nt.string
};
var Ey = function(t) {
  var n = t.checkInterval, r = t.children, i = t.className, a = t.debounce, o = t.debug, s = t.followButtonClassName, l = t.initialScrollBehavior, c = t.mode, u = t.nonce, f = t.scroller, d = t.scrollViewClassName;
  return /* @__PURE__ */ bt.createElement(xy, {
    checkInterval: n,
    debounce: a,
    debug: o,
    initialScrollBehavior: l,
    mode: c,
    nonce: u,
    scroller: f
  }, /* @__PURE__ */ bt.createElement(Sy, {
    className: i,
    followButtonClassName: s,
    scrollViewClassName: d
  }, r));
};
Ey.defaultProps = {
  checkInterval: void 0,
  children: void 0,
  className: void 0,
  debounce: void 0,
  debug: void 0,
  followButtonClassName: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: void 0,
  scrollViewClassName: void 0
};
Ey.propTypes = {
  checkInterval: nt.number,
  children: nt.any,
  className: nt.string,
  debounce: nt.number,
  debug: nt.bool,
  followButtonClassName: nt.string,
  initialScrollBehavior: nt.oneOf(["auto", "smooth"]),
  mode: nt.oneOf(["bottom", "top"]),
  nonce: nt.string,
  scroller: nt.func,
  scrollViewClassName: nt.string
};
function Ope() {
  var e = kC(), t = e.scrollToBottom;
  return t;
}
HZ();
const Tpe = Ju(
  ({ scrollDownButton: e, className: t, ...n }) => {
    const { messageList: r } = xt, i = Rn((g) => g.conversationId), a = De((g) => g.messages)[i ?? ""] ?? [], o = De((g) => g.setState), s = De((g) => g.client), l = De((g) => g.messageContainerRef), c = De((g) => g.isTyping), u = De((g) => g.setIsTyping), f = De((g) => g.headerMessage), d = Sr(() => WI(a), [a]), [p, h] = ht(!0), { y: m } = $U(l), y = Et(() => {
      if (!l.current) return;
      const { scrollHeight: g } = l.current;
      p && l.current.scrollTo({ top: g });
    }, []);
    $t(() => s == null ? void 0 : s.on("isTyping", ({ isTyping: g, timeout: b }) => {
      u(g, b);
    }), []), $t(() => {
      const g = a[a.length - 1];
      o({ disableComposer: !!(g != null && g.disableInput) });
    }, [a.length]), $t(() => {
      if (!l.current) return;
      const { offsetHeight: g, scrollHeight: b, scrollTop: k } = l.current;
      h(b <= k + g + 100);
    }, [m]);
    const v = e != null && e.icon ? e == null ? void 0 : e.icon : n7;
    return /* @__PURE__ */ C.jsxs(
      Ey,
      {
        ...n,
        className: Nv(r.container.className, t),
        followButtonClassName: "bpHidden",
        scrollViewClassName: r.viewPort.className,
        children: [
          f && /* @__PURE__ */ C.jsx("span", { ...r.headerMessage, children: f }),
          /* @__PURE__ */ C.jsx(qZ, {}),
          d.map((g) => /* @__PURE__ */ C.jsx(p0, { scroll: y, ...g }, g.id)),
          c && /* @__PURE__ */ C.jsx(p0, { scroll: y, direction: "incoming", children: /* @__PURE__ */ C.jsx(UZ, {}) }),
          /* @__PURE__ */ C.jsx("li", { "data-is-at-bottom": p, ...r.scrollDownButton.container, children: /* @__PURE__ */ C.jsxs(Cpe, { children: [
            (e == null ? void 0 : e.text) ?? "Back",
            " ",
            /* @__PURE__ */ C.jsx(v, { ...r.scrollDownButton.icon })
          ] }) })
        ]
      }
    );
  }
), Cpe = (e) => {
  const [t] = $C(), n = Ope(), {
    messageList: { scrollDownButton: r }
  } = xt;
  return !t && /* @__PURE__ */ C.jsx("button", { type: "button", ...r.button, onClick: () => n(), ...e });
}, vhe = () => {
  const { color: e, fontFamily: t, radius: n, themeMode: r, variant: i } = v$(), a = Sr(
    () => rP({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i }),
    [e, t, n, r, i]
  );
  return /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsxs(AZ, { children: [
      /* @__PURE__ */ C.jsx(zZ, {}),
      /* @__PURE__ */ C.jsx(Tpe, {}),
      /* @__PURE__ */ C.jsx(xq, {})
    ] }),
    /* @__PURE__ */ C.jsx("style", { children: a })
  ] });
};
export {
  AE as Avatar,
  hl as Block,
  xq as Composer,
  AZ as Container,
  hhe as Fab,
  zZ as Header,
  p0 as Message,
  Tpe as MessageList,
  la as Modal,
  wq as ModalProvider,
  FZ as RestartConversation,
  UZ as TypingIndicator,
  vhe as Webchat,
  uhe as WebchatProvider,
  IE as WebchatThemeSchema,
  Ppe as __adapters,
  Yf as avatarThemeSchema,
  XA as blockThemeSchema,
  nP as configPropsSchema,
  GA as configurationSchema,
  JA as cssStyleSchema,
  Po as descriptionItemSchema,
  wz as fileTypes,
  rP as generateThemeStylesheet,
  Oz as getClient,
  lhe as initPropsSchema,
  Sz as isFileType,
  YA as markdownTypeSchema,
  J9 as renderers,
  eP as statePropsSchema,
  ue as styleOptionSchema,
  QA as themeSchema,
  che as useClient,
  De as useWebchatStore,
  tP as userPropsSchema,
  xt as webchatClasses
};
