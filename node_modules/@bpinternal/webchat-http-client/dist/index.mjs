var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
import axios2 from "axios";

// src/gen/client/index.ts
import axios from "axios";

// src/gen/client/errors.ts
import crypto from "crypto";
var cryptoLibPolyfill = {
  getRandomValues: (array) => new Uint8Array(array.map(() => Math.floor(Math.random() * 256)))
};
var cryptoLib = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.crypto : crypto;
if (!cryptoLib.getRandomValues) {
  cryptoLib = cryptoLibPolyfill;
}
var BaseApiError = class extends Error {
  constructor(code, description, type, message, error, id) {
    super(message);
    this.code = code;
    this.description = description;
    this.type = type;
    this.message = message;
    this.error = error;
    this.id = id;
    if (!this.id) {
      this.id = BaseApiError.generateId();
    }
  }
  isApiError = true;
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const prefix = this.getPrefix();
    const timestamp = new Date().toISOString().replace(/[\-:TZ]/g, "").split(".")[0];
    const randomSuffixByteLength = 4;
    const randomHexSuffix = Array.from(cryptoLib.getRandomValues(new Uint8Array(randomSuffixByteLength))).map((x) => x.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${prefix}_${timestamp}x${randomHexSuffix}`;
  }
  static getPrefix() {
    if (typeof window !== "undefined" && typeof window.document !== "undefined") {
      return "err_bwsr";
    }
    return "err";
  }
};
var isObject = (obj) => typeof obj === "object" && !Array.isArray(obj) && obj !== null;
var isApiError = (thrown) => {
  return thrown instanceof BaseApiError || isObject(thrown) && thrown.isApiError === true;
};
var UnknownError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An unknown error occurred", "Unknown", message, error, id);
  }
};
var InternalError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An internal error occurred", "Internal", message, error, id);
  }
};
var UnauthorizedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(401, "The request requires to be authenticated.", "Unauthorized", message, error, id);
  }
};
var ForbiddenError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", message, error, id);
  }
};
var PayloadTooLargeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request payload is too large.", "PayloadTooLarge", message, error, id);
  }
};
var InvalidPayloadError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The request payload is invalid.", "InvalidPayload", message, error, id);
  }
};
var UnsupportedMediaTypeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", message, error, id);
  }
};
var MethodNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(405, "The requested method does not exist.", "MethodNotFound", message, error, id);
  }
};
var ResourceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", message, error, id);
  }
};
var InvalidJsonSchemaError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", message, error, id);
  }
};
var InvalidDataFormatError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", message, error, id);
  }
};
var InvalidIdentifierError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", message, error, id);
  }
};
var RelationConflictError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", message, error, id);
  }
};
var ReferenceConstraintError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", message, error, id);
  }
};
var ResourceLockedConflictError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource is current locked and cannot be operated on until the lock is released.", "ResourceLockedConflict", message, error, id);
  }
};
var ReferenceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", message, error, id);
  }
};
var InvalidQueryError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", message, error, id);
  }
};
var RuntimeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", message, error, id);
  }
};
var AlreadyExistsError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", message, error, id);
  }
};
var RateLimitedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(429, "The request has been rate limited.", "RateLimited", message, error, id);
  }
};
var PaymentRequiredError = class extends BaseApiError {
  constructor(message, error, id) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", message, error, id);
  }
};
var QuotaExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", message, error, id);
  }
};
var LimitExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", message, error, id);
  }
};
var BreakingChangesError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", message, error, id);
  }
};
var errorTypes = {
  Unknown: UnknownError,
  Internal: InternalError,
  Unauthorized: UnauthorizedError,
  Forbidden: ForbiddenError,
  PayloadTooLarge: PayloadTooLargeError,
  InvalidPayload: InvalidPayloadError,
  UnsupportedMediaType: UnsupportedMediaTypeError,
  MethodNotFound: MethodNotFoundError,
  ResourceNotFound: ResourceNotFoundError,
  InvalidJsonSchema: InvalidJsonSchemaError,
  InvalidDataFormat: InvalidDataFormatError,
  InvalidIdentifier: InvalidIdentifierError,
  RelationConflict: RelationConflictError,
  ReferenceConstraint: ReferenceConstraintError,
  ResourceLockedConflict: ResourceLockedConflictError,
  ReferenceNotFound: ReferenceNotFoundError,
  InvalidQuery: InvalidQueryError,
  Runtime: RuntimeError,
  AlreadyExists: AlreadyExistsError,
  RateLimited: RateLimitedError,
  PaymentRequired: PaymentRequiredError,
  QuotaExceeded: QuotaExceededError,
  LimitExceeded: LimitExceededError,
  BreakingChanges: BreakingChangesError
};
var errorFrom = (err) => {
  if (isApiError(err)) {
    return err;
  } else if (err instanceof Error) {
    return new UnknownError(err.message, err);
  } else if (typeof err === "string") {
    return new UnknownError(err);
  } else {
    return getApiErrorFromObject(err);
  }
};
function getApiErrorFromObject(err) {
  if (typeof err === "object" && "code" in err && "type" in err && "id" in err && "message" in err && typeof err.type === "string" && typeof err.message === "string") {
    const ErrorClass = errorTypes[err.type];
    if (!ErrorClass) {
      return new UnknownError(`An unclassified API error occurred: ${err.message} (Type: ${err.type}, Code: ${err.code})`);
    }
    return new ErrorClass(err.message, void 0, err.id || "UNKNOWN");
  }
  return new UnknownError("An invalid error occurred: " + JSON.stringify(err));
}

// src/gen/client/to-axios.ts
import qs from "qs";
var isDefined = (pair) => pair[1] !== void 0;
var toAxiosRequest = (req) => {
  const { method, path, query, headers: headerParams, body: data } = req;
  const headerEntries = Object.entries(headerParams).filter(isDefined);
  const headers = Object.fromEntries(headerEntries);
  const queryString = qs.stringify(query, { encode: true, arrayFormat: "repeat", allowDots: true });
  const url = queryString ? [path, queryString].join("?") : path;
  return {
    method,
    url,
    headers,
    data
  };
};

// src/gen/client/operations/getConversation.ts
var parseReq = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/createConversation.ts
var parseReq2 = (input) => {
  return {
    path: `/conversations`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "_": input["_"] }
  };
};

// src/gen/client/operations/deleteConversation.ts
var parseReq3 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/listConversations.ts
var parseReq4 = (input) => {
  return {
    path: `/conversations`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: {},
    body: {}
  };
};

// src/gen/client/operations/listenConversation.ts
var parseReq5 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/listen`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/listConversationMessages.ts
var parseReq6 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/messages`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/addParticipant.ts
var parseReq7 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: { "userId": input["userId"] }
  };
};

// src/gen/client/operations/removeParticipant.ts
var parseReq8 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants/${encodeURIComponent(input["userId"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"], "userId": input["userId"] },
    body: {}
  };
};

// src/gen/client/operations/getParticipant.ts
var parseReq9 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants/${encodeURIComponent(input["userId"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"], "userId": input["userId"] },
    body: {}
  };
};

// src/gen/client/operations/listParticipants.ts
var parseReq10 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/getMessage.ts
var parseReq11 = (input) => {
  return {
    path: `/messages/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/createMessage.ts
var parseReq12 = (input) => {
  return {
    path: `/messages`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "payload": input["payload"], "conversationId": input["conversationId"], "metadata": input["metadata"] }
  };
};

// src/gen/client/operations/deleteMessage.ts
var parseReq13 = (input) => {
  return {
    path: `/messages/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/getUser.ts
var parseReq14 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: {}
  };
};

// src/gen/client/operations/createUser.ts
var parseReq15 = (input) => {
  return {
    path: `/users`,
    headers: {},
    query: {},
    params: {},
    body: { "name": input["name"], "pictureUrl": input["pictureUrl"], "userData": input["userData"] }
  };
};

// src/gen/client/operations/updateUser.ts
var parseReq16 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "name": input["name"], "pictureUrl": input["pictureUrl"], "userData": input["userData"] }
  };
};

// src/gen/client/operations/deleteUser.ts
var parseReq17 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: {}
  };
};

// src/gen/client/operations/getEvent.ts
var parseReq18 = (input) => {
  return {
    path: `/events/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/createEvent.ts
var parseReq19 = (input) => {
  return {
    path: `/events`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "payload": input["payload"], "conversationId": input["conversationId"], "bindConversation": input["bindConversation"], "bindUser": input["bindUser"] }
  };
};

// src/gen/client/operations/createFile.ts
var parseReq20 = (input) => {
  return {
    path: `/files`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "key": input["key"], "size": input["size"], "accessPolicies": input["accessPolicies"], "index": input["index"], "contentType": input["contentType"], "tags": input["tags"] }
  };
};

// src/gen/client/index.ts
var Client = class {
  constructor(axiosInstance, props = {}) {
    this.axiosInstance = axiosInstance;
    this.props = props;
  }
  getConversation = async (input) => {
    const { path, headers, query, body } = parseReq(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createConversation = async (input) => {
    const { path, headers, query, body } = parseReq2(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteConversation = async (input) => {
    const { path, headers, query, body } = parseReq3(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listConversations = async (input) => {
    const { path, headers, query, body } = parseReq4(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listenConversation = async (input) => {
    const { path, headers, query, body } = parseReq5(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listConversationMessages = async (input) => {
    const { path, headers, query, body } = parseReq6(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  addParticipant = async (input) => {
    const { path, headers, query, body } = parseReq7(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  removeParticipant = async (input) => {
    const { path, headers, query, body } = parseReq8(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getParticipant = async (input) => {
    const { path, headers, query, body } = parseReq9(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listParticipants = async (input) => {
    const { path, headers, query, body } = parseReq10(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getMessage = async (input) => {
    const { path, headers, query, body } = parseReq11(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createMessage = async (input) => {
    const { path, headers, query, body } = parseReq12(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteMessage = async (input) => {
    const { path, headers, query, body } = parseReq13(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getUser = async (input) => {
    const { path, headers, query, body } = parseReq14(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createUser = async (input) => {
    const { path, headers, query, body } = parseReq15(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  updateUser = async (input) => {
    const { path, headers, query, body } = parseReq16(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "put",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteUser = async (input) => {
    const { path, headers, query, body } = parseReq17(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getEvent = async (input) => {
    const { path, headers, query, body } = parseReq18(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createEvent = async (input) => {
    const { path, headers, query, body } = parseReq19(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createFile = async (input) => {
    const { path, headers, query, body } = parseReq20(input);
    const mapper = this.props.toAxiosRequest ?? toAxiosRequest;
    const axiosReq = mapper({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
};
function getError(err) {
  if (axios.isAxiosError(err) && err.response?.data) {
    return errorFrom(err.response.data);
  }
  return errorFrom(err);
}

// src/event-emitter.ts
var EventEmitter = class {
  listeners = {};
  emit(type, event) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    for (const listener of [...listeners]) {
      listener(event);
    }
  }
  onceOrMore(type, listener) {
    const wrapped = (event) => {
      const status = listener(event);
      if (status === "stop-listening") {
        this.off(type, wrapped);
      }
    };
    this.on(type, wrapped);
  }
  once(type, listener) {
    const wrapped = (event) => {
      this.off(type, wrapped);
      listener(event);
    };
    this.on(type, wrapped);
  }
  on(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(listener);
  }
  off(type, listener) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  cleanup() {
    this.listeners = {};
  }
};

// src/eventsource.ts
import EventSource from "event-source-polyfill";
var makeEventSource = (url, props) => {
  const source = new EventSource.EventSourcePolyfill(url, {
    headers: props.headers,
    heartbeatTimeout: props.timeout
  });
  const emitter = new EventEmitter();
  source.onopen = (ev) => emitter.emit("open", ev);
  source.onmessage = (ev) => emitter.emit("message", ev);
  source.onerror = (ev) => emitter.emit("error", ev);
  return {
    emitter,
    source
  };
};
var listenEventSource = async (url, props = {}) => {
  const { emitter, source } = makeEventSource(url, props);
  await new Promise((resolve, reject) => {
    emitter.on("open", () => {
      resolve();
    });
    emitter.on("error", (thrown) => {
      reject(thrown);
    });
  }).finally(() => emitter.cleanup());
  return {
    on: emitter.on.bind(emitter),
    close: () => {
      emitter.cleanup();
      source.close();
    }
  };
};

// src/gen/signals/messageCreated.z.ts
import { z } from "zod";
var messageCreated_z_default = z.object({
  type: z.literal("message_created"),
  data: z.object({
    id: z.string().describe("Id of the [Message](#schema_message)"),
    createdAt: z.string().datetime().describe(
      "Creation date of the [Message](#schema_message) in ISO 8601 format"
    ),
    payload: z.union([
      z.object({ audioUrl: z.string().min(1), type: z.literal("audio") }),
      z.object({
        title: z.string().min(1),
        subtitle: z.string().min(1).optional(),
        imageUrl: z.string().min(1).optional(),
        actions: z.array(
          z.object({
            action: z.enum(["postback", "url", "say"]),
            label: z.string().min(1),
            value: z.string().min(1)
          })
        ),
        type: z.literal("card")
      }),
      z.object({
        items: z.array(
          z.object({
            title: z.string().min(1),
            subtitle: z.string().min(1).optional(),
            imageUrl: z.string().min(1).optional(),
            actions: z.array(
              z.object({
                action: z.enum(["postback", "url", "say"]),
                label: z.string().min(1),
                value: z.string().min(1)
              })
            )
          })
        ),
        type: z.literal("carousel")
      }),
      z.object({
        text: z.string().min(1),
        options: z.array(
          z.object({ label: z.string().min(1), value: z.string().min(1) })
        ),
        type: z.literal("choice"),
        disableFreeText: z.boolean().optional()
      }),
      z.object({
        text: z.string().min(1),
        options: z.array(
          z.object({ label: z.string().min(1), value: z.string().min(1) })
        ),
        type: z.literal("dropdown")
      }),
      z.object({
        fileUrl: z.string().min(1),
        title: z.string().min(1).optional(),
        type: z.literal("file")
      }),
      z.object({ imageUrl: z.string().min(1), type: z.literal("image") }),
      z.object({
        latitude: z.number(),
        longitude: z.number(),
        address: z.string().optional(),
        title: z.string().optional(),
        type: z.literal("location")
      }),
      z.object({
        text: z.string().min(1),
        type: z.literal("text"),
        value: z.string().optional()
      }),
      z.object({ videoUrl: z.string().min(1), type: z.literal("video") }),
      z.object({
        items: z.array(
          z.union([
            z.object({
              type: z.literal("text"),
              payload: z.object({ text: z.string().min(1) })
            }),
            z.object({
              type: z.literal("markdown"),
              payload: z.object({ markdown: z.string().min(1) })
            }),
            z.object({
              type: z.literal("image"),
              payload: z.object({ imageUrl: z.string().min(1) })
            }),
            z.object({
              type: z.literal("audio"),
              payload: z.object({ audioUrl: z.string().min(1) })
            }),
            z.object({
              type: z.literal("video"),
              payload: z.object({ videoUrl: z.string().min(1) })
            }),
            z.object({
              type: z.literal("file"),
              payload: z.object({
                fileUrl: z.string().min(1),
                title: z.string().min(1).optional()
              })
            }),
            z.object({
              type: z.literal("location"),
              payload: z.object({
                latitude: z.number(),
                longitude: z.number(),
                address: z.string().optional(),
                title: z.string().optional()
              })
            })
          ])
        ),
        type: z.literal("bloc")
      }),
      z.object({
        markdown: z.string().min(1),
        type: z.literal("markdown")
      })
    ]).describe("Payload is the content type of the message."),
    userId: z.string().describe("ID of the [User](#schema_user)"),
    conversationId: z.string().describe("ID of the [Conversation](#schema_conversation)"),
    metadata: z.record(z.union([z.any(), z.null()])).describe("Metadata of the message").optional()
  }).describe(
    "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user)."
  )
});

// src/gen/signals/webchatVisibility.z.ts
import { z as z2 } from "zod";
var webchatVisibility_z_default = z2.object({
  type: z2.literal("webchat_visibility"),
  data: z2.object({
    visibility: z2.union([
      z2.literal("show"),
      z2.literal("hide"),
      z2.literal("toggle")
    ])
  })
});

// src/gen/signals/webchatConfig.z.ts
import { z as z3 } from "zod";
var webchatConfig_z_default = z3.object({
  type: z3.literal("webchat_config"),
  data: z3.object({ config: z3.record(z3.union([z3.any(), z3.null()])) })
});

// src/gen/signals/custom.z.ts
import { z as z4 } from "zod";
var custom_z_default = z4.object({
  type: z4.literal("custom"),
  data: z4.object({ event: z4.record(z4.union([z4.any(), z4.null()])) })
});

// src/gen/signals/typingStarted.z.ts
import { z as z5 } from "zod";
var typingStarted_z_default = z5.object({
  type: z5.literal("typing_started"),
  data: z5.object({ timeout: z5.number().optional() })
});

// src/gen/signals/typingStopped.z.ts
import { z as z6 } from "zod";
var typingStopped_z_default = z6.object({ type: z6.literal("typing_stopped"), data: z6.record(z6.never()) });

// src/gen/signals/index.ts
var zod = {
  messageCreated: messageCreated_z_default,
  webchatVisibility: webchatVisibility_z_default,
  webchatConfig: webchatConfig_z_default,
  custom: custom_z_default,
  typingStarted: typingStarted_z_default,
  typingStopped: typingStopped_z_default
};

// src/signal-listener.ts
var DEFAULT_ERROR_MESSAGE = "unknown error";
var _SignalListener = class extends EventEmitter {
  constructor(_props) {
    super();
    this._props = _props;
  }
  _state = { status: "disconnected" };
  get status() {
    return this._state.status;
  }
  connect = async () => {
    if (this._state.status === "connected") {
      return;
    }
    if (this._state.status === "connecting") {
      await this._state.connectionPromise;
      return;
    }
    const connectionPromise = this._connect();
    this._state = { status: "connecting", connectionPromise };
    await connectionPromise;
  };
  disconnect = async () => {
    if (this._state.status === "disconnected") {
      return;
    }
    let source;
    if (this._state.status === "connecting") {
      source = await this._state.connectionPromise;
    } else {
      source = this._state.source;
    }
    this._disconnectSync(source);
  };
  _connect = async () => {
    const source = await listenEventSource(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
      headers: { "x-user-key": this._props.userKey },
      timeout: this._props.timeout
    });
    source.on("message", this._handleMessage);
    source.on("error", this._handleError(source));
    this._state = { status: "connected", source };
    return source;
  };
  _disconnectSync = (source) => {
    source.close();
    this._state = { status: "disconnected" };
  };
  _handleMessage = (ev) => {
    const signal = this._parseSignal(ev.data);
    this.emit(signal.type, signal.data);
  };
  _handleError = (source) => (ev) => {
    this._disconnectSync(source);
    const err = this._toError(ev);
    this.emit("error", err);
  };
  _parseSignal = (data) => {
    for (const schema of Object.values(zod)) {
      const parsedData = this._safeJsonParse(data);
      const parseResult = schema.safeParse(parsedData);
      if (parseResult.success) {
        return parseResult.data;
      }
    }
    return {
      type: "unknown",
      data
    };
  };
  _safeJsonParse = (x) => {
    try {
      return JSON.parse(x);
    } catch {
      return x;
    }
  };
  _toError = (thrown) => {
    if (thrown instanceof Error) {
      return thrown;
    }
    if (typeof thrown === "string") {
      return new Error(thrown);
    }
    if (thrown === null) {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
    if (typeof thrown === "object" && "message" in thrown) {
      return this._toError(thrown.message);
    }
    try {
      const json = JSON.stringify(thrown);
      return new Error(json);
    } catch {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
  };
};
var SignalListener = _SignalListener;
__publicField(SignalListener, "listen", async (props) => {
  const inst = new _SignalListener(props);
  await inst.connect();
  return inst;
});

// src/index.ts
var _100mb = 100 * 1024 * 1024;
var maxBodyLength = _100mb;
var maxContentLength = _100mb;
var defaultHttpTimeout = 6e4;
var Client2 = class {
  constructor(props) {
    this.props = props;
    const { apiUrl: baseURL } = props;
    const headers = {
      ...props.headers
    };
    const timeout = this.props.timeout ?? defaultHttpTimeout;
    const axiosClient = axios2.create({
      baseURL,
      headers,
      withCredentials: true,
      timeout,
      maxBodyLength,
      maxContentLength
    });
    this._auto = new Client(axiosClient);
  }
  _auto;
  createConversation = (x) => this._auto.createConversation(x);
  getConversation = (x) => this._auto.getConversation(x);
  deleteConversation = (x) => this._auto.deleteConversation(x);
  listConversations = (x) => this._auto.listConversations(x);
  listConversationMessages = (x) => this._auto.listConversationMessages(x);
  addParticipant = (x) => this._auto.addParticipant(x);
  removeParticipant = (x) => this._auto.removeParticipant(x);
  getParticipant = (x) => this._auto.getParticipant(x);
  listParticipants = (x) => this._auto.listParticipants(x);
  createMessage = (x) => this._auto.createMessage(x);
  getMessage = (x) => this._auto.getMessage(x);
  deleteMessage = (x) => this._auto.deleteMessage(x);
  createFile = (x) => this._auto.createFile(x);
  createUser = (x) => this._auto.createUser(x);
  getUser = (x) => this._auto.getUser(x);
  updateUser = (x) => this._auto.updateUser(x);
  deleteUser = (x) => this._auto.deleteUser(x);
  createEvent = (x) => this._auto.createEvent(x);
  getEvent = (x) => this._auto.getEvent(x);
  listenConversation = async ({
    id,
    "x-user-key": userKey
  }) => {
    const signalListener = await SignalListener.listen({
      url: this.props.apiUrl,
      conversationId: id,
      userKey,
      timeout: this.props.sseTimeout
    });
    return signalListener;
  };
};
export {
  AlreadyExistsError,
  BreakingChangesError,
  Client2 as Client,
  ForbiddenError,
  InternalError,
  InvalidDataFormatError,
  InvalidIdentifierError,
  InvalidJsonSchemaError,
  InvalidPayloadError,
  InvalidQueryError,
  LimitExceededError,
  MethodNotFoundError,
  PayloadTooLargeError,
  PaymentRequiredError,
  QuotaExceededError,
  RateLimitedError,
  ReferenceConstraintError,
  ReferenceNotFoundError,
  RelationConflictError,
  ResourceLockedConflictError,
  ResourceNotFoundError,
  RuntimeError,
  SignalListener,
  UnauthorizedError,
  UnknownError,
  UnsupportedMediaTypeError,
  errorFrom,
  isApiError
};
//# sourceMappingURL=index.mjs.map
